/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}

impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }

    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];

        let bit_index = index % 8;
        let mask = 1 << bit_index;

        byte & mask == mask
    }

    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];

        let bit_index = index % 8;
        let mask = 1 << bit_index;

        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }

    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        let mut val = 0;

        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                val |= 1 << i;
            }
        }

        val
    }

    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            self.set_bit(i + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ptr(&self) -> *const T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut_ptr(&mut self) -> *mut T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
impl<T> ::core::clone::Clone for __IncompleteArrayField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::core::marker::Copy for __IncompleteArrayField<T> {}
#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self {
        __BindgenUnionField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::core::mem::transmute(self)
    }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
pub const _NEWLIB_VERSION_H__: u32 = 1;
pub const _NEWLIB_VERSION: &'static [u8; 6usize] = b"3.0.0\0";
pub const __NEWLIB__: u32 = 3;
pub const __NEWLIB_MINOR__: u32 = 0;
pub const __NEWLIB_PATCHLEVEL__: u32 = 0;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __ATFILE_VISIBLE: u32 = 1;
pub const __BSD_VISIBLE: u32 = 1;
pub const __GNU_VISIBLE: u32 = 0;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __LARGEFILE_VISIBLE: u32 = 0;
pub const __MISC_VISIBLE: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __SVID_VISIBLE: u32 = 1;
pub const __XSI_VISIBLE: u32 = 0;
pub const __SSP_FORTIFY_LEVEL: u32 = 0;
pub const __have_longlong64: u32 = 1;
pub const __have_long32: u32 = 1;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const ___int_least8_t_defined: u32 = 1;
pub const ___int_least16_t_defined: u32 = 1;
pub const ___int_least32_t_defined: u32 = 1;
pub const ___int_least64_t_defined: u32 = 1;
pub const __int20: u32 = 2;
pub const __INT8: &'static [u8; 3usize] = b"hh\0";
pub const __INT16: &'static [u8; 2usize] = b"h\0";
pub const __INT64: &'static [u8; 3usize] = b"ll\0";
pub const __FAST8: &'static [u8; 3usize] = b"hh\0";
pub const __FAST16: &'static [u8; 2usize] = b"h\0";
pub const __FAST64: &'static [u8; 3usize] = b"ll\0";
pub const __LEAST8: &'static [u8; 3usize] = b"hh\0";
pub const __LEAST16: &'static [u8; 2usize] = b"h\0";
pub const __LEAST64: &'static [u8; 3usize] = b"ll\0";
pub const __int8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const __int_least8_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const WINT_MIN: u32 = 0;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const CUR_PROCESS_HANDLE: u32 = 4294934529;
pub const ARBITRATION_SIGNAL_ALL: i32 = -1;
pub const CUR_THREAD_HANDLE: u32 = 4294934528;
pub const SYSCLOCK_SOC: u32 = 16756991;
pub const SYSCLOCK_ARM9: u32 = 134055928;
pub const SYSCLOCK_ARM11: u32 = 268111856;
pub const SYSCLOCK_ARM11_NEW: u32 = 804335568;
pub const CPU_TICKS_PER_MSEC: f64 = 268111.856;
pub const CPU_TICKS_PER_USEC: f64 = 268.111856;
pub const __NEWLIB_H__: u32 = 1;
pub const _WANT_IO_C99_FORMATS: u32 = 1;
pub const _WANT_IO_LONG_LONG: u32 = 1;
pub const _WANT_IO_POS_ARGS: u32 = 1;
pub const _MB_CAPABLE: u32 = 1;
pub const _MB_LEN_MAX: u32 = 8;
pub const HAVE_INITFINI_ARRAY: u32 = 1;
pub const _ATEXIT_DYNAMIC_ALLOC: u32 = 1;
pub const _HAVE_LONG_DOUBLE: u32 = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: u32 = 1;
pub const _LDBL_EQ_DBL: u32 = 1;
pub const _FVWRITE_IN_STREAMIO: u32 = 1;
pub const _FSEEK_OPTIMIZATION: u32 = 1;
pub const _UNBUF_STREAM_OPT: u32 = 1;
pub const __OBSOLETE_MATH_DEFAULT: u32 = 0;
pub const __OBSOLETE_MATH: u32 = 0;
pub const __RAND_MAX: u32 = 2147483647;
pub const CONSOLE_COLOR_BOLD: u32 = 1;
pub const CONSOLE_COLOR_FAINT: u32 = 2;
pub const CONSOLE_ITALIC: u32 = 4;
pub const CONSOLE_UNDERLINE: u32 = 8;
pub const CONSOLE_BLINK_SLOW: u32 = 16;
pub const CONSOLE_BLINK_FAST: u32 = 32;
pub const CONSOLE_COLOR_REVERSE: u32 = 64;
pub const CONSOLE_CONCEAL: u32 = 128;
pub const CONSOLE_CROSSED_OUT: u32 = 256;
pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___OFFSETOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _LITTLE_ENDIAN: u32 = 1234;
pub const _BIG_ENDIAN: u32 = 4321;
pub const _PDP_ENDIAN: u32 = 3412;
pub const _BYTE_ORDER: u32 = 1234;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const FD_SETSIZE: u32 = 64;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const PTHREAD_SCOPE_PROCESS: u32 = 0;
pub const PTHREAD_SCOPE_SYSTEM: u32 = 1;
pub const PTHREAD_INHERIT_SCHED: u32 = 1;
pub const PTHREAD_EXPLICIT_SCHED: u32 = 2;
pub const PTHREAD_CREATE_DETACHED: u32 = 0;
pub const PTHREAD_CREATE_JOINABLE: u32 = 1;
pub const CSND_NUM_CHANNELS: u32 = 32;
pub const HTTPC_RESULTCODE_DOWNLOADPENDING: u32 = 3628113963;
pub const HTTPC_RESULTCODE_NOTFOUND: u32 = 3628113960;
pub const HTTPC_RESULTCODE_TIMEDOUT: u32 = 3626016873;
pub const UDS_MAXNODES: u32 = 16;
pub const UDS_BROADCAST_NETWORKNODEID: u32 = 65535;
pub const UDS_HOST_NETWORKNODEID: u32 = 1;
pub const UDS_DEFAULT_RECVBUFSIZE: u32 = 11824;
pub const UDS_DATAFRAME_MAXSIZE: u32 = 1478;
pub const DST_NONE: u32 = 0;
pub const DST_USA: u32 = 1;
pub const DST_AUST: u32 = 2;
pub const DST_WET: u32 = 3;
pub const DST_MET: u32 = 4;
pub const DST_EET: u32 = 5;
pub const DST_CAN: u32 = 6;
pub const SBT_MAX: u64 = 9223372036854775807;
pub const ITIMER_REAL: u32 = 0;
pub const ITIMER_VIRTUAL: u32 = 1;
pub const ITIMER_PROF: u32 = 2;
pub const _NULL: u32 = 0;
pub const _ATEXIT_SIZE: u32 = 32;
pub const _RAND48_SEED_0: u32 = 13070;
pub const _RAND48_SEED_1: u32 = 43981;
pub const _RAND48_SEED_2: u32 = 4660;
pub const _RAND48_MULT_0: u32 = 58989;
pub const _RAND48_MULT_1: u32 = 57068;
pub const _RAND48_MULT_2: u32 = 5;
pub const _RAND48_ADD: u32 = 11;
pub const _REENT_EMERGENCY_SIZE: u32 = 25;
pub const _REENT_ASCTIME_SIZE: u32 = 26;
pub const _REENT_SIGNAL_SIZE: u32 = 24;
pub const _N_LISTS: u32 = 30;
pub const _CLOCKS_PER_SEC_: u32 = 100;
pub const CLOCKS_PER_SEC: u32 = 100;
pub const CLK_TCK: u32 = 100;
pub const CLOCK_ENABLED: u32 = 1;
pub const CLOCK_DISABLED: u32 = 0;
pub const CLOCK_ALLOWED: u32 = 1;
pub const CLOCK_DISALLOWED: u32 = 0;
pub const TIMER_ABSTIME: u32 = 4;
pub const SOL_SOCKET: u32 = 65535;
pub const PF_UNSPEC: u32 = 0;
pub const PF_INET: u32 = 2;
pub const PF_INET6: u32 = 23;
pub const AF_UNSPEC: u32 = 0;
pub const AF_INET: u32 = 2;
pub const AF_INET6: u32 = 23;
pub const SOCK_STREAM: u32 = 1;
pub const SOCK_DGRAM: u32 = 2;
pub const MSG_OOB: u32 = 1;
pub const MSG_PEEK: u32 = 2;
pub const MSG_DONTWAIT: u32 = 4;
pub const MSG_DONTROUTE: u32 = 0;
pub const MSG_WAITALL: u32 = 0;
pub const MSG_MORE: u32 = 0;
pub const MSG_NOSIGNAL: u32 = 0;
pub const SHUT_RD: u32 = 0;
pub const SHUT_WR: u32 = 1;
pub const SHUT_RDWR: u32 = 2;
pub const SO_REUSEADDR: u32 = 4;
pub const SO_LINGER: u32 = 128;
pub const SO_OOBINLINE: u32 = 256;
pub const SO_SNDBUF: u32 = 4097;
pub const SO_RCVBUF: u32 = 4098;
pub const SO_SNDLOWAT: u32 = 4099;
pub const SO_RCVLOWAT: u32 = 4100;
pub const SO_TYPE: u32 = 4104;
pub const SO_ERROR: u32 = 4105;
pub const INADDR_LOOPBACK: u32 = 2130706433;
pub const INADDR_ANY: u32 = 0;
pub const INADDR_BROADCAST: u32 = 4294967295;
pub const INADDR_NONE: u32 = 4294967295;
pub const INET_ADDRSTRLEN: u32 = 16;
pub const IPPROTO_IP: u32 = 0;
pub const IPPROTO_UDP: u32 = 17;
pub const IPPROTO_TCP: u32 = 6;
pub const IP_TOS: u32 = 7;
pub const IP_TTL: u32 = 8;
pub const IP_MULTICAST_LOOP: u32 = 9;
pub const IP_MULTICAST_TTL: u32 = 10;
pub const IP_ADD_MEMBERSHIP: u32 = 11;
pub const IP_DROP_MEMBERSHIP: u32 = 12;
pub const SOL_CONFIG: u32 = 65534;
pub const ROUTING_FLAG_G: u32 = 1;
pub const TCP_STATE_CLOSED: u32 = 1;
pub const TCP_STATE_LISTEN: u32 = 2;
pub const TCP_STATE_ESTABLISHED: u32 = 5;
pub const TCP_STATE_FINWAIT1: u32 = 6;
pub const TCP_STATE_FINWAIT2: u32 = 7;
pub const TCP_STATE_CLOSE_WAIT: u32 = 8;
pub const TCP_STATE_LAST_ACK: u32 = 9;
pub const TCP_STATE_TIME_WAIT: u32 = 11;
pub const MVD_STATUS_OK: u32 = 94208;
pub const MVD_STATUS_PARAMSET: u32 = 94209;
pub const MVD_STATUS_BUSY: u32 = 94210;
pub const MVD_STATUS_FRAMEREADY: u32 = 94211;
pub const MVD_STATUS_INCOMPLETEPROCESSING: u32 = 94212;
pub const MVD_STATUS_NALUPROCFLAG: u32 = 94215;
pub const MVD_DEFAULT_WORKBUF_SIZE: u32 = 9438920;
pub const NFC_ERR_INVALID_STATE: u32 = 3366024704;
pub const NFC_ERR_APPDATA_UNINITIALIZED: u32 = 3366024736;
pub const NFC_ERR_AMIIBO_NOTSETUP: u32 = 3366024744;
pub const NFC_ERR_APPID_MISMATCH: u32 = 3366024760;
pub const NFC_ERR_DATACORRUPTION0: u32 = 3368121868;
pub const NFC_ERR_DATACORRUPTION1: u32 = 3366024728;
pub const NFC_STARTSCAN_DEFAULTINPUT: u32 = 0;
pub const GPUREG_0000: u32 = 0;
pub const GPUREG_0001: u32 = 1;
pub const GPUREG_0002: u32 = 2;
pub const GPUREG_0003: u32 = 3;
pub const GPUREG_0004: u32 = 4;
pub const GPUREG_0005: u32 = 5;
pub const GPUREG_0006: u32 = 6;
pub const GPUREG_0007: u32 = 7;
pub const GPUREG_0008: u32 = 8;
pub const GPUREG_0009: u32 = 9;
pub const GPUREG_000A: u32 = 10;
pub const GPUREG_000B: u32 = 11;
pub const GPUREG_000C: u32 = 12;
pub const GPUREG_000D: u32 = 13;
pub const GPUREG_000E: u32 = 14;
pub const GPUREG_000F: u32 = 15;
pub const GPUREG_FINALIZE: u32 = 16;
pub const GPUREG_0011: u32 = 17;
pub const GPUREG_0012: u32 = 18;
pub const GPUREG_0013: u32 = 19;
pub const GPUREG_0014: u32 = 20;
pub const GPUREG_0015: u32 = 21;
pub const GPUREG_0016: u32 = 22;
pub const GPUREG_0017: u32 = 23;
pub const GPUREG_0018: u32 = 24;
pub const GPUREG_0019: u32 = 25;
pub const GPUREG_001A: u32 = 26;
pub const GPUREG_001B: u32 = 27;
pub const GPUREG_001C: u32 = 28;
pub const GPUREG_001D: u32 = 29;
pub const GPUREG_001E: u32 = 30;
pub const GPUREG_001F: u32 = 31;
pub const GPUREG_0020: u32 = 32;
pub const GPUREG_0021: u32 = 33;
pub const GPUREG_0022: u32 = 34;
pub const GPUREG_0023: u32 = 35;
pub const GPUREG_0024: u32 = 36;
pub const GPUREG_0025: u32 = 37;
pub const GPUREG_0026: u32 = 38;
pub const GPUREG_0027: u32 = 39;
pub const GPUREG_0028: u32 = 40;
pub const GPUREG_0029: u32 = 41;
pub const GPUREG_002A: u32 = 42;
pub const GPUREG_002B: u32 = 43;
pub const GPUREG_002C: u32 = 44;
pub const GPUREG_002D: u32 = 45;
pub const GPUREG_002E: u32 = 46;
pub const GPUREG_002F: u32 = 47;
pub const GPUREG_0030: u32 = 48;
pub const GPUREG_0031: u32 = 49;
pub const GPUREG_0032: u32 = 50;
pub const GPUREG_0033: u32 = 51;
pub const GPUREG_0034: u32 = 52;
pub const GPUREG_0035: u32 = 53;
pub const GPUREG_0036: u32 = 54;
pub const GPUREG_0037: u32 = 55;
pub const GPUREG_0038: u32 = 56;
pub const GPUREG_0039: u32 = 57;
pub const GPUREG_003A: u32 = 58;
pub const GPUREG_003B: u32 = 59;
pub const GPUREG_003C: u32 = 60;
pub const GPUREG_003D: u32 = 61;
pub const GPUREG_003E: u32 = 62;
pub const GPUREG_003F: u32 = 63;
pub const GPUREG_FACECULLING_CONFIG: u32 = 64;
pub const GPUREG_VIEWPORT_WIDTH: u32 = 65;
pub const GPUREG_VIEWPORT_INVW: u32 = 66;
pub const GPUREG_VIEWPORT_HEIGHT: u32 = 67;
pub const GPUREG_VIEWPORT_INVH: u32 = 68;
pub const GPUREG_0045: u32 = 69;
pub const GPUREG_0046: u32 = 70;
pub const GPUREG_FRAGOP_CLIP: u32 = 71;
pub const GPUREG_FRAGOP_CLIP_DATA0: u32 = 72;
pub const GPUREG_FRAGOP_CLIP_DATA1: u32 = 73;
pub const GPUREG_FRAGOP_CLIP_DATA2: u32 = 74;
pub const GPUREG_FRAGOP_CLIP_DATA3: u32 = 75;
pub const GPUREG_004C: u32 = 76;
pub const GPUREG_DEPTHMAP_SCALE: u32 = 77;
pub const GPUREG_DEPTHMAP_OFFSET: u32 = 78;
pub const GPUREG_SH_OUTMAP_TOTAL: u32 = 79;
pub const GPUREG_SH_OUTMAP_O0: u32 = 80;
pub const GPUREG_SH_OUTMAP_O1: u32 = 81;
pub const GPUREG_SH_OUTMAP_O2: u32 = 82;
pub const GPUREG_SH_OUTMAP_O3: u32 = 83;
pub const GPUREG_SH_OUTMAP_O4: u32 = 84;
pub const GPUREG_SH_OUTMAP_O5: u32 = 85;
pub const GPUREG_SH_OUTMAP_O6: u32 = 86;
pub const GPUREG_0057: u32 = 87;
pub const GPUREG_0058: u32 = 88;
pub const GPUREG_0059: u32 = 89;
pub const GPUREG_005A: u32 = 90;
pub const GPUREG_005B: u32 = 91;
pub const GPUREG_005C: u32 = 92;
pub const GPUREG_005D: u32 = 93;
pub const GPUREG_005E: u32 = 94;
pub const GPUREG_005F: u32 = 95;
pub const GPUREG_0060: u32 = 96;
pub const GPUREG_EARLYDEPTH_FUNC: u32 = 97;
pub const GPUREG_EARLYDEPTH_TEST1: u32 = 98;
pub const GPUREG_EARLYDEPTH_CLEAR: u32 = 99;
pub const GPUREG_SH_OUTATTR_MODE: u32 = 100;
pub const GPUREG_SCISSORTEST_MODE: u32 = 101;
pub const GPUREG_SCISSORTEST_POS: u32 = 102;
pub const GPUREG_SCISSORTEST_DIM: u32 = 103;
pub const GPUREG_VIEWPORT_XY: u32 = 104;
pub const GPUREG_0069: u32 = 105;
pub const GPUREG_EARLYDEPTH_DATA: u32 = 106;
pub const GPUREG_006B: u32 = 107;
pub const GPUREG_006C: u32 = 108;
pub const GPUREG_DEPTHMAP_ENABLE: u32 = 109;
pub const GPUREG_RENDERBUF_DIM: u32 = 110;
pub const GPUREG_SH_OUTATTR_CLOCK: u32 = 111;
pub const GPUREG_0070: u32 = 112;
pub const GPUREG_0071: u32 = 113;
pub const GPUREG_0072: u32 = 114;
pub const GPUREG_0073: u32 = 115;
pub const GPUREG_0074: u32 = 116;
pub const GPUREG_0075: u32 = 117;
pub const GPUREG_0076: u32 = 118;
pub const GPUREG_0077: u32 = 119;
pub const GPUREG_0078: u32 = 120;
pub const GPUREG_0079: u32 = 121;
pub const GPUREG_007A: u32 = 122;
pub const GPUREG_007B: u32 = 123;
pub const GPUREG_007C: u32 = 124;
pub const GPUREG_007D: u32 = 125;
pub const GPUREG_007E: u32 = 126;
pub const GPUREG_007F: u32 = 127;
pub const GPUREG_TEXUNIT_CONFIG: u32 = 128;
pub const GPUREG_TEXUNIT0_BORDER_COLOR: u32 = 129;
pub const GPUREG_TEXUNIT0_DIM: u32 = 130;
pub const GPUREG_TEXUNIT0_PARAM: u32 = 131;
pub const GPUREG_TEXUNIT0_LOD: u32 = 132;
pub const GPUREG_TEXUNIT0_ADDR1: u32 = 133;
pub const GPUREG_TEXUNIT0_ADDR2: u32 = 134;
pub const GPUREG_TEXUNIT0_ADDR3: u32 = 135;
pub const GPUREG_TEXUNIT0_ADDR4: u32 = 136;
pub const GPUREG_TEXUNIT0_ADDR5: u32 = 137;
pub const GPUREG_TEXUNIT0_ADDR6: u32 = 138;
pub const GPUREG_TEXUNIT0_SHADOW: u32 = 139;
pub const GPUREG_008C: u32 = 140;
pub const GPUREG_008D: u32 = 141;
pub const GPUREG_TEXUNIT0_TYPE: u32 = 142;
pub const GPUREG_LIGHTING_ENABLE0: u32 = 143;
pub const GPUREG_0090: u32 = 144;
pub const GPUREG_TEXUNIT1_BORDER_COLOR: u32 = 145;
pub const GPUREG_TEXUNIT1_DIM: u32 = 146;
pub const GPUREG_TEXUNIT1_PARAM: u32 = 147;
pub const GPUREG_TEXUNIT1_LOD: u32 = 148;
pub const GPUREG_TEXUNIT1_ADDR: u32 = 149;
pub const GPUREG_TEXUNIT1_TYPE: u32 = 150;
pub const GPUREG_0097: u32 = 151;
pub const GPUREG_0098: u32 = 152;
pub const GPUREG_TEXUNIT2_BORDER_COLOR: u32 = 153;
pub const GPUREG_TEXUNIT2_DIM: u32 = 154;
pub const GPUREG_TEXUNIT2_PARAM: u32 = 155;
pub const GPUREG_TEXUNIT2_LOD: u32 = 156;
pub const GPUREG_TEXUNIT2_ADDR: u32 = 157;
pub const GPUREG_TEXUNIT2_TYPE: u32 = 158;
pub const GPUREG_009F: u32 = 159;
pub const GPUREG_00A0: u32 = 160;
pub const GPUREG_00A1: u32 = 161;
pub const GPUREG_00A2: u32 = 162;
pub const GPUREG_00A3: u32 = 163;
pub const GPUREG_00A4: u32 = 164;
pub const GPUREG_00A5: u32 = 165;
pub const GPUREG_00A6: u32 = 166;
pub const GPUREG_00A7: u32 = 167;
pub const GPUREG_TEXUNIT3_PROCTEX0: u32 = 168;
pub const GPUREG_TEXUNIT3_PROCTEX1: u32 = 169;
pub const GPUREG_TEXUNIT3_PROCTEX2: u32 = 170;
pub const GPUREG_TEXUNIT3_PROCTEX3: u32 = 171;
pub const GPUREG_TEXUNIT3_PROCTEX4: u32 = 10;
pub const GPUREG_TEXUNIT3_PROCTEX5: u32 = 13;
pub const GPUREG_00AE: u32 = 174;
pub const GPUREG_PROCTEX_LUT: u32 = 175;
pub const GPUREG_PROCTEX_LUT_DATA0: u32 = 176;
pub const GPUREG_PROCTEX_LUT_DATA1: u32 = 177;
pub const GPUREG_PROCTEX_LUT_DATA2: u32 = 178;
pub const GPUREG_PROCTEX_LUT_DATA3: u32 = 179;
pub const GPUREG_PROCTEX_LUT_DATA4: u32 = 180;
pub const GPUREG_PROCTEX_LUT_DATA5: u32 = 181;
pub const GPUREG_PROCTEX_LUT_DATA6: u32 = 182;
pub const GPUREG_PROCTEX_LUT_DATA7: u32 = 183;
pub const GPUREG_00B8: u32 = 184;
pub const GPUREG_00B9: u32 = 185;
pub const GPUREG_00BA: u32 = 186;
pub const GPUREG_00BB: u32 = 187;
pub const GPUREG_00BC: u32 = 188;
pub const GPUREG_00BD: u32 = 189;
pub const GPUREG_00BE: u32 = 190;
pub const GPUREG_00BF: u32 = 191;
pub const GPUREG_TEXENV0_SOURCE: u32 = 192;
pub const GPUREG_TEXENV0_OPERAND: u32 = 193;
pub const GPUREG_TEXENV0_COMBINER: u32 = 194;
pub const GPUREG_TEXENV0_COLOR: u32 = 195;
pub const GPUREG_TEXENV0_SCALE: u32 = 196;
pub const GPUREG_00C5: u32 = 197;
pub const GPUREG_00C6: u32 = 198;
pub const GPUREG_00C7: u32 = 199;
pub const GPUREG_TEXENV1_SOURCE: u32 = 200;
pub const GPUREG_TEXENV1_OPERAND: u32 = 201;
pub const GPUREG_TEXENV1_COMBINER: u32 = 202;
pub const GPUREG_TEXENV1_COLOR: u32 = 203;
pub const GPUREG_TEXENV1_SCALE: u32 = 204;
pub const GPUREG_00CD: u32 = 205;
pub const GPUREG_00CE: u32 = 206;
pub const GPUREG_00CF: u32 = 207;
pub const GPUREG_TEXENV2_SOURCE: u32 = 208;
pub const GPUREG_TEXENV2_OPERAND: u32 = 209;
pub const GPUREG_TEXENV2_COMBINER: u32 = 210;
pub const GPUREG_TEXENV2_COLOR: u32 = 211;
pub const GPUREG_TEXENV2_SCALE: u32 = 212;
pub const GPUREG_00D5: u32 = 213;
pub const GPUREG_00D6: u32 = 214;
pub const GPUREG_00D7: u32 = 215;
pub const GPUREG_TEXENV3_SOURCE: u32 = 216;
pub const GPUREG_TEXENV3_OPERAND: u32 = 217;
pub const GPUREG_TEXENV3_COMBINER: u32 = 218;
pub const GPUREG_TEXENV3_COLOR: u32 = 219;
pub const GPUREG_TEXENV3_SCALE: u32 = 220;
pub const GPUREG_00DD: u32 = 221;
pub const GPUREG_00DE: u32 = 222;
pub const GPUREG_00DF: u32 = 223;
pub const GPUREG_TEXENV_UPDATE_BUFFER: u32 = 224;
pub const GPUREG_FOG_COLOR: u32 = 225;
pub const GPUREG_00E2: u32 = 226;
pub const GPUREG_00E3: u32 = 227;
pub const GPUREG_GAS_ATTENUATION: u32 = 228;
pub const GPUREG_GAS_ACCMAX: u32 = 229;
pub const GPUREG_FOG_LUT_INDEX: u32 = 230;
pub const GPUREG_00E7: u32 = 231;
pub const GPUREG_FOG_LUT_DATA0: u32 = 232;
pub const GPUREG_FOG_LUT_DATA1: u32 = 233;
pub const GPUREG_FOG_LUT_DATA2: u32 = 234;
pub const GPUREG_FOG_LUT_DATA3: u32 = 235;
pub const GPUREG_FOG_LUT_DATA4: u32 = 236;
pub const GPUREG_FOG_LUT_DATA5: u32 = 237;
pub const GPUREG_FOG_LUT_DATA6: u32 = 238;
pub const GPUREG_FOG_LUT_DATA7: u32 = 239;
pub const GPUREG_TEXENV4_SOURCE: u32 = 240;
pub const GPUREG_TEXENV4_OPERAND: u32 = 241;
pub const GPUREG_TEXENV4_COMBINER: u32 = 242;
pub const GPUREG_TEXENV4_COLOR: u32 = 243;
pub const GPUREG_TEXENV4_SCALE: u32 = 244;
pub const GPUREG_00F5: u32 = 245;
pub const GPUREG_00F6: u32 = 246;
pub const GPUREG_00F7: u32 = 247;
pub const GPUREG_TEXENV5_SOURCE: u32 = 248;
pub const GPUREG_TEXENV5_OPERAND: u32 = 249;
pub const GPUREG_TEXENV5_COMBINER: u32 = 250;
pub const GPUREG_TEXENV5_COLOR: u32 = 251;
pub const GPUREG_TEXENV5_SCALE: u32 = 252;
pub const GPUREG_TEXENV_BUFFER_COLOR: u32 = 253;
pub const GPUREG_00FE: u32 = 254;
pub const GPUREG_00FF: u32 = 255;
pub const GPUREG_COLOR_OPERATION: u32 = 256;
pub const GPUREG_BLEND_FUNC: u32 = 257;
pub const GPUREG_LOGIC_OP: u32 = 258;
pub const GPUREG_BLEND_COLOR: u32 = 259;
pub const GPUREG_FRAGOP_ALPHA_TEST: u32 = 260;
pub const GPUREG_STENCIL_TEST: u32 = 261;
pub const GPUREG_STENCIL_OP: u32 = 262;
pub const GPUREG_DEPTH_COLOR_MASK: u32 = 263;
pub const GPUREG_0108: u32 = 264;
pub const GPUREG_0109: u32 = 265;
pub const GPUREG_010A: u32 = 266;
pub const GPUREG_010B: u32 = 267;
pub const GPUREG_010C: u32 = 268;
pub const GPUREG_010D: u32 = 269;
pub const GPUREG_010E: u32 = 270;
pub const GPUREG_010F: u32 = 271;
pub const GPUREG_FRAMEBUFFER_INVALIDATE: u32 = 272;
pub const GPUREG_FRAMEBUFFER_FLUSH: u32 = 273;
pub const GPUREG_COLORBUFFER_READ: u32 = 274;
pub const GPUREG_COLORBUFFER_WRITE: u32 = 275;
pub const GPUREG_DEPTHBUFFER_READ: u32 = 276;
pub const GPUREG_DEPTHBUFFER_WRITE: u32 = 277;
pub const GPUREG_DEPTHBUFFER_FORMAT: u32 = 278;
pub const GPUREG_COLORBUFFER_FORMAT: u32 = 279;
pub const GPUREG_EARLYDEPTH_TEST2: u32 = 280;
pub const GPUREG_0119: u32 = 281;
pub const GPUREG_011A: u32 = 282;
pub const GPUREG_FRAMEBUFFER_BLOCK32: u32 = 283;
pub const GPUREG_DEPTHBUFFER_LOC: u32 = 284;
pub const GPUREG_COLORBUFFER_LOC: u32 = 285;
pub const GPUREG_FRAMEBUFFER_DIM: u32 = 286;
pub const GPUREG_011F: u32 = 287;
pub const GPUREG_GAS_LIGHT_XY: u32 = 288;
pub const GPUREG_GAS_LIGHT_Z: u32 = 289;
pub const GPUREG_GAS_LIGHT_Z_COLOR: u32 = 290;
pub const GPUREG_GAS_LUT_INDEX: u32 = 291;
pub const GPUREG_GAS_LUT_DATA: u32 = 292;
pub const GPUREG_0125: u32 = 293;
pub const GPUREG_GAS_DELTAZ_DEPTH: u32 = 294;
pub const GPUREG_0127: u32 = 295;
pub const GPUREG_0128: u32 = 296;
pub const GPUREG_0129: u32 = 297;
pub const GPUREG_012A: u32 = 298;
pub const GPUREG_012B: u32 = 299;
pub const GPUREG_012C: u32 = 300;
pub const GPUREG_012D: u32 = 301;
pub const GPUREG_012E: u32 = 302;
pub const GPUREG_012F: u32 = 303;
pub const GPUREG_FRAGOP_SHADOW: u32 = 304;
pub const GPUREG_0131: u32 = 305;
pub const GPUREG_0132: u32 = 306;
pub const GPUREG_0133: u32 = 307;
pub const GPUREG_0134: u32 = 308;
pub const GPUREG_0135: u32 = 309;
pub const GPUREG_0136: u32 = 310;
pub const GPUREG_0137: u32 = 311;
pub const GPUREG_0138: u32 = 312;
pub const GPUREG_0139: u32 = 313;
pub const GPUREG_013A: u32 = 314;
pub const GPUREG_013B: u32 = 315;
pub const GPUREG_013C: u32 = 316;
pub const GPUREG_013D: u32 = 317;
pub const GPUREG_013E: u32 = 318;
pub const GPUREG_013F: u32 = 319;
pub const GPUREG_LIGHT0_SPECULAR0: u32 = 320;
pub const GPUREG_LIGHT0_SPECULAR1: u32 = 321;
pub const GPUREG_LIGHT0_DIFFUSE: u32 = 322;
pub const GPUREG_LIGHT0_AMBIENT: u32 = 323;
pub const GPUREG_LIGHT0_XY: u32 = 324;
pub const GPUREG_LIGHT0_Z: u32 = 325;
pub const GPUREG_LIGHT0_SPOTDIR_XY: u32 = 326;
pub const GPUREG_LIGHT0_SPOTDIR_Z: u32 = 327;
pub const GPUREG_0148: u32 = 328;
pub const GPUREG_LIGHT0_CONFIG: u32 = 329;
pub const GPUREG_LIGHT0_ATTENUATION_BIAS: u32 = 330;
pub const GPUREG_LIGHT0_ATTENUATION_SCALE: u32 = 331;
pub const GPUREG_014C: u32 = 332;
pub const GPUREG_014D: u32 = 333;
pub const GPUREG_014E: u32 = 334;
pub const GPUREG_014F: u32 = 335;
pub const GPUREG_LIGHT1_SPECULAR0: u32 = 336;
pub const GPUREG_LIGHT1_SPECULAR1: u32 = 337;
pub const GPUREG_LIGHT1_DIFFUSE: u32 = 338;
pub const GPUREG_LIGHT1_AMBIENT: u32 = 339;
pub const GPUREG_LIGHT1_XY: u32 = 340;
pub const GPUREG_LIGHT1_Z: u32 = 341;
pub const GPUREG_LIGHT1_SPOTDIR_XY: u32 = 342;
pub const GPUREG_LIGHT1_SPOTDIR_Z: u32 = 343;
pub const GPUREG_0158: u32 = 344;
pub const GPUREG_LIGHT1_CONFIG: u32 = 345;
pub const GPUREG_LIGHT1_ATTENUATION_BIAS: u32 = 346;
pub const GPUREG_LIGHT1_ATTENUATION_SCALE: u32 = 347;
pub const GPUREG_015C: u32 = 348;
pub const GPUREG_015D: u32 = 349;
pub const GPUREG_015E: u32 = 350;
pub const GPUREG_015F: u32 = 351;
pub const GPUREG_LIGHT2_SPECULAR0: u32 = 352;
pub const GPUREG_LIGHT2_SPECULAR1: u32 = 353;
pub const GPUREG_LIGHT2_DIFFUSE: u32 = 354;
pub const GPUREG_LIGHT2_AMBIENT: u32 = 355;
pub const GPUREG_LIGHT2_XY: u32 = 356;
pub const GPUREG_LIGHT2_Z: u32 = 357;
pub const GPUREG_LIGHT2_SPOTDIR_XY: u32 = 358;
pub const GPUREG_LIGHT2_SPOTDIR_Z: u32 = 359;
pub const GPUREG_0168: u32 = 360;
pub const GPUREG_LIGHT2_CONFIG: u32 = 361;
pub const GPUREG_LIGHT2_ATTENUATION_BIAS: u32 = 362;
pub const GPUREG_LIGHT2_ATTENUATION_SCALE: u32 = 363;
pub const GPUREG_016C: u32 = 364;
pub const GPUREG_016D: u32 = 365;
pub const GPUREG_016E: u32 = 366;
pub const GPUREG_016F: u32 = 367;
pub const GPUREG_LIGHT3_SPECULAR0: u32 = 368;
pub const GPUREG_LIGHT3_SPECULAR1: u32 = 369;
pub const GPUREG_LIGHT3_DIFFUSE: u32 = 370;
pub const GPUREG_LIGHT3_AMBIENT: u32 = 371;
pub const GPUREG_LIGHT3_XY: u32 = 372;
pub const GPUREG_LIGHT3_Z: u32 = 373;
pub const GPUREG_LIGHT3_SPOTDIR_XY: u32 = 374;
pub const GPUREG_LIGHT3_SPOTDIR_Z: u32 = 375;
pub const GPUREG_0178: u32 = 376;
pub const GPUREG_LIGHT3_CONFIG: u32 = 377;
pub const GPUREG_LIGHT3_ATTENUATION_BIAS: u32 = 378;
pub const GPUREG_LIGHT3_ATTENUATION_SCALE: u32 = 379;
pub const GPUREG_017C: u32 = 380;
pub const GPUREG_017D: u32 = 381;
pub const GPUREG_017E: u32 = 382;
pub const GPUREG_017F: u32 = 383;
pub const GPUREG_LIGHT4_SPECULAR0: u32 = 384;
pub const GPUREG_LIGHT4_SPECULAR1: u32 = 385;
pub const GPUREG_LIGHT4_DIFFUSE: u32 = 386;
pub const GPUREG_LIGHT4_AMBIENT: u32 = 387;
pub const GPUREG_LIGHT4_XY: u32 = 388;
pub const GPUREG_LIGHT4_Z: u32 = 389;
pub const GPUREG_LIGHT4_SPOTDIR_XY: u32 = 390;
pub const GPUREG_LIGHT4_SPOTDIR_Z: u32 = 391;
pub const GPUREG_0188: u32 = 392;
pub const GPUREG_LIGHT4_CONFIG: u32 = 393;
pub const GPUREG_LIGHT4_ATTENUATION_BIAS: u32 = 394;
pub const GPUREG_LIGHT4_ATTENUATION_SCALE: u32 = 395;
pub const GPUREG_018C: u32 = 396;
pub const GPUREG_018D: u32 = 397;
pub const GPUREG_018E: u32 = 398;
pub const GPUREG_018F: u32 = 399;
pub const GPUREG_LIGHT5_SPECULAR0: u32 = 400;
pub const GPUREG_LIGHT5_SPECULAR1: u32 = 401;
pub const GPUREG_LIGHT5_DIFFUSE: u32 = 402;
pub const GPUREG_LIGHT5_AMBIENT: u32 = 403;
pub const GPUREG_LIGHT5_XY: u32 = 404;
pub const GPUREG_LIGHT5_Z: u32 = 405;
pub const GPUREG_LIGHT5_SPOTDIR_XY: u32 = 406;
pub const GPUREG_LIGHT5_SPOTDIR_Z: u32 = 407;
pub const GPUREG_0198: u32 = 408;
pub const GPUREG_LIGHT5_CONFIG: u32 = 409;
pub const GPUREG_LIGHT5_ATTENUATION_BIAS: u32 = 410;
pub const GPUREG_LIGHT5_ATTENUATION_SCALE: u32 = 411;
pub const GPUREG_019C: u32 = 412;
pub const GPUREG_019D: u32 = 413;
pub const GPUREG_019E: u32 = 414;
pub const GPUREG_019F: u32 = 415;
pub const GPUREG_LIGHT6_SPECULAR0: u32 = 416;
pub const GPUREG_LIGHT6_SPECULAR1: u32 = 417;
pub const GPUREG_LIGHT6_DIFFUSE: u32 = 418;
pub const GPUREG_LIGHT6_AMBIENT: u32 = 419;
pub const GPUREG_LIGHT6_XY: u32 = 420;
pub const GPUREG_LIGHT6_Z: u32 = 421;
pub const GPUREG_LIGHT6_SPOTDIR_XY: u32 = 422;
pub const GPUREG_LIGHT6_SPOTDIR_Z: u32 = 423;
pub const GPUREG_01A8: u32 = 424;
pub const GPUREG_LIGHT6_CONFIG: u32 = 425;
pub const GPUREG_LIGHT6_ATTENUATION_BIAS: u32 = 426;
pub const GPUREG_LIGHT6_ATTENUATION_SCALE: u32 = 427;
pub const GPUREG_01AC: u32 = 428;
pub const GPUREG_01AD: u32 = 429;
pub const GPUREG_01AE: u32 = 430;
pub const GPUREG_01AF: u32 = 431;
pub const GPUREG_LIGHT7_SPECULAR0: u32 = 432;
pub const GPUREG_LIGHT7_SPECULAR1: u32 = 433;
pub const GPUREG_LIGHT7_DIFFUSE: u32 = 434;
pub const GPUREG_LIGHT7_AMBIENT: u32 = 435;
pub const GPUREG_LIGHT7_XY: u32 = 436;
pub const GPUREG_LIGHT7_Z: u32 = 437;
pub const GPUREG_LIGHT7_SPOTDIR_XY: u32 = 438;
pub const GPUREG_LIGHT7_SPOTDIR_Z: u32 = 439;
pub const GPUREG_01B8: u32 = 440;
pub const GPUREG_LIGHT7_CONFIG: u32 = 441;
pub const GPUREG_LIGHT7_ATTENUATION_BIAS: u32 = 442;
pub const GPUREG_LIGHT7_ATTENUATION_SCALE: u32 = 443;
pub const GPUREG_01BC: u32 = 444;
pub const GPUREG_01BD: u32 = 445;
pub const GPUREG_01BE: u32 = 446;
pub const GPUREG_01BF: u32 = 447;
pub const GPUREG_LIGHTING_AMBIENT: u32 = 448;
pub const GPUREG_01C1: u32 = 449;
pub const GPUREG_LIGHTING_NUM_LIGHTS: u32 = 450;
pub const GPUREG_LIGHTING_CONFIG0: u32 = 451;
pub const GPUREG_LIGHTING_CONFIG1: u32 = 452;
pub const GPUREG_LIGHTING_LUT_INDEX: u32 = 453;
pub const GPUREG_LIGHTING_ENABLE1: u32 = 454;
pub const GPUREG_01C7: u32 = 455;
pub const GPUREG_LIGHTING_LUT_DATA0: u32 = 456;
pub const GPUREG_LIGHTING_LUT_DATA1: u32 = 457;
pub const GPUREG_LIGHTING_LUT_DATA2: u32 = 458;
pub const GPUREG_LIGHTING_LUT_DATA3: u32 = 459;
pub const GPUREG_LIGHTING_LUT_DATA4: u32 = 460;
pub const GPUREG_LIGHTING_LUT_DATA5: u32 = 461;
pub const GPUREG_LIGHTING_LUT_DATA6: u32 = 462;
pub const GPUREG_LIGHTING_LUT_DATA7: u32 = 463;
pub const GPUREG_LIGHTING_LUTINPUT_ABS: u32 = 464;
pub const GPUREG_LIGHTING_LUTINPUT_SELECT: u32 = 465;
pub const GPUREG_LIGHTING_LUTINPUT_SCALE: u32 = 466;
pub const GPUREG_01D3: u32 = 467;
pub const GPUREG_01D4: u32 = 468;
pub const GPUREG_01D5: u32 = 469;
pub const GPUREG_01D6: u32 = 470;
pub const GPUREG_01D7: u32 = 471;
pub const GPUREG_01D8: u32 = 472;
pub const GPUREG_LIGHTING_LIGHT_PERMUTATION: u32 = 473;
pub const GPUREG_01DA: u32 = 474;
pub const GPUREG_01DB: u32 = 475;
pub const GPUREG_01DC: u32 = 476;
pub const GPUREG_01DD: u32 = 477;
pub const GPUREG_01DE: u32 = 478;
pub const GPUREG_01DF: u32 = 479;
pub const GPUREG_01E0: u32 = 480;
pub const GPUREG_01E1: u32 = 481;
pub const GPUREG_01E2: u32 = 482;
pub const GPUREG_01E3: u32 = 483;
pub const GPUREG_01E4: u32 = 484;
pub const GPUREG_01E5: u32 = 485;
pub const GPUREG_01E6: u32 = 486;
pub const GPUREG_01E7: u32 = 487;
pub const GPUREG_01E8: u32 = 488;
pub const GPUREG_01E9: u32 = 489;
pub const GPUREG_01EA: u32 = 490;
pub const GPUREG_01EB: u32 = 491;
pub const GPUREG_01EC: u32 = 492;
pub const GPUREG_01ED: u32 = 493;
pub const GPUREG_01EE: u32 = 494;
pub const GPUREG_01EF: u32 = 495;
pub const GPUREG_01F0: u32 = 496;
pub const GPUREG_01F1: u32 = 497;
pub const GPUREG_01F2: u32 = 498;
pub const GPUREG_01F3: u32 = 499;
pub const GPUREG_01F4: u32 = 500;
pub const GPUREG_01F5: u32 = 501;
pub const GPUREG_01F6: u32 = 502;
pub const GPUREG_01F7: u32 = 503;
pub const GPUREG_01F8: u32 = 504;
pub const GPUREG_01F9: u32 = 505;
pub const GPUREG_01FA: u32 = 506;
pub const GPUREG_01FB: u32 = 507;
pub const GPUREG_01FC: u32 = 508;
pub const GPUREG_01FD: u32 = 509;
pub const GPUREG_01FE: u32 = 510;
pub const GPUREG_01FF: u32 = 511;
pub const GPUREG_ATTRIBBUFFERS_LOC: u32 = 512;
pub const GPUREG_ATTRIBBUFFERS_FORMAT_LOW: u32 = 513;
pub const GPUREG_ATTRIBBUFFERS_FORMAT_HIGH: u32 = 514;
pub const GPUREG_ATTRIBBUFFER0_OFFSET: u32 = 515;
pub const GPUREG_ATTRIBBUFFER0_CONFIG1: u32 = 516;
pub const GPUREG_ATTRIBBUFFER0_CONFIG2: u32 = 517;
pub const GPUREG_ATTRIBBUFFER1_OFFSET: u32 = 518;
pub const GPUREG_ATTRIBBUFFER1_CONFIG1: u32 = 519;
pub const GPUREG_ATTRIBBUFFER1_CONFIG2: u32 = 520;
pub const GPUREG_ATTRIBBUFFER2_OFFSET: u32 = 521;
pub const GPUREG_ATTRIBBUFFER2_CONFIG1: u32 = 522;
pub const GPUREG_ATTRIBBUFFER2_CONFIG2: u32 = 523;
pub const GPUREG_ATTRIBBUFFER3_OFFSET: u32 = 524;
pub const GPUREG_ATTRIBBUFFER3_CONFIG1: u32 = 525;
pub const GPUREG_ATTRIBBUFFER3_CONFIG2: u32 = 526;
pub const GPUREG_ATTRIBBUFFER4_OFFSET: u32 = 527;
pub const GPUREG_ATTRIBBUFFER4_CONFIG1: u32 = 528;
pub const GPUREG_ATTRIBBUFFER4_CONFIG2: u32 = 529;
pub const GPUREG_ATTRIBBUFFER5_OFFSET: u32 = 530;
pub const GPUREG_ATTRIBBUFFER5_CONFIG1: u32 = 531;
pub const GPUREG_ATTRIBBUFFER5_CONFIG2: u32 = 532;
pub const GPUREG_ATTRIBBUFFER6_OFFSET: u32 = 533;
pub const GPUREG_ATTRIBBUFFER6_CONFIG1: u32 = 534;
pub const GPUREG_ATTRIBBUFFER6_CONFIG2: u32 = 535;
pub const GPUREG_ATTRIBBUFFER7_OFFSET: u32 = 536;
pub const GPUREG_ATTRIBBUFFER7_CONFIG1: u32 = 537;
pub const GPUREG_ATTRIBBUFFER7_CONFIG2: u32 = 538;
pub const GPUREG_ATTRIBBUFFER8_OFFSET: u32 = 539;
pub const GPUREG_ATTRIBBUFFER8_CONFIG1: u32 = 540;
pub const GPUREG_ATTRIBBUFFER8_CONFIG2: u32 = 541;
pub const GPUREG_ATTRIBBUFFER9_OFFSET: u32 = 542;
pub const GPUREG_ATTRIBBUFFER9_CONFIG1: u32 = 543;
pub const GPUREG_ATTRIBBUFFER9_CONFIG2: u32 = 544;
pub const GPUREG_ATTRIBBUFFERA_OFFSET: u32 = 545;
pub const GPUREG_ATTRIBBUFFERA_CONFIG1: u32 = 546;
pub const GPUREG_ATTRIBBUFFERA_CONFIG2: u32 = 547;
pub const GPUREG_ATTRIBBUFFERB_OFFSET: u32 = 548;
pub const GPUREG_ATTRIBBUFFERB_CONFIG1: u32 = 549;
pub const GPUREG_ATTRIBBUFFERB_CONFIG2: u32 = 550;
pub const GPUREG_INDEXBUFFER_CONFIG: u32 = 551;
pub const GPUREG_NUMVERTICES: u32 = 552;
pub const GPUREG_GEOSTAGE_CONFIG: u32 = 553;
pub const GPUREG_VERTEX_OFFSET: u32 = 554;
pub const GPUREG_022B: u32 = 555;
pub const GPUREG_022C: u32 = 556;
pub const GPUREG_POST_VERTEX_CACHE_NUM: u32 = 557;
pub const GPUREG_DRAWARRAYS: u32 = 558;
pub const GPUREG_DRAWELEMENTS: u32 = 559;
pub const GPUREG_0230: u32 = 560;
pub const GPUREG_VTX_FUNC: u32 = 561;
pub const GPUREG_FIXEDATTRIB_INDEX: u32 = 562;
pub const GPUREG_FIXEDATTRIB_DATA0: u32 = 563;
pub const GPUREG_FIXEDATTRIB_DATA1: u32 = 564;
pub const GPUREG_FIXEDATTRIB_DATA2: u32 = 565;
pub const GPUREG_0236: u32 = 566;
pub const GPUREG_0237: u32 = 567;
pub const GPUREG_CMDBUF_SIZE0: u32 = 568;
pub const GPUREG_CMDBUF_SIZE1: u32 = 569;
pub const GPUREG_CMDBUF_ADDR0: u32 = 570;
pub const GPUREG_CMDBUF_ADDR1: u32 = 571;
pub const GPUREG_CMDBUF_JUMP0: u32 = 572;
pub const GPUREG_CMDBUF_JUMP1: u32 = 573;
pub const GPUREG_023E: u32 = 574;
pub const GPUREG_023F: u32 = 575;
pub const GPUREG_0240: u32 = 576;
pub const GPUREG_0241: u32 = 577;
pub const GPUREG_VSH_NUM_ATTR: u32 = 578;
pub const GPUREG_0243: u32 = 579;
pub const GPUREG_VSH_COM_MODE: u32 = 580;
pub const GPUREG_START_DRAW_FUNC0: u32 = 581;
pub const GPUREG_0246: u32 = 582;
pub const GPUREG_0247: u32 = 583;
pub const GPUREG_0248: u32 = 584;
pub const GPUREG_0249: u32 = 585;
pub const GPUREG_VSH_OUTMAP_TOTAL1: u32 = 586;
pub const GPUREG_024B: u32 = 587;
pub const GPUREG_024C: u32 = 588;
pub const GPUREG_024D: u32 = 589;
pub const GPUREG_024E: u32 = 590;
pub const GPUREG_024F: u32 = 591;
pub const GPUREG_0250: u32 = 592;
pub const GPUREG_VSH_OUTMAP_TOTAL2: u32 = 593;
pub const GPUREG_GSH_MISC0: u32 = 594;
pub const GPUREG_GEOSTAGE_CONFIG2: u32 = 595;
pub const GPUREG_GSH_MISC1: u32 = 596;
pub const GPUREG_0255: u32 = 597;
pub const GPUREG_0256: u32 = 598;
pub const GPUREG_0257: u32 = 599;
pub const GPUREG_0258: u32 = 600;
pub const GPUREG_0259: u32 = 601;
pub const GPUREG_025A: u32 = 602;
pub const GPUREG_025B: u32 = 603;
pub const GPUREG_025C: u32 = 604;
pub const GPUREG_025D: u32 = 605;
pub const GPUREG_PRIMITIVE_CONFIG: u32 = 606;
pub const GPUREG_RESTART_PRIMITIVE: u32 = 607;
pub const GPUREG_0260: u32 = 608;
pub const GPUREG_0261: u32 = 609;
pub const GPUREG_0262: u32 = 610;
pub const GPUREG_0263: u32 = 611;
pub const GPUREG_0264: u32 = 612;
pub const GPUREG_0265: u32 = 613;
pub const GPUREG_0266: u32 = 614;
pub const GPUREG_0267: u32 = 615;
pub const GPUREG_0268: u32 = 616;
pub const GPUREG_0269: u32 = 617;
pub const GPUREG_026A: u32 = 618;
pub const GPUREG_026B: u32 = 619;
pub const GPUREG_026C: u32 = 620;
pub const GPUREG_026D: u32 = 621;
pub const GPUREG_026E: u32 = 622;
pub const GPUREG_026F: u32 = 623;
pub const GPUREG_0270: u32 = 624;
pub const GPUREG_0271: u32 = 625;
pub const GPUREG_0272: u32 = 626;
pub const GPUREG_0273: u32 = 627;
pub const GPUREG_0274: u32 = 628;
pub const GPUREG_0275: u32 = 629;
pub const GPUREG_0276: u32 = 630;
pub const GPUREG_0277: u32 = 631;
pub const GPUREG_0278: u32 = 632;
pub const GPUREG_0279: u32 = 633;
pub const GPUREG_027A: u32 = 634;
pub const GPUREG_027B: u32 = 635;
pub const GPUREG_027C: u32 = 636;
pub const GPUREG_027D: u32 = 637;
pub const GPUREG_027E: u32 = 638;
pub const GPUREG_027F: u32 = 639;
pub const GPUREG_GSH_BOOLUNIFORM: u32 = 640;
pub const GPUREG_GSH_INTUNIFORM_I0: u32 = 641;
pub const GPUREG_GSH_INTUNIFORM_I1: u32 = 642;
pub const GPUREG_GSH_INTUNIFORM_I2: u32 = 643;
pub const GPUREG_GSH_INTUNIFORM_I3: u32 = 644;
pub const GPUREG_0285: u32 = 645;
pub const GPUREG_0286: u32 = 646;
pub const GPUREG_0287: u32 = 647;
pub const GPUREG_0288: u32 = 648;
pub const GPUREG_GSH_INPUTBUFFER_CONFIG: u32 = 649;
pub const GPUREG_GSH_ENTRYPOINT: u32 = 650;
pub const GPUREG_GSH_ATTRIBUTES_PERMUTATION_LOW: u32 = 651;
pub const GPUREG_GSH_ATTRIBUTES_PERMUTATION_HIGH: u32 = 652;
pub const GPUREG_GSH_OUTMAP_MASK: u32 = 653;
pub const GPUREG_028E: u32 = 654;
pub const GPUREG_GSH_CODETRANSFER_END: u32 = 655;
pub const GPUREG_GSH_FLOATUNIFORM_CONFIG: u32 = 656;
pub const GPUREG_GSH_FLOATUNIFORM_DATA: u32 = 657;
pub const GPUREG_0299: u32 = 665;
pub const GPUREG_029A: u32 = 666;
pub const GPUREG_GSH_CODETRANSFER_CONFIG: u32 = 667;
pub const GPUREG_GSH_CODETRANSFER_DATA: u32 = 668;
pub const GPUREG_02A4: u32 = 676;
pub const GPUREG_GSH_OPDESCS_CONFIG: u32 = 677;
pub const GPUREG_GSH_OPDESCS_DATA: u32 = 678;
pub const GPUREG_02AE: u32 = 686;
pub const GPUREG_02AF: u32 = 687;
pub const GPUREG_VSH_BOOLUNIFORM: u32 = 688;
pub const GPUREG_VSH_INTUNIFORM_I0: u32 = 689;
pub const GPUREG_VSH_INTUNIFORM_I1: u32 = 690;
pub const GPUREG_VSH_INTUNIFORM_I2: u32 = 691;
pub const GPUREG_VSH_INTUNIFORM_I3: u32 = 692;
pub const GPUREG_02B5: u32 = 693;
pub const GPUREG_02B6: u32 = 694;
pub const GPUREG_02B7: u32 = 695;
pub const GPUREG_02B8: u32 = 696;
pub const GPUREG_VSH_INPUTBUFFER_CONFIG: u32 = 697;
pub const GPUREG_VSH_ENTRYPOINT: u32 = 698;
pub const GPUREG_VSH_ATTRIBUTES_PERMUTATION_LOW: u32 = 699;
pub const GPUREG_VSH_ATTRIBUTES_PERMUTATION_HIGH: u32 = 700;
pub const GPUREG_VSH_OUTMAP_MASK: u32 = 701;
pub const GPUREG_02BE: u32 = 702;
pub const GPUREG_VSH_CODETRANSFER_END: u32 = 703;
pub const GPUREG_VSH_FLOATUNIFORM_CONFIG: u32 = 704;
pub const GPUREG_VSH_FLOATUNIFORM_DATA: u32 = 705;
pub const GPUREG_02C9: u32 = 713;
pub const GPUREG_02CA: u32 = 714;
pub const GPUREG_VSH_CODETRANSFER_CONFIG: u32 = 715;
pub const GPUREG_VSH_CODETRANSFER_DATA: u32 = 716;
pub const GPUREG_02D4: u32 = 724;
pub const GPUREG_VSH_OPDESCS_CONFIG: u32 = 725;
pub const GPUREG_VSH_OPDESCS_DATA: u32 = 726;
pub const GPUREG_02DE: u32 = 734;
pub const GPUREG_02DF: u32 = 735;
pub const GPUREG_02E0: u32 = 736;
pub const GPUREG_02E1: u32 = 737;
pub const GPUREG_02E2: u32 = 738;
pub const GPUREG_02E3: u32 = 739;
pub const GPUREG_02E4: u32 = 740;
pub const GPUREG_02E5: u32 = 741;
pub const GPUREG_02E6: u32 = 742;
pub const GPUREG_02E7: u32 = 743;
pub const GPUREG_02E8: u32 = 744;
pub const GPUREG_02E9: u32 = 745;
pub const GPUREG_02EA: u32 = 746;
pub const GPUREG_02EB: u32 = 747;
pub const GPUREG_02EC: u32 = 748;
pub const GPUREG_02ED: u32 = 749;
pub const GPUREG_02EE: u32 = 750;
pub const GPUREG_02EF: u32 = 751;
pub const GPUREG_02F0: u32 = 752;
pub const GPUREG_02F1: u32 = 753;
pub const GPUREG_02F2: u32 = 754;
pub const GPUREG_02F3: u32 = 755;
pub const GPUREG_02F4: u32 = 756;
pub const GPUREG_02F5: u32 = 757;
pub const GPUREG_02F6: u32 = 758;
pub const GPUREG_02F7: u32 = 759;
pub const GPUREG_02F8: u32 = 760;
pub const GPUREG_02F9: u32 = 761;
pub const GPUREG_02FA: u32 = 762;
pub const GPUREG_02FB: u32 = 763;
pub const GPUREG_02FC: u32 = 764;
pub const GPUREG_02FD: u32 = 765;
pub const GPUREG_02FE: u32 = 766;
pub const GPUREG_02FF: u32 = 767;
pub const NDSP_SAMPLE_RATE: f64 = 32728.498046875;
pub const SWKBD_MAX_WORD_LEN: u32 = 40;
pub const SWKBD_MAX_BUTTON_TEXT_LEN: u32 = 16;
pub const SWKBD_MAX_HINT_TEXT_LEN: u32 = 64;
pub const SWKBD_MAX_CALLBACK_MSG_LEN: u32 = 256;
pub const MIISELECTOR_MAGIC: u32 = 333326543;
pub const MIISELECTOR_TITLE_LEN: u32 = 64;
pub const MIISELECTOR_GUESTMII_SLOTS: u32 = 6;
pub const MIISELECTOR_USERMII_SLOTS: u32 = 100;
pub const MIISELECTOR_MIIDATA_SIZE: u32 = 92;
pub const MIISELECTOR_GUESTMII_NAME_LEN: u32 = 12;
pub const SDMC_DIRITER_MAGIC: u32 = 1935961443;
pub type __int8_t = ::libc::c_schar;
pub type __uint8_t = ::libc::c_uchar;
pub type __int16_t = ::libc::c_short;
pub type __uint16_t = ::libc::c_ushort;
pub type __int32_t = ::libc::c_int;
pub type __uint32_t = ::libc::c_uint;
pub type __int64_t = ::libc::c_longlong;
pub type __uint64_t = ::libc::c_ulonglong;
pub type __int_least8_t = ::libc::c_schar;
pub type __uint_least8_t = ::libc::c_uchar;
pub type __int_least16_t = ::libc::c_short;
pub type __uint_least16_t = ::libc::c_ushort;
pub type __int_least32_t = ::libc::c_int;
pub type __uint_least32_t = ::libc::c_uint;
pub type __int_least64_t = ::libc::c_longlong;
pub type __uint_least64_t = ::libc::c_ulonglong;
pub type __intmax_t = ::libc::c_longlong;
pub type __uintmax_t = ::libc::c_ulonglong;
pub type __intptr_t = ::libc::c_long;
pub type __uintptr_t = ::libc::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::libc::c_schar;
pub type uint_fast8_t = ::libc::c_uchar;
pub type int_fast16_t = ::libc::c_short;
pub type uint_fast16_t = ::libc::c_ushort;
pub type int_fast32_t = ::libc::c_int;
pub type uint_fast32_t = ::libc::c_uint;
pub type int_fast64_t = ::libc::c_longlong;
pub type uint_fast64_t = ::libc::c_ulonglong;
pub type wchar_t = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::libc::c_longlong,
    pub __clang_max_align_nonce2: f64,
}
pub type s8 = i8;
pub type s16 = i16;
pub type s32 = i32;
pub type s64 = i64;
pub type vu8 = u8;
pub type vu16 = u16;
pub type vu32 = u32;
pub type vu64 = u64;
pub type vs8 = s8;
pub type vs16 = s16;
pub type vs32 = s32;
pub type vs64 = s64;
pub type Handle = u32;
pub type Result = s32;
pub type ThreadFunc = ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::libc::c_void)>;
pub type voidfn = ::core::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
pub struct CpuRegisters {
    pub r: [u32; 13usize],
    pub sp: u32,
    pub lr: u32,
    pub pc: u32,
    pub cpsr: u32,
}
#[repr(C)]
pub struct FpuRegisters {
    pub __bindgen_anon_1: FpuRegisters__bindgen_ty_1,
    pub fpscr: u32,
    pub fpexc: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FpuRegisters__bindgen_ty_1 {
    pub __bindgen_anon_1: FpuRegisters__bindgen_ty_1__bindgen_ty_1,
    pub s: [f32; 32usize],
    _bindgen_union_align: [u32; 32usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FpuRegisters__bindgen_ty_1__bindgen_ty_1 {
    pub d: [f64; 16usize],
}
pub const RL_SUCCESS: _bindgen_ty_1 = 0;
pub const RL_INFO: _bindgen_ty_1 = 1;
pub const RL_FATAL: _bindgen_ty_1 = 31;
pub const RL_RESET: _bindgen_ty_1 = 30;
pub const RL_REINITIALIZE: _bindgen_ty_1 = 29;
pub const RL_USAGE: _bindgen_ty_1 = 28;
pub const RL_PERMANENT: _bindgen_ty_1 = 27;
pub const RL_TEMPORARY: _bindgen_ty_1 = 26;
pub const RL_STATUS: _bindgen_ty_1 = 25;
pub type _bindgen_ty_1 = u32;
pub const RS_SUCCESS: _bindgen_ty_2 = 0;
pub const RS_NOP: _bindgen_ty_2 = 1;
pub const RS_WOULDBLOCK: _bindgen_ty_2 = 2;
pub const RS_OUTOFRESOURCE: _bindgen_ty_2 = 3;
pub const RS_NOTFOUND: _bindgen_ty_2 = 4;
pub const RS_INVALIDSTATE: _bindgen_ty_2 = 5;
pub const RS_NOTSUPPORTED: _bindgen_ty_2 = 6;
pub const RS_INVALIDARG: _bindgen_ty_2 = 7;
pub const RS_WRONGARG: _bindgen_ty_2 = 8;
pub const RS_CANCELED: _bindgen_ty_2 = 9;
pub const RS_STATUSCHANGED: _bindgen_ty_2 = 10;
pub const RS_INTERNAL: _bindgen_ty_2 = 11;
pub const RS_INVALIDRESVAL: _bindgen_ty_2 = 63;
pub type _bindgen_ty_2 = u32;
pub const RM_COMMON: _bindgen_ty_3 = 0;
pub const RM_KERNEL: _bindgen_ty_3 = 1;
pub const RM_UTIL: _bindgen_ty_3 = 2;
pub const RM_FILE_SERVER: _bindgen_ty_3 = 3;
pub const RM_LOADER_SERVER: _bindgen_ty_3 = 4;
pub const RM_TCB: _bindgen_ty_3 = 5;
pub const RM_OS: _bindgen_ty_3 = 6;
pub const RM_DBG: _bindgen_ty_3 = 7;
pub const RM_DMNT: _bindgen_ty_3 = 8;
pub const RM_PDN: _bindgen_ty_3 = 9;
pub const RM_GSP: _bindgen_ty_3 = 10;
pub const RM_I2C: _bindgen_ty_3 = 11;
pub const RM_GPIO: _bindgen_ty_3 = 12;
pub const RM_DD: _bindgen_ty_3 = 13;
pub const RM_CODEC: _bindgen_ty_3 = 14;
pub const RM_SPI: _bindgen_ty_3 = 15;
pub const RM_PXI: _bindgen_ty_3 = 16;
pub const RM_FS: _bindgen_ty_3 = 17;
pub const RM_DI: _bindgen_ty_3 = 18;
pub const RM_HID: _bindgen_ty_3 = 19;
pub const RM_CAM: _bindgen_ty_3 = 20;
pub const RM_PI: _bindgen_ty_3 = 21;
pub const RM_PM: _bindgen_ty_3 = 22;
pub const RM_PM_LOW: _bindgen_ty_3 = 23;
pub const RM_FSI: _bindgen_ty_3 = 24;
pub const RM_SRV: _bindgen_ty_3 = 25;
pub const RM_NDM: _bindgen_ty_3 = 26;
pub const RM_NWM: _bindgen_ty_3 = 27;
pub const RM_SOC: _bindgen_ty_3 = 28;
pub const RM_LDR: _bindgen_ty_3 = 29;
pub const RM_ACC: _bindgen_ty_3 = 30;
pub const RM_ROMFS: _bindgen_ty_3 = 31;
pub const RM_AM: _bindgen_ty_3 = 32;
pub const RM_HIO: _bindgen_ty_3 = 33;
pub const RM_UPDATER: _bindgen_ty_3 = 34;
pub const RM_MIC: _bindgen_ty_3 = 35;
pub const RM_FND: _bindgen_ty_3 = 36;
pub const RM_MP: _bindgen_ty_3 = 37;
pub const RM_MPWL: _bindgen_ty_3 = 38;
pub const RM_AC: _bindgen_ty_3 = 39;
pub const RM_HTTP: _bindgen_ty_3 = 40;
pub const RM_DSP: _bindgen_ty_3 = 41;
pub const RM_SND: _bindgen_ty_3 = 42;
pub const RM_DLP: _bindgen_ty_3 = 43;
pub const RM_HIO_LOW: _bindgen_ty_3 = 44;
pub const RM_CSND: _bindgen_ty_3 = 45;
pub const RM_SSL: _bindgen_ty_3 = 46;
pub const RM_AM_LOW: _bindgen_ty_3 = 47;
pub const RM_NEX: _bindgen_ty_3 = 48;
pub const RM_FRIENDS: _bindgen_ty_3 = 49;
pub const RM_RDT: _bindgen_ty_3 = 50;
pub const RM_APPLET: _bindgen_ty_3 = 51;
pub const RM_NIM: _bindgen_ty_3 = 52;
pub const RM_PTM: _bindgen_ty_3 = 53;
pub const RM_MIDI: _bindgen_ty_3 = 54;
pub const RM_MC: _bindgen_ty_3 = 55;
pub const RM_SWC: _bindgen_ty_3 = 56;
pub const RM_FATFS: _bindgen_ty_3 = 57;
pub const RM_NGC: _bindgen_ty_3 = 58;
pub const RM_CARD: _bindgen_ty_3 = 59;
pub const RM_CARDNOR: _bindgen_ty_3 = 60;
pub const RM_SDMC: _bindgen_ty_3 = 61;
pub const RM_BOSS: _bindgen_ty_3 = 62;
pub const RM_DBM: _bindgen_ty_3 = 63;
pub const RM_CONFIG: _bindgen_ty_3 = 64;
pub const RM_PS: _bindgen_ty_3 = 65;
pub const RM_CEC: _bindgen_ty_3 = 66;
pub const RM_IR: _bindgen_ty_3 = 67;
pub const RM_UDS: _bindgen_ty_3 = 68;
pub const RM_PL: _bindgen_ty_3 = 69;
pub const RM_CUP: _bindgen_ty_3 = 70;
pub const RM_GYROSCOPE: _bindgen_ty_3 = 71;
pub const RM_MCU: _bindgen_ty_3 = 72;
pub const RM_NS: _bindgen_ty_3 = 73;
pub const RM_NEWS: _bindgen_ty_3 = 74;
pub const RM_RO: _bindgen_ty_3 = 75;
pub const RM_GD: _bindgen_ty_3 = 76;
pub const RM_CARD_SPI: _bindgen_ty_3 = 77;
pub const RM_EC: _bindgen_ty_3 = 78;
pub const RM_WEB_BROWSER: _bindgen_ty_3 = 79;
pub const RM_TEST: _bindgen_ty_3 = 80;
pub const RM_ENC: _bindgen_ty_3 = 81;
pub const RM_PIA: _bindgen_ty_3 = 82;
pub const RM_ACT: _bindgen_ty_3 = 83;
pub const RM_VCTL: _bindgen_ty_3 = 84;
pub const RM_OLV: _bindgen_ty_3 = 85;
pub const RM_NEIA: _bindgen_ty_3 = 86;
pub const RM_NPNS: _bindgen_ty_3 = 87;
pub const RM_AVD: _bindgen_ty_3 = 90;
pub const RM_L2B: _bindgen_ty_3 = 91;
pub const RM_MVD: _bindgen_ty_3 = 92;
pub const RM_NFC: _bindgen_ty_3 = 93;
pub const RM_UART: _bindgen_ty_3 = 94;
pub const RM_SPM: _bindgen_ty_3 = 95;
pub const RM_QTM: _bindgen_ty_3 = 96;
pub const RM_NFP: _bindgen_ty_3 = 97;
pub const RM_APPLICATION: _bindgen_ty_3 = 254;
pub const RM_INVALIDRESVAL: _bindgen_ty_3 = 255;
pub type _bindgen_ty_3 = u32;
pub const RD_SUCCESS: _bindgen_ty_4 = 0;
pub const RD_INVALID_RESULT_VALUE: _bindgen_ty_4 = 1023;
pub const RD_TIMEOUT: _bindgen_ty_4 = 1022;
pub const RD_OUT_OF_RANGE: _bindgen_ty_4 = 1021;
pub const RD_ALREADY_EXISTS: _bindgen_ty_4 = 1020;
pub const RD_CANCEL_REQUESTED: _bindgen_ty_4 = 1019;
pub const RD_NOT_FOUND: _bindgen_ty_4 = 1018;
pub const RD_ALREADY_INITIALIZED: _bindgen_ty_4 = 1017;
pub const RD_NOT_INITIALIZED: _bindgen_ty_4 = 1016;
pub const RD_INVALID_HANDLE: _bindgen_ty_4 = 1015;
pub const RD_INVALID_POINTER: _bindgen_ty_4 = 1014;
pub const RD_INVALID_ADDRESS: _bindgen_ty_4 = 1013;
pub const RD_NOT_IMPLEMENTED: _bindgen_ty_4 = 1012;
pub const RD_OUT_OF_MEMORY: _bindgen_ty_4 = 1011;
pub const RD_MISALIGNED_SIZE: _bindgen_ty_4 = 1010;
pub const RD_MISALIGNED_ADDRESS: _bindgen_ty_4 = 1009;
pub const RD_BUSY: _bindgen_ty_4 = 1008;
pub const RD_NO_DATA: _bindgen_ty_4 = 1007;
pub const RD_INVALID_COMBINATION: _bindgen_ty_4 = 1006;
pub const RD_INVALID_ENUM_VALUE: _bindgen_ty_4 = 1005;
pub const RD_INVALID_SIZE: _bindgen_ty_4 = 1004;
pub const RD_ALREADY_DONE: _bindgen_ty_4 = 1003;
pub const RD_NOT_AUTHORIZED: _bindgen_ty_4 = 1002;
pub const RD_TOO_LARGE: _bindgen_ty_4 = 1001;
pub const RD_INVALID_SELECTION: _bindgen_ty_4 = 1000;
pub type _bindgen_ty_4 = u32;
pub const IPC_BUFFER_R: IPC_BufferRights = 2;
pub const IPC_BUFFER_W: IPC_BufferRights = 4;
pub const IPC_BUFFER_RW: IPC_BufferRights = 6;
pub type IPC_BufferRights = u32;
pub const MEMOP_FREE: MemOp = 1;
pub const MEMOP_RESERVE: MemOp = 2;
pub const MEMOP_ALLOC: MemOp = 3;
pub const MEMOP_MAP: MemOp = 4;
pub const MEMOP_UNMAP: MemOp = 5;
pub const MEMOP_PROT: MemOp = 6;
pub const MEMOP_REGION_APP: MemOp = 256;
pub const MEMOP_REGION_SYSTEM: MemOp = 512;
pub const MEMOP_REGION_BASE: MemOp = 768;
pub const MEMOP_OP_MASK: MemOp = 255;
pub const MEMOP_REGION_MASK: MemOp = 3840;
pub const MEMOP_LINEAR_FLAG: MemOp = 65536;
pub const MEMOP_ALLOC_LINEAR: MemOp = 65539;
pub type MemOp = u32;
pub const MEMSTATE_FREE: MemState = 0;
pub const MEMSTATE_RESERVED: MemState = 1;
pub const MEMSTATE_IO: MemState = 2;
pub const MEMSTATE_STATIC: MemState = 3;
pub const MEMSTATE_CODE: MemState = 4;
pub const MEMSTATE_PRIVATE: MemState = 5;
pub const MEMSTATE_SHARED: MemState = 6;
pub const MEMSTATE_CONTINUOUS: MemState = 7;
pub const MEMSTATE_ALIASED: MemState = 8;
pub const MEMSTATE_ALIAS: MemState = 9;
pub const MEMSTATE_ALIASCODE: MemState = 10;
pub const MEMSTATE_LOCKED: MemState = 11;
pub type MemState = u32;
pub const MEMPERM_READ: MemPerm = 1;
pub const MEMPERM_WRITE: MemPerm = 2;
pub const MEMPERM_EXECUTE: MemPerm = 4;
pub const MEMPERM_DONTCARE: MemPerm = 268435456;
pub type MemPerm = u32;
#[repr(C)]
pub struct MemInfo {
    pub base_addr: u32,
    pub size: u32,
    pub perm: u32,
    pub state: u32,
}
#[repr(C)]
pub struct PageInfo {
    pub flags: u32,
}
pub const ARBITRATION_SIGNAL: ArbitrationType = 0;
pub const ARBITRATION_WAIT_IF_LESS_THAN: ArbitrationType = 1;
pub const ARBITRATION_DECREMENT_AND_WAIT_IF_LESS_THAN: ArbitrationType = 2;
pub const ARBITRATION_WAIT_IF_LESS_THAN_TIMEOUT: ArbitrationType = 3;
pub const ARBITRATION_DECREMENT_AND_WAIT_IF_LESS_THAN_TIMEOUT: ArbitrationType = 4;
pub type ArbitrationType = u32;
pub const RESET_ONESHOT: ResetType = 0;
pub const RESET_STICKY: ResetType = 1;
pub const RESET_PULSE: ResetType = 2;
pub type ResetType = u32;
pub const THREADINFO_TYPE_UNKNOWN: ThreadInfoType = 0;
pub type ThreadInfoType = u32;
pub const RESLIMIT_PRIORITY: ResourceLimitType = 0;
pub const RESLIMIT_COMMIT: ResourceLimitType = 1;
pub const RESLIMIT_THREAD: ResourceLimitType = 2;
pub const RESLIMIT_EVENT: ResourceLimitType = 3;
pub const RESLIMIT_MUTEX: ResourceLimitType = 4;
pub const RESLIMIT_SEMAPHORE: ResourceLimitType = 5;
pub const RESLIMIT_TIMER: ResourceLimitType = 6;
pub const RESLIMIT_SHAREDMEMORY: ResourceLimitType = 7;
pub const RESLIMIT_ADDRESSARBITER: ResourceLimitType = 8;
pub const RESLIMIT_CPUTIME: ResourceLimitType = 9;
pub const RESLIMIT_BIT: ResourceLimitType = 2147483648;
pub type ResourceLimitType = u32;
#[repr(C)]
pub struct AttachProcessEvent {
    pub program_id: u64,
    pub process_name: [::libc::c_char; 8usize],
    pub process_id: u32,
    pub other_flags: u32,
}
pub const EXITPROCESS_EVENT_EXIT: ExitProcessEventReason = 0;
pub const EXITPROCESS_EVENT_TERMINATE: ExitProcessEventReason = 1;
pub const EXITPROCESS_EVENT_DEBUG_TERMINATE: ExitProcessEventReason = 2;
pub type ExitProcessEventReason = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExitProcessEvent {
    pub reason: ExitProcessEventReason,
}
#[repr(C)]
pub struct AttachThreadEvent {
    pub creator_thread_id: u32,
    pub thread_local_storage: u32,
    pub entry_point: u32,
}
pub const EXITTHREAD_EVENT_EXIT: ExitThreadEventReason = 0;
pub const EXITTHREAD_EVENT_TERMINATE: ExitThreadEventReason = 1;
pub const EXITTHREAD_EVENT_EXIT_PROCESS: ExitThreadEventReason = 2;
pub const EXITTHREAD_EVENT_TERMINATE_PROCESS: ExitThreadEventReason = 3;
pub type ExitThreadEventReason = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExitThreadEvent {
    pub reason: ExitThreadEventReason,
}
pub const USERBREAK_PANIC: UserBreakType = 0;
pub const USERBREAK_ASSERT: UserBreakType = 1;
pub const USERBREAK_USER: UserBreakType = 2;
pub const USERBREAK_LOAD_RO: UserBreakType = 3;
pub const USERBREAK_UNLOAD_RO: UserBreakType = 4;
pub type UserBreakType = u32;
pub const EXCEVENT_UNDEFINED_INSTRUCTION: ExceptionEventType = 0;
pub const EXCEVENT_PREFETCH_ABORT: ExceptionEventType = 1;
pub const EXCEVENT_DATA_ABORT: ExceptionEventType = 2;
pub const EXCEVENT_UNALIGNED_DATA_ACCESS: ExceptionEventType = 3;
pub const EXCEVENT_ATTACH_BREAK: ExceptionEventType = 4;
pub const EXCEVENT_STOP_POINT: ExceptionEventType = 5;
pub const EXCEVENT_USER_BREAK: ExceptionEventType = 6;
pub const EXCEVENT_DEBUGGER_BREAK: ExceptionEventType = 7;
pub const EXCEVENT_UNDEFINED_SYSCALL: ExceptionEventType = 8;
pub type ExceptionEventType = u32;
#[repr(C)]
pub struct FaultExceptionEvent {
    pub fault_information: u32,
}
pub const STOPPOINT_SVC_FF: StopPointType = 0;
pub const STOPPOINT_BREAKPOINT: StopPointType = 1;
pub const STOPPOINT_WATCHPOINT: StopPointType = 2;
pub type StopPointType = u32;
#[repr(C)]
pub struct StopPointExceptionEvent {
    pub type_: StopPointType,
    pub fault_information: u32,
}
#[repr(C)]
pub struct UserBreakExceptionEvent {
    pub type_: UserBreakType,
    pub croInfo: u32,
    pub croInfoSize: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DebuggerBreakExceptionEvent {
    pub thread_ids: [s32; 4usize],
}
#[repr(C)]
pub struct ExceptionEvent {
    pub type_: ExceptionEventType,
    pub address: u32,
    pub __bindgen_anon_1: ExceptionEvent__bindgen_ty_1,
}
#[repr(C)]
pub struct ExceptionEvent__bindgen_ty_1 {
    pub fault: __BindgenUnionField<FaultExceptionEvent>,
    pub stop_point: __BindgenUnionField<StopPointExceptionEvent>,
    pub user_break: __BindgenUnionField<UserBreakExceptionEvent>,
    pub debugger_break: __BindgenUnionField<DebuggerBreakExceptionEvent>,
    pub bindgen_union_field: [u32; 4usize],
}
#[repr(C)]
pub struct ScheduleInOutEvent {
    pub clock_tick: u64,
}
#[repr(C)]
pub struct SyscallInOutEvent {
    pub clock_tick: u64,
    pub syscall: u32,
}
#[repr(C)]
pub struct OutputStringEvent {
    pub string_addr: u32,
    pub string_size: u32,
}
#[repr(C)]
pub struct MapEvent {
    pub mapped_addr: u32,
    pub mapped_size: u32,
    pub memperm: MemPerm,
    pub memstate: MemState,
}
pub const DBGEVENT_ATTACH_PROCESS: DebugEventType = 0;
pub const DBGEVENT_ATTACH_THREAD: DebugEventType = 1;
pub const DBGEVENT_EXIT_THREAD: DebugEventType = 2;
pub const DBGEVENT_EXIT_PROCESS: DebugEventType = 3;
pub const DBGEVENT_EXCEPTION: DebugEventType = 4;
pub const DBGEVENT_DLL_LOAD: DebugEventType = 5;
pub const DBGEVENT_DLL_UNLOAD: DebugEventType = 6;
pub const DBGEVENT_SCHEDULE_IN: DebugEventType = 7;
pub const DBGEVENT_SCHEDULE_OUT: DebugEventType = 8;
pub const DBGEVENT_SYSCALL_IN: DebugEventType = 9;
pub const DBGEVENT_SYSCALL_OUT: DebugEventType = 10;
pub const DBGEVENT_OUTPUT_STRING: DebugEventType = 11;
pub const DBGEVENT_MAP: DebugEventType = 12;
pub type DebugEventType = u32;
#[repr(C)]
pub struct DebugEventInfo {
    pub type_: DebugEventType,
    pub thread_id: u32,
    pub flags: u32,
    pub remnants: [u8; 4usize],
    pub __bindgen_anon_1: DebugEventInfo__bindgen_ty_1,
}
#[repr(C)]
pub struct DebugEventInfo__bindgen_ty_1 {
    pub attach_process: __BindgenUnionField<AttachProcessEvent>,
    pub attach_thread: __BindgenUnionField<AttachThreadEvent>,
    pub exit_thread: __BindgenUnionField<ExitThreadEvent>,
    pub exit_process: __BindgenUnionField<ExitProcessEvent>,
    pub exception: __BindgenUnionField<ExceptionEvent>,
    pub scheduler: __BindgenUnionField<ScheduleInOutEvent>,
    pub syscall: __BindgenUnionField<SyscallInOutEvent>,
    pub output_string: __BindgenUnionField<OutputStringEvent>,
    pub map: __BindgenUnionField<MapEvent>,
    pub bindgen_union_field: [u64; 3usize],
}
pub const DBG_INHIBIT_USER_CPU_EXCEPTION_HANDLERS: DebugFlags = 1;
pub const DBG_SIGNAL_FAULT_EXCEPTION_EVENTS: DebugFlags = 2;
pub const DBG_SIGNAL_SCHEDULE_EVENTS: DebugFlags = 4;
pub const DBG_SIGNAL_SYSCALL_EVENTS: DebugFlags = 8;
pub const DBG_SIGNAL_MAP_EVENTS: DebugFlags = 16;
pub type DebugFlags = u32;
#[repr(C)]
pub struct ThreadContext {
    pub cpu_registers: CpuRegisters,
    pub fpu_registers: FpuRegisters,
}
pub const THREADCONTEXT_CONTROL_CPU_GPRS: ThreadContextControlFlags = 1;
pub const THREADCONTEXT_CONTROL_CPU_SPRS: ThreadContextControlFlags = 2;
pub const THREADCONTEXT_CONTROL_FPU_GPRS: ThreadContextControlFlags = 4;
pub const THREADCONTEXT_CONTROL_FPU_SPRS: ThreadContextControlFlags = 8;
pub const THREADCONTEXT_CONTROL_CPU_REGS: ThreadContextControlFlags = 3;
pub const THREADCONTEXT_CONTROL_FPU_REGS: ThreadContextControlFlags = 12;
pub const THREADCONTEXT_CONTROL_ALL: ThreadContextControlFlags = 15;
pub type ThreadContextControlFlags = u32;
pub const DBGTHREAD_PARAMETER_PRIORITY: DebugThreadParameter = 0;
pub const DBGTHREAD_PARAMETER_SCHEDULING_MASK_LOW: DebugThreadParameter = 1;
pub const DBGTHREAD_PARAMETER_CPU_IDEAL: DebugThreadParameter = 2;
pub const DBGTHREAD_PARAMETER_CPU_CREATOR: DebugThreadParameter = 3;
pub type DebugThreadParameter = u32;
#[repr(C)]
pub struct CodeSetInfo {
    pub name: [u8; 8usize],
    pub unk1: u16,
    pub unk2: u16,
    pub unk3: u32,
    pub text_addr: u32,
    pub text_size: u32,
    pub ro_addr: u32,
    pub ro_size: u32,
    pub rw_addr: u32,
    pub rw_size: u32,
    pub text_size_total: u32,
    pub ro_size_total: u32,
    pub rw_size_total: u32,
    pub unk4: u32,
    pub program_id: u64,
}
#[repr(C)]
pub struct StartupInfo {
    pub priority: ::libc::c_int,
    pub stack_size: u32,
    pub argc: ::libc::c_int,
    pub argv: *mut u16,
    pub envp: *mut u16,
}
extern "C" {
    pub fn svcControlMemory(
        addr_out: *mut u32,
        addr0: u32,
        addr1: u32,
        size: u32,
        op: MemOp,
        perm: MemPerm,
    ) -> Result;
}
extern "C" {
    pub fn svcControlProcessMemory(
        process: Handle,
        addr0: u32,
        addr1: u32,
        size: u32,
        type_: u32,
        perm: u32,
    ) -> Result;
}
extern "C" {
    pub fn svcCreateMemoryBlock(
        memblock: *mut Handle,
        addr: u32,
        size: u32,
        my_perm: MemPerm,
        other_perm: MemPerm,
    ) -> Result;
}
extern "C" {
    pub fn svcMapMemoryBlock(
        memblock: Handle,
        addr: u32,
        my_perm: MemPerm,
        other_perm: MemPerm,
    ) -> Result;
}
extern "C" {
    pub fn svcMapProcessMemory(process: Handle, destAddress: u32, size: u32) -> Result;
}
extern "C" {
    pub fn svcUnmapProcessMemory(process: Handle, destAddress: u32, size: u32) -> Result;
}
extern "C" {
    pub fn svcUnmapMemoryBlock(memblock: Handle, addr: u32) -> Result;
}
extern "C" {
    pub fn svcStartInterProcessDma(
        dma: *mut Handle,
        dstProcess: Handle,
        dst: *mut ::libc::c_void,
        srcProcess: Handle,
        src: *const ::libc::c_void,
        size: u32,
        dmaConfig: *mut ::libc::c_void,
    ) -> Result;
}
extern "C" {
    pub fn svcStopDma(dma: Handle) -> Result;
}
extern "C" {
    pub fn svcGetDmaState(dmaState: *mut ::libc::c_void, dma: Handle) -> Result;
}
extern "C" {
    pub fn svcQueryMemory(info: *mut MemInfo, out: *mut PageInfo, addr: u32) -> Result;
}
extern "C" {
    pub fn svcQueryProcessMemory(
        info: *mut MemInfo,
        out: *mut PageInfo,
        process: Handle,
        addr: u32,
    ) -> Result;
}
extern "C" {
    pub fn svcInvalidateProcessDataCache(
        process: Handle,
        addr: *mut ::libc::c_void,
        size: u32,
    ) -> Result;
}
extern "C" {
    pub fn svcStoreProcessDataCache(
        process: Handle,
        addr: *mut ::libc::c_void,
        size: u32,
    ) -> Result;
}
extern "C" {
    pub fn svcFlushProcessDataCache(
        process: Handle,
        addr: *const ::libc::c_void,
        size: u32,
    ) -> Result;
}
extern "C" {
    pub fn svcOpenProcess(process: *mut Handle, processId: u32) -> Result;
}
extern "C" {
    pub fn svcExitProcess();
}
extern "C" {
    pub fn svcTerminateProcess(process: Handle) -> Result;
}
extern "C" {
    pub fn svcGetProcessInfo(out: *mut s64, process: Handle, type_: u32) -> Result;
}
extern "C" {
    pub fn svcGetProcessId(out: *mut u32, handle: Handle) -> Result;
}
extern "C" {
    pub fn svcGetProcessList(
        processCount: *mut s32,
        processIds: *mut u32,
        processIdMaxCount: s32,
    ) -> Result;
}
extern "C" {
    pub fn svcGetThreadList(
        threadCount: *mut s32,
        threadIds: *mut u32,
        threadIdMaxCount: s32,
        process: Handle,
    ) -> Result;
}
extern "C" {
    pub fn svcCreatePort(
        portServer: *mut Handle,
        portClient: *mut Handle,
        name: *const ::libc::c_char,
        maxSessions: s32,
    ) -> Result;
}
extern "C" {
    pub fn svcConnectToPort(out: *mut Handle, portName: *const ::libc::c_char) -> Result;
}
extern "C" {
    pub fn svcCreateCodeSet(
        out: *mut Handle,
        info: *const CodeSetInfo,
        code_ptr: *mut ::libc::c_void,
        ro_ptr: *mut ::libc::c_void,
        data_ptr: *mut ::libc::c_void,
    ) -> Result;
}
extern "C" {
    pub fn svcCreateProcess(
        out: *mut Handle,
        codeset: Handle,
        arm11kernelcaps: *const u32,
        arm11kernelcaps_num: u32,
    ) -> Result;
}
extern "C" {
    pub fn svcGetProcessAffinityMask(
        affinitymask: *mut u8,
        process: Handle,
        processorcount: s32,
    ) -> Result;
}
extern "C" {
    pub fn svcSetProcessAffinityMask(
        process: Handle,
        affinitymask: *const u8,
        processorcount: s32,
    ) -> Result;
}
extern "C" {
    pub fn svcGetProcessIdealProcessor(processorid: *mut s32, process: Handle) -> Result;
}
extern "C" {
    pub fn svcSetProcessIdealProcessor(process: Handle, processorid: s32) -> Result;
}
extern "C" {
    pub fn svcRun(process: Handle, info: *const StartupInfo) -> Result;
}
extern "C" {
    pub fn svcCreateThread(
        thread: *mut Handle,
        entrypoint: ThreadFunc,
        arg: u32,
        stack_top: *mut u32,
        thread_priority: s32,
        processor_id: s32,
    ) -> Result;
}
extern "C" {
    pub fn svcOpenThread(thread: *mut Handle, process: Handle, threadId: u32) -> Result;
}
extern "C" {
    pub fn svcExitThread();
}
extern "C" {
    pub fn svcSleepThread(ns: s64);
}
extern "C" {
    pub fn svcGetThreadPriority(out: *mut s32, handle: Handle) -> Result;
}
extern "C" {
    pub fn svcSetThreadPriority(thread: Handle, prio: s32) -> Result;
}
extern "C" {
    pub fn svcGetThreadAffinityMask(
        affinitymask: *mut u8,
        thread: Handle,
        processorcount: s32,
    ) -> Result;
}
extern "C" {
    pub fn svcSetThreadAffinityMask(
        thread: Handle,
        affinitymask: *const u8,
        processorcount: s32,
    ) -> Result;
}
extern "C" {
    pub fn svcGetThreadIdealProcessor(processorid: *mut s32, thread: Handle) -> Result;
}
extern "C" {
    pub fn svcSetThreadIdealProcessor(thread: Handle, processorid: s32) -> Result;
}
extern "C" {
    pub fn svcGetProcessorID() -> s32;
}
extern "C" {
    pub fn svcGetThreadId(out: *mut u32, handle: Handle) -> Result;
}
extern "C" {
    pub fn svcGetResourceLimit(resourceLimit: *mut Handle, process: Handle) -> Result;
}
extern "C" {
    pub fn svcGetResourceLimitLimitValues(
        values: *mut s64,
        resourceLimit: Handle,
        names: *mut ResourceLimitType,
        nameCount: s32,
    ) -> Result;
}
extern "C" {
    pub fn svcGetResourceLimitCurrentValues(
        values: *mut s64,
        resourceLimit: Handle,
        names: *mut ResourceLimitType,
        nameCount: s32,
    ) -> Result;
}
extern "C" {
    pub fn svcSetProcessResourceLimits(process: Handle, resourceLimit: Handle) -> Result;
}
extern "C" {
    pub fn svcCreateResourceLimit(resourceLimit: *mut Handle) -> Result;
}
extern "C" {
    pub fn svcSetResourceLimitValues(
        resourceLimit: Handle,
        names: *const ResourceLimitType,
        values: *const s64,
        nameCount: s32,
    ) -> Result;
}
extern "C" {
    pub fn svcGetProcessIdOfThread(out: *mut u32, handle: Handle) -> Result;
}
extern "C" {
    pub fn svcGetThreadInfo(out: *mut s64, thread: Handle, type_: ThreadInfoType) -> Result;
}
extern "C" {
    pub fn svcCreateMutex(mutex: *mut Handle, initially_locked: bool) -> Result;
}
extern "C" {
    pub fn svcReleaseMutex(handle: Handle) -> Result;
}
extern "C" {
    pub fn svcCreateSemaphore(semaphore: *mut Handle, initial_count: s32, max_count: s32)
        -> Result;
}
extern "C" {
    pub fn svcReleaseSemaphore(count: *mut s32, semaphore: Handle, release_count: s32) -> Result;
}
extern "C" {
    pub fn svcCreateEvent(event: *mut Handle, reset_type: ResetType) -> Result;
}
extern "C" {
    pub fn svcSignalEvent(handle: Handle) -> Result;
}
extern "C" {
    pub fn svcClearEvent(handle: Handle) -> Result;
}
extern "C" {
    pub fn svcWaitSynchronization(handle: Handle, nanoseconds: s64) -> Result;
}
extern "C" {
    pub fn svcWaitSynchronizationN(
        out: *mut s32,
        handles: *const Handle,
        handles_num: s32,
        wait_all: bool,
        nanoseconds: s64,
    ) -> Result;
}
extern "C" {
    pub fn svcCreateAddressArbiter(arbiter: *mut Handle) -> Result;
}
extern "C" {
    pub fn svcArbitrateAddress(
        arbiter: Handle,
        addr: u32,
        type_: ArbitrationType,
        value: s32,
        nanoseconds: s64,
    ) -> Result;
}
extern "C" {
    pub fn svcSendSyncRequest(session: Handle) -> Result;
}
extern "C" {
    pub fn svcCreateSessionToPort(clientSession: *mut Handle, clientPort: Handle) -> Result;
}
extern "C" {
    pub fn svcCreateSession(serverSession: *mut Handle, clientSession: *mut Handle) -> Result;
}
extern "C" {
    pub fn svcAcceptSession(session: *mut Handle, port: Handle) -> Result;
}
extern "C" {
    pub fn svcReplyAndReceive(
        index: *mut s32,
        handles: *const Handle,
        handleCount: s32,
        replyTarget: Handle,
    ) -> Result;
}
extern "C" {
    pub fn svcBindInterrupt(
        interruptId: u32,
        eventOrSemaphore: Handle,
        priority: s32,
        isManualClear: bool,
    ) -> Result;
}
extern "C" {
    pub fn svcUnbindInterrupt(interruptId: u32, eventOrSemaphore: Handle) -> Result;
}
extern "C" {
    pub fn svcCreateTimer(timer: *mut Handle, reset_type: ResetType) -> Result;
}
extern "C" {
    pub fn svcSetTimer(timer: Handle, initial: s64, interval: s64) -> Result;
}
extern "C" {
    pub fn svcCancelTimer(timer: Handle) -> Result;
}
extern "C" {
    pub fn svcClearTimer(timer: Handle) -> Result;
}
extern "C" {
    pub fn svcGetSystemTick() -> u64;
}
extern "C" {
    pub fn svcCloseHandle(handle: Handle) -> Result;
}
extern "C" {
    pub fn svcDuplicateHandle(out: *mut Handle, original: Handle) -> Result;
}
extern "C" {
    pub fn svcGetHandleInfo(out: *mut s64, handle: Handle, param: u32) -> Result;
}
extern "C" {
    pub fn svcGetSystemInfo(out: *mut s64, type_: u32, param: s32) -> Result;
}
extern "C" {
    pub fn svcSetGpuProt(useApplicationRestriction: bool) -> Result;
}
extern "C" {
    pub fn svcSetWifiEnabled(enabled: bool) -> Result;
}
extern "C" {
    pub fn svcKernelSetState(type_: u32, ...) -> Result;
}
extern "C" {
    pub fn svcBreak(breakReason: UserBreakType);
}
extern "C" {
    pub fn svcBreakRO(breakReason: UserBreakType, croInfo: *const ::libc::c_void, croInfoSize: u32);
}
extern "C" {
    pub fn svcOutputDebugString(str: *const ::libc::c_char, length: s32) -> Result;
}
extern "C" {
    pub fn svcDebugActiveProcess(debug: *mut Handle, processId: u32) -> Result;
}
extern "C" {
    pub fn svcBreakDebugProcess(debug: Handle) -> Result;
}
extern "C" {
    pub fn svcTerminateDebugProcess(debug: Handle) -> Result;
}
extern "C" {
    pub fn svcGetProcessDebugEvent(info: *mut DebugEventInfo, debug: Handle) -> Result;
}
extern "C" {
    pub fn svcContinueDebugEvent(debug: Handle, flags: DebugFlags) -> Result;
}
extern "C" {
    pub fn svcGetDebugThreadContext(
        context: *mut ThreadContext,
        debug: Handle,
        threadId: u32,
        controlFlags: ThreadContextControlFlags,
    ) -> Result;
}
extern "C" {
    pub fn svcSetDebugThreadContext(
        debug: Handle,
        threadId: u32,
        context: *mut ThreadContext,
        controlFlags: ThreadContextControlFlags,
    ) -> Result;
}
extern "C" {
    pub fn svcQueryDebugProcessMemory(
        info: *mut MemInfo,
        out: *mut PageInfo,
        debug: Handle,
        addr: u32,
    ) -> Result;
}
extern "C" {
    pub fn svcReadProcessMemory(
        buffer: *mut ::libc::c_void,
        debug: Handle,
        addr: u32,
        size: u32,
    ) -> Result;
}
extern "C" {
    pub fn svcWriteProcessMemory(
        debug: Handle,
        buffer: *const ::libc::c_void,
        addr: u32,
        size: u32,
    ) -> Result;
}
extern "C" {
    pub fn svcSetHardwareBreakPoint(registerId: s32, control: u32, value: u32) -> Result;
}
extern "C" {
    pub fn svcGetDebugThreadParam(
        unused: *mut s64,
        out: *mut u32,
        debug: Handle,
        threadId: u32,
        parameter: DebugThreadParameter,
    ) -> Result;
}
extern "C" {
    pub fn svcBackdoor(callback: ::core::option::Option<unsafe extern "C" fn() -> s32>) -> Result;
}
pub const ARM9DESC_MOUNT_NAND: _bindgen_ty_5 = 1;
pub const ARM9DESC_MOUNT_NANDRO_RW: _bindgen_ty_5 = 2;
pub const ARM9DESC_MOUNT_TWLN: _bindgen_ty_5 = 4;
pub const ARM9DESC_MOUNT_WNAND: _bindgen_ty_5 = 8;
pub const ARM9DESC_MOUNT_CARDSPI: _bindgen_ty_5 = 16;
pub const ARM9DESC_USE_SDIF3: _bindgen_ty_5 = 32;
pub const ARM9DESC_CREATE_SEED: _bindgen_ty_5 = 64;
pub const ARM9DESC_USE_CARD_SPI: _bindgen_ty_5 = 128;
pub const ARM9DESC_SD_APPLICATION: _bindgen_ty_5 = 256;
pub const ARM9DESC_MOUNT_SDMC_RW: _bindgen_ty_5 = 512;
pub type _bindgen_ty_5 = u32;
pub const FSACCESS_CATEGORY_SYSTEM_APPLICATION: _bindgen_ty_6 = 1;
pub const FSACCESS_CATEGORY_HARDWARE_CHECK: _bindgen_ty_6 = 2;
pub const FSACCESS_CATEGORY_FILESYSTEM_TOOL: _bindgen_ty_6 = 4;
pub const FSACCESS_DEBUG: _bindgen_ty_6 = 8;
pub const FSACCESS_TWLCARD_BACKUP: _bindgen_ty_6 = 16;
pub const FSACCESS_TWLNAND_DATA: _bindgen_ty_6 = 32;
pub const FSACCESS_BOSS: _bindgen_ty_6 = 64;
pub const FSACCESS_SDMC_RW: _bindgen_ty_6 = 128;
pub const FSACCESS_CORE: _bindgen_ty_6 = 256;
pub const FSACCESS_NANDRO_RO: _bindgen_ty_6 = 512;
pub const FSACCESS_NANDRW: _bindgen_ty_6 = 1024;
pub const FSACCESS_NANDRO_RW: _bindgen_ty_6 = 2048;
pub const FSACCESS_CATEGORY_SYSTEM_SETTINGS: _bindgen_ty_6 = 4096;
pub const FSACCESS_CARDBOARD: _bindgen_ty_6 = 8192;
pub const FSACCESS_EXPORT_IMPORT_IVS: _bindgen_ty_6 = 16384;
pub const FSACCESS_SDMC_WO: _bindgen_ty_6 = 32768;
pub const FSACCESS_SWITCH_CLEANUP: _bindgen_ty_6 = 65536;
pub const FSACCESS_SAVEDATA_MOVE: _bindgen_ty_6 = 131072;
pub const FSACCESS_SHOP: _bindgen_ty_6 = 262144;
pub const FSACCESS_SHELL: _bindgen_ty_6 = 524288;
pub const FSACCESS_CATEGORY_HOME_MENU: _bindgen_ty_6 = 1048576;
pub const FSACCESS_SEEDDB: _bindgen_ty_6 = 2097152;
pub type _bindgen_ty_6 = u32;
pub const RESLIMIT_CATEGORY_APPLICATION: ResourceLimitCategory = 0;
pub const RESLIMIT_CATEGORY_SYS_APPLET: ResourceLimitCategory = 1;
pub const RESLIMIT_CATEGORY_LIB_APPLET: ResourceLimitCategory = 2;
pub const RESLIMIT_CATEGORY_OTHER: ResourceLimitCategory = 3;
pub type ResourceLimitCategory = u32;
pub const SYSMODE_O3DS_PROD: SystemMode = 0;
pub const SYSMODE_N3DS_PROD: SystemMode = 1;
pub const SYSMODE_DEV1: SystemMode = 2;
pub const SYSMODE_DEV2: SystemMode = 3;
pub const SYSMODE_DEV3: SystemMode = 4;
pub const SYSMODE_DEV4: SystemMode = 5;
pub type SystemMode = u32;
#[repr(C)]
pub struct ExHeader_SystemInfoFlags {
    pub reserved: [u8; 5usize],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub remaster_version: u16,
}
impl ExHeader_SystemInfoFlags {
    #[inline]
    pub fn compress_exefs_code(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_compress_exefs_code(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_sd_application(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_sd_application(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        compress_exefs_code: bool,
        is_sd_application: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let compress_exefs_code: u8 = unsafe { ::core::mem::transmute(compress_exefs_code) };
            compress_exefs_code as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let is_sd_application: u8 = unsafe { ::core::mem::transmute(is_sd_application) };
            is_sd_application as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct ExHeader_CodeSectionInfo {
    pub address: u32,
    pub num_pages: u32,
    pub size: u32,
}
#[repr(C)]
pub struct ExHeader_CodeSetInfo {
    pub name: [::libc::c_char; 8usize],
    pub flags: ExHeader_SystemInfoFlags,
    pub text: ExHeader_CodeSectionInfo,
    pub stack_size: u32,
    pub rodata: ExHeader_CodeSectionInfo,
    pub reserved: u32,
    pub data: ExHeader_CodeSectionInfo,
    pub bss_size: u32,
}
#[repr(C)]
pub struct ExHeader_SystemInfo {
    pub savedata_size: u64,
    pub jump_id: u64,
    pub reserved: [u8; 48usize],
}
#[repr(C)]
pub struct ExHeader_SystemControlInfo {
    pub codeset_info: ExHeader_CodeSetInfo,
    pub dependencies: [u64; 48usize],
    pub system_info: ExHeader_SystemInfo,
}
#[repr(C)]
pub struct ExHeader_Arm11StorageInfo {
    pub extdata_id: u64,
    pub system_savedata_ids: [u32; 2usize],
    pub accessible_savedata_ids: u64,
    pub fs_access_info: u32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl ExHeader_Arm11StorageInfo {
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn no_romfs(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_romfs(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn use_extended_savedata_access(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_use_extended_savedata_access(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved: u32,
        no_romfs: bool,
        use_extended_savedata_access: bool,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let no_romfs: u8 = unsafe { ::core::mem::transmute(no_romfs) };
            no_romfs as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let use_extended_savedata_access: u8 =
                unsafe { ::core::mem::transmute(use_extended_savedata_access) };
            use_extended_savedata_access as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct ExHeader_Arm11CoreInfo {
    pub core_version: u32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize], u8>,
    pub priority: u8,
}
impl ExHeader_Arm11CoreInfo {
    #[inline]
    pub fn use_cpu_clockrate_804MHz(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_use_cpu_clockrate_804MHz(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_l2c(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enable_l2c(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flag1_unused(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_flag1_unused(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn n3ds_system_mode(&self) -> SystemMode {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_n3ds_system_mode(&mut self, val: SystemMode) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn flag2_unused(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_flag2_unused(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn ideal_processor(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_ideal_processor(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn affinity_mask(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_affinity_mask(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn o3ds_system_mode(&self) -> SystemMode {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_o3ds_system_mode(&mut self, val: SystemMode) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        use_cpu_clockrate_804MHz: bool,
        enable_l2c: bool,
        flag1_unused: u8,
        n3ds_system_mode: SystemMode,
        flag2_unused: u8,
        ideal_processor: u8,
        affinity_mask: u8,
        o3ds_system_mode: SystemMode,
    ) -> __BindgenBitfieldUnit<[u8; 3usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let use_cpu_clockrate_804MHz: u8 =
                unsafe { ::core::mem::transmute(use_cpu_clockrate_804MHz) };
            use_cpu_clockrate_804MHz as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let enable_l2c: u8 = unsafe { ::core::mem::transmute(enable_l2c) };
            enable_l2c as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let flag1_unused: u8 = unsafe { ::core::mem::transmute(flag1_unused) };
            flag1_unused as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let n3ds_system_mode: u32 = unsafe { ::core::mem::transmute(n3ds_system_mode) };
            n3ds_system_mode as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let flag2_unused: u8 = unsafe { ::core::mem::transmute(flag2_unused) };
            flag2_unused as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let ideal_processor: u8 = unsafe { ::core::mem::transmute(ideal_processor) };
            ideal_processor as u64
        });
        __bindgen_bitfield_unit.set(18usize, 2u8, {
            let affinity_mask: u8 = unsafe { ::core::mem::transmute(affinity_mask) };
            affinity_mask as u64
        });
        __bindgen_bitfield_unit.set(20usize, 4u8, {
            let o3ds_system_mode: u32 = unsafe { ::core::mem::transmute(o3ds_system_mode) };
            o3ds_system_mode as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct ExHeader_Arm11SystemLocalCapabilities {
    pub title_id: u64,
    pub core_info: ExHeader_Arm11CoreInfo,
    pub reslimits: [u16; 16usize],
    pub storage_info: ExHeader_Arm11StorageInfo,
    pub service_access: [[::libc::c_char; 8usize]; 34usize],
    pub reserved: [u8; 15usize],
    pub reslimit_category: ResourceLimitCategory,
}
#[repr(C)]
pub struct ExHeader_Arm11KernelCapabilities {
    pub descriptors: [u32; 28usize],
    pub reserved: [u8; 16usize],
}
#[repr(C)]
pub struct ExHeader_Arm9AccessControl {
    pub descriptors: [u8; 15usize],
    pub descriptor_version: u8,
}
#[repr(C)]
pub struct ExHeader_AccessControlInfo {
    pub local_caps: ExHeader_Arm11SystemLocalCapabilities,
    pub kernel_caps: ExHeader_Arm11KernelCapabilities,
    pub access_control: ExHeader_Arm9AccessControl,
}
#[repr(C)]
pub struct ExHeader_Info {
    pub sci: ExHeader_SystemControlInfo,
    pub aci: ExHeader_AccessControlInfo,
}
#[repr(C)]
pub struct ExHeader_AccessDescriptor {
    pub signature: [u8; 256usize],
    pub ncchModulus: [u8; 256usize],
    pub acli: ExHeader_AccessControlInfo,
}
#[repr(C)]
pub struct ExHeader {
    pub info: ExHeader_Info,
    pub access_descriptor: ExHeader_AccessDescriptor,
}
extern "C" {
    pub fn srvInit() -> Result;
}
extern "C" {
    pub fn srvExit();
}
extern "C" {
    pub fn srvSetBlockingPolicy(nonBlocking: bool);
}
extern "C" {
    pub fn srvGetSessionHandle() -> *mut Handle;
}
extern "C" {
    pub fn srvGetServiceHandle(out: *mut Handle, name: *const ::libc::c_char) -> Result;
}
extern "C" {
    pub fn srvRegisterClient() -> Result;
}
extern "C" {
    pub fn srvEnableNotification(semaphoreOut: *mut Handle) -> Result;
}
extern "C" {
    pub fn srvRegisterService(
        out: *mut Handle,
        name: *const ::libc::c_char,
        maxSessions: ::libc::c_int,
    ) -> Result;
}
extern "C" {
    pub fn srvUnregisterService(name: *const ::libc::c_char) -> Result;
}
extern "C" {
    pub fn srvGetServiceHandleDirect(out: *mut Handle, name: *const ::libc::c_char) -> Result;
}
extern "C" {
    pub fn srvRegisterPort(name: *const ::libc::c_char, clientHandle: Handle) -> Result;
}
extern "C" {
    pub fn srvUnregisterPort(name: *const ::libc::c_char) -> Result;
}
extern "C" {
    pub fn srvGetPort(out: *mut Handle, name: *const ::libc::c_char) -> Result;
}
extern "C" {
    pub fn srvWaitForPortRegistered(name: *const ::libc::c_char) -> Result;
}
extern "C" {
    pub fn srvSubscribe(notificationId: u32) -> Result;
}
extern "C" {
    pub fn srvUnsubscribe(notificationId: u32) -> Result;
}
extern "C" {
    pub fn srvReceiveNotification(notificationIdOut: *mut u32) -> Result;
}
extern "C" {
    pub fn srvPublishToSubscriber(notificationId: u32, flags: u32) -> Result;
}
extern "C" {
    pub fn srvPublishAndGetSubscriber(
        processIdCountOut: *mut u32,
        processIdsOut: *mut u32,
        notificationId: u32,
    ) -> Result;
}
extern "C" {
    pub fn srvIsServiceRegistered(registeredOut: *mut bool, name: *const ::libc::c_char) -> Result;
}
extern "C" {
    pub fn srvIsPortRegistered(registeredOut: *mut bool, name: *const ::libc::c_char) -> Result;
}
pub const ERRF_ERRTYPE_GENERIC: ERRF_ErrType = 0;
pub const ERRF_ERRTYPE_MEM_CORRUPT: ERRF_ErrType = 1;
pub const ERRF_ERRTYPE_CARD_REMOVED: ERRF_ErrType = 2;
pub const ERRF_ERRTYPE_EXCEPTION: ERRF_ErrType = 3;
pub const ERRF_ERRTYPE_FAILURE: ERRF_ErrType = 4;
pub const ERRF_ERRTYPE_LOGGED: ERRF_ErrType = 5;
pub type ERRF_ErrType = u32;
pub const ERRF_EXCEPTION_PREFETCH_ABORT: ERRF_ExceptionType = 0;
pub const ERRF_EXCEPTION_DATA_ABORT: ERRF_ExceptionType = 1;
pub const ERRF_EXCEPTION_UNDEFINED: ERRF_ExceptionType = 2;
pub const ERRF_EXCEPTION_VFP: ERRF_ExceptionType = 3;
pub type ERRF_ExceptionType = u32;
#[repr(C)]
pub struct ERRF_ExceptionInfo {
    pub type_: ERRF_ExceptionType,
    pub reserved: [u8; 3usize],
    pub fsr: u32,
    pub far: u32,
    pub fpexc: u32,
    pub fpinst: u32,
    pub fpinst2: u32,
}
#[repr(C)]
pub struct ERRF_ExceptionData {
    pub excep: ERRF_ExceptionInfo,
    pub regs: CpuRegisters,
}
#[repr(C)]
pub struct ERRF_FatalErrInfo {
    pub type_: ERRF_ErrType,
    pub revHigh: u8,
    pub revLow: u16,
    pub resCode: u32,
    pub pcAddr: u32,
    pub procId: u32,
    pub titleId: u64,
    pub appTitleId: u64,
    pub data: ERRF_FatalErrInfo__bindgen_ty_1,
}
#[repr(C)]
pub struct ERRF_FatalErrInfo__bindgen_ty_1 {
    pub exception_data: __BindgenUnionField<ERRF_ExceptionData>,
    pub failure_mesg: __BindgenUnionField<[::libc::c_char; 96usize]>,
    pub bindgen_union_field: [u32; 24usize],
}
extern "C" {
    pub fn errfInit() -> Result;
}
extern "C" {
    pub fn errfExit();
}
extern "C" {
    pub fn errfGetSessionHandle() -> *mut Handle;
}
extern "C" {
    pub fn ERRF_Throw(error: *const ERRF_FatalErrInfo) -> Result;
}
extern "C" {
    pub fn ERRF_ThrowResult(failure: Result) -> Result;
}
extern "C" {
    pub fn ERRF_ThrowResultWithMessage(failure: Result, message: *const ::libc::c_char) -> Result;
}
extern "C" {
    pub fn ERRF_ExceptionHandler(excep: *mut ERRF_ExceptionInfo, regs: *mut CpuRegisters);
}
pub const MEMREGION_ALL: MemRegion = 0;
pub const MEMREGION_APPLICATION: MemRegion = 1;
pub const MEMREGION_SYSTEM: MemRegion = 2;
pub const MEMREGION_BASE: MemRegion = 3;
pub type MemRegion = u32;
#[repr(C)]
pub struct TickCounter {
    pub elapsed: u64,
    pub reference: u64,
}
#[repr(C)]
pub struct OS_VersionBin {
    pub build: u8,
    pub minor: u8,
    pub mainver: u8,
    pub reserved_x3: u8,
    pub region: ::libc::c_char,
    pub reserved_x5: [u8; 3usize],
}
extern "C" {
    pub fn osConvertVirtToPhys(vaddr: *const ::libc::c_void) -> u32;
}
extern "C" {
    pub fn osConvertOldLINEARMemToNew(vaddr: *const ::libc::c_void) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn osStrError(error: u32) -> *const ::libc::c_char;
}
extern "C" {
    pub fn osGetMemRegionUsed(region: MemRegion) -> s64;
}
extern "C" {
    pub fn osGetTime() -> u64;
}
extern "C" {
    pub fn osTickCounterRead(cnt: *const TickCounter) -> f64;
}
extern "C" {
    pub fn osSetSpeedupEnable(enable: bool);
}
extern "C" {
    pub fn osGetSystemVersionData(
        nver_versionbin: *mut OS_VersionBin,
        cver_versionbin: *mut OS_VersionBin,
    ) -> Result;
}
extern "C" {
    pub fn osGetSystemVersionDataString(
        nver_versionbin: *mut OS_VersionBin,
        cver_versionbin: *mut OS_VersionBin,
        sysverstr: *mut ::libc::c_char,
        sysverstr_maxsize: u32,
    ) -> Result;
}
pub type _LOCK_T = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __lock_t {
    pub lock: _LOCK_T,
    pub thread_tag: u32,
    pub counter: u32,
}
pub type _LOCK_RECURSIVE_T = __lock_t;
extern "C" {
    pub fn __libc_lock_init(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_init_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_close(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_close_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_acquire(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_acquire_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_release(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_release_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_try_acquire(lock: *mut _LOCK_T) -> ::libc::c_int;
}
extern "C" {
    pub fn __libc_lock_try_acquire_recursive(lock: *mut _LOCK_RECURSIVE_T) -> ::libc::c_int;
}
pub type LightLock = _LOCK_T;
pub type RecursiveLock = _LOCK_RECURSIVE_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LightEvent {
    pub state: s32,
    pub lock: LightLock,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LightSemaphore {
    pub current_count: s32,
    pub num_threads_acq: s16,
    pub max_count: s16,
}
extern "C" {
    pub fn __sync_get_arbiter() -> Handle;
}
extern "C" {
    pub fn LightLock_Init(lock: *mut LightLock);
}
extern "C" {
    pub fn LightLock_Lock(lock: *mut LightLock);
}
extern "C" {
    pub fn LightLock_TryLock(lock: *mut LightLock) -> ::libc::c_int;
}
extern "C" {
    pub fn LightLock_Unlock(lock: *mut LightLock);
}
extern "C" {
    pub fn RecursiveLock_Init(lock: *mut RecursiveLock);
}
extern "C" {
    pub fn RecursiveLock_Lock(lock: *mut RecursiveLock);
}
extern "C" {
    pub fn RecursiveLock_TryLock(lock: *mut RecursiveLock) -> ::libc::c_int;
}
extern "C" {
    pub fn RecursiveLock_Unlock(lock: *mut RecursiveLock);
}
extern "C" {
    pub fn LightEvent_Init(event: *mut LightEvent, reset_type: ResetType);
}
extern "C" {
    pub fn LightEvent_Clear(event: *mut LightEvent);
}
extern "C" {
    pub fn LightEvent_Pulse(event: *mut LightEvent);
}
extern "C" {
    pub fn LightEvent_Signal(event: *mut LightEvent);
}
extern "C" {
    pub fn LightEvent_TryWait(event: *mut LightEvent) -> ::libc::c_int;
}
extern "C" {
    pub fn LightEvent_Wait(event: *mut LightEvent);
}
extern "C" {
    pub fn LightSemaphore_Init(semaphore: *mut LightSemaphore, initial_count: s16, max_count: s16);
}
extern "C" {
    pub fn LightSemaphore_Acquire(semaphore: *mut LightSemaphore, count: s32);
}
extern "C" {
    pub fn LightSemaphore_Release(semaphore: *mut LightSemaphore, count: s32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Thread_tag {
    _unused: [u8; 0],
}
pub type Thread = *mut Thread_tag;
pub type ExceptionHandler = ::core::option::Option<
    unsafe extern "C" fn(excep: *mut ERRF_ExceptionInfo, regs: *mut CpuRegisters),
>;
extern "C" {
    pub fn threadCreate(
        entrypoint: ThreadFunc,
        arg: *mut ::libc::c_void,
        stack_size: usize,
        prio: ::libc::c_int,
        affinity: ::libc::c_int,
        detached: bool,
    ) -> Thread;
}
extern "C" {
    pub fn threadGetHandle(thread: Thread) -> Handle;
}
extern "C" {
    pub fn threadGetExitCode(thread: Thread) -> ::libc::c_int;
}
extern "C" {
    pub fn threadFree(thread: Thread);
}
extern "C" {
    pub fn threadJoin(thread: Thread, timeout_ns: u64) -> Result;
}
extern "C" {
    pub fn threadDetach(thread: Thread);
}
extern "C" {
    pub fn threadGetCurrent() -> Thread;
}
extern "C" {
    pub fn threadExit(rc: ::libc::c_int);
}
#[repr(C)]
pub struct GSPGPU_FramebufferInfo {
    pub active_framebuf: u32,
    pub framebuf0_vaddr: *mut u32,
    pub framebuf1_vaddr: *mut u32,
    pub framebuf_widthbytesize: u32,
    pub format: u32,
    pub framebuf_dispselect: u32,
    pub unk: u32,
}
pub const GSP_RGBA8_OES: GSPGPU_FramebufferFormats = 0;
pub const GSP_BGR8_OES: GSPGPU_FramebufferFormats = 1;
pub const GSP_RGB565_OES: GSPGPU_FramebufferFormats = 2;
pub const GSP_RGB5_A1_OES: GSPGPU_FramebufferFormats = 3;
pub const GSP_RGBA4_OES: GSPGPU_FramebufferFormats = 4;
pub type GSPGPU_FramebufferFormats = u32;
#[repr(C)]
pub struct GSPGPU_CaptureInfoEntry {
    pub framebuf0_vaddr: *mut u32,
    pub framebuf1_vaddr: *mut u32,
    pub format: u32,
    pub framebuf_widthbytesize: u32,
}
#[repr(C)]
pub struct GSPGPU_CaptureInfo {
    pub screencapture: [GSPGPU_CaptureInfoEntry; 2usize],
}
pub const GSPGPU_EVENT_PSC0: GSPGPU_Event = 0;
pub const GSPGPU_EVENT_PSC1: GSPGPU_Event = 1;
pub const GSPGPU_EVENT_VBlank0: GSPGPU_Event = 2;
pub const GSPGPU_EVENT_VBlank1: GSPGPU_Event = 3;
pub const GSPGPU_EVENT_PPF: GSPGPU_Event = 4;
pub const GSPGPU_EVENT_P3D: GSPGPU_Event = 5;
pub const GSPGPU_EVENT_DMA: GSPGPU_Event = 6;
pub const GSPGPU_EVENT_MAX: GSPGPU_Event = 7;
pub type GSPGPU_Event = u32;
extern "C" {
    pub fn gspInit() -> Result;
}
extern "C" {
    pub fn gspExit();
}
extern "C" {
    pub fn gspSetEventCallback(
        id: GSPGPU_Event,
        cb: ThreadFunc,
        data: *mut ::libc::c_void,
        oneShot: bool,
    );
}
extern "C" {
    pub fn gspInitEventHandler(gspEvent: Handle, gspSharedMem: *mut vu8, gspThreadId: u8)
        -> Result;
}
extern "C" {
    pub fn gspExitEventHandler();
}
extern "C" {
    pub fn gspWaitForEvent(id: GSPGPU_Event, nextEvent: bool);
}
extern "C" {
    pub fn gspWaitForAnyEvent() -> GSPGPU_Event;
}
extern "C" {
    pub fn gspSubmitGxCommand(sharedGspCmdBuf: *mut u32, gxCommand: *mut u32) -> Result;
}
extern "C" {
    pub fn GSPGPU_AcquireRight(flags: u8) -> Result;
}
extern "C" {
    pub fn GSPGPU_ReleaseRight() -> Result;
}
extern "C" {
    pub fn GSPGPU_ImportDisplayCaptureInfo(captureinfo: *mut GSPGPU_CaptureInfo) -> Result;
}
extern "C" {
    pub fn GSPGPU_SaveVramSysArea() -> Result;
}
extern "C" {
    pub fn GSPGPU_RestoreVramSysArea() -> Result;
}
extern "C" {
    pub fn GSPGPU_SetLcdForceBlack(flags: u8) -> Result;
}
extern "C" {
    pub fn GSPGPU_SetBufferSwap(screenid: u32, framebufinfo: *mut GSPGPU_FramebufferInfo)
        -> Result;
}
extern "C" {
    pub fn GSPGPU_FlushDataCache(adr: *const ::libc::c_void, size: u32) -> Result;
}
extern "C" {
    pub fn GSPGPU_InvalidateDataCache(adr: *const ::libc::c_void, size: u32) -> Result;
}
extern "C" {
    pub fn GSPGPU_WriteHWRegs(regAddr: u32, data: *mut u32, size: u8) -> Result;
}
extern "C" {
    pub fn GSPGPU_WriteHWRegsWithMask(
        regAddr: u32,
        data: *mut u32,
        datasize: u8,
        maskdata: *mut u32,
        masksize: u8,
    ) -> Result;
}
extern "C" {
    pub fn GSPGPU_ReadHWRegs(regAddr: u32, data: *mut u32, size: u8) -> Result;
}
extern "C" {
    pub fn GSPGPU_RegisterInterruptRelayQueue(
        eventHandle: Handle,
        flags: u32,
        outMemHandle: *mut Handle,
        threadID: *mut u8,
    ) -> Result;
}
extern "C" {
    pub fn GSPGPU_UnregisterInterruptRelayQueue() -> Result;
}
extern "C" {
    pub fn GSPGPU_TriggerCmdReqQueue() -> Result;
}
extern "C" {
    pub fn GSPGPU_SetLedForceOff(disable: bool) -> Result;
}
pub const GFX_TOP: gfxScreen_t = 0;
pub const GFX_BOTTOM: gfxScreen_t = 1;
pub type gfxScreen_t = u32;
pub const GFX_LEFT: gfx3dSide_t = 0;
pub const GFX_RIGHT: gfx3dSide_t = 1;
pub type gfx3dSide_t = u32;
extern "C" {
    pub fn gfxInitDefault();
}
extern "C" {
    pub fn gfxInit(
        topFormat: GSPGPU_FramebufferFormats,
        bottomFormat: GSPGPU_FramebufferFormats,
        vrambuffers: bool,
    );
}
extern "C" {
    pub fn gfxExit();
}
extern "C" {
    pub fn gfxSet3D(enable: bool);
}
extern "C" {
    pub fn gfxIs3D() -> bool;
}
extern "C" {
    pub fn gfxSetScreenFormat(screen: gfxScreen_t, format: GSPGPU_FramebufferFormats);
}
extern "C" {
    pub fn gfxGetScreenFormat(screen: gfxScreen_t) -> GSPGPU_FramebufferFormats;
}
extern "C" {
    pub fn gfxSetDoubleBuffering(screen: gfxScreen_t, doubleBuffering: bool);
}
extern "C" {
    pub fn gfxFlushBuffers();
}
extern "C" {
    pub fn gfxConfigScreen(scr: gfxScreen_t, immediate: bool);
}
extern "C" {
    pub fn gfxSwapBuffers();
}
extern "C" {
    pub fn gfxSwapBuffersGpu();
}
extern "C" {
    pub fn gfxGetFramebuffer(
        screen: gfxScreen_t,
        side: gfx3dSide_t,
        width: *mut u16,
        height: *mut u16,
    ) -> *mut u8;
}
extern "C" {
    pub static mut gfxTopLeftFramebuffers: [*mut u8; 2usize];
}
extern "C" {
    pub static mut gfxTopRightFramebuffers: [*mut u8; 2usize];
}
extern "C" {
    pub static mut gfxBottomFramebuffers: [*mut u8; 2usize];
}
pub type ConsolePrint = ::core::option::Option<
    unsafe extern "C" fn(con: *mut ::libc::c_void, c: ::libc::c_int) -> bool,
>;
#[repr(C)]
pub struct ConsoleFont {
    pub gfx: *mut u8,
    pub asciiOffset: u16,
    pub numChars: u16,
}
#[repr(C)]
pub struct PrintConsole {
    pub font: ConsoleFont,
    pub frameBuffer: *mut u16,
    pub cursorX: ::libc::c_int,
    pub cursorY: ::libc::c_int,
    pub prevCursorX: ::libc::c_int,
    pub prevCursorY: ::libc::c_int,
    pub consoleWidth: ::libc::c_int,
    pub consoleHeight: ::libc::c_int,
    pub windowX: ::libc::c_int,
    pub windowY: ::libc::c_int,
    pub windowWidth: ::libc::c_int,
    pub windowHeight: ::libc::c_int,
    pub tabSize: ::libc::c_int,
    pub fg: ::libc::c_int,
    pub bg: ::libc::c_int,
    pub flags: ::libc::c_int,
    pub PrintChar: ConsolePrint,
    pub consoleInitialised: bool,
}
pub const debugDevice_NULL: debugDevice = 0;
pub const debugDevice_SVC: debugDevice = 1;
pub const debugDevice_CONSOLE: debugDevice = 2;
pub const debugDevice_3DMOO: debugDevice = 1;
pub type debugDevice = u32;
extern "C" {
    pub fn consoleSetFont(console: *mut PrintConsole, font: *mut ConsoleFont);
}
extern "C" {
    pub fn consoleSetWindow(
        console: *mut PrintConsole,
        x: ::libc::c_int,
        y: ::libc::c_int,
        width: ::libc::c_int,
        height: ::libc::c_int,
    );
}
extern "C" {
    pub fn consoleGetDefault() -> *mut PrintConsole;
}
extern "C" {
    pub fn consoleSelect(console: *mut PrintConsole) -> *mut PrintConsole;
}
extern "C" {
    pub fn consoleInit(screen: gfxScreen_t, console: *mut PrintConsole) -> *mut PrintConsole;
}
extern "C" {
    pub fn consoleDebugInit(device: debugDevice);
}
extern "C" {
    pub fn consoleClear();
}
pub const RUNFLAG_APTWORKAROUND: _bindgen_ty_7 = 1;
pub const RUNFLAG_APTREINIT: _bindgen_ty_7 = 2;
pub const RUNFLAG_APTCHAINLOAD: _bindgen_ty_7 = 4;
pub type _bindgen_ty_7 = u32;
extern "C" {
    pub fn envGetHandle(name: *const ::libc::c_char) -> Handle;
}
pub type _off_t = __int64_t;
pub type _fpos_t = __int64_t;
pub type __ino_t = __uint32_t;
pub type __dev_t = __uint32_t;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::libc::c_int;
pub type __blkcnt_t = ::libc::c_long;
pub type __blksize_t = ::libc::c_long;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint32_t;
pub type __pid_t = ::libc::c_int;
pub type __uid_t = ::libc::c_ushort;
pub type __gid_t = ::libc::c_ushort;
pub type __id_t = __uint32_t;
pub type __mode_t = __uint32_t;
pub type _off64_t = ::libc::c_longlong;
pub type __off_t = _off_t;
pub type __loff_t = _off64_t;
pub type __key_t = ::libc::c_long;
pub type __size_t = ::libc::c_uint;
pub type _ssize_t = ::libc::c_int;
pub type __ssize_t = _ssize_t;
pub type wint_t = ::libc::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mbstate_t {
    pub __count: ::libc::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _mbstate_t__bindgen_ty_1 {
    pub __wch: wint_t,
    pub __wchb: [::libc::c_uchar; 4usize],
    _bindgen_union_align: u32,
}
pub type _flock_t = _LOCK_RECURSIVE_T;
pub type _iconv_t = *mut ::libc::c_void;
pub type __clock_t = ::libc::c_ulong;
pub type __time_t = __int_least64_t;
pub type __clockid_t = ::libc::c_ulong;
pub type __timer_t = ::libc::c_ulong;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __nlink_t = ::libc::c_ushort;
pub type __suseconds_t = ::libc::c_long;
pub type __useconds_t = ::libc::c_ulong;
pub type __sigset_t = ::libc::c_ulong;
pub type suseconds_t = __suseconds_t;
pub type time_t = __int_least64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::libc::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
pub type sigset_t = __sigset_t;
pub type fd_mask = ::libc::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _types_fd_set {
    pub fds_bits: [fd_mask; 2usize],
}
extern "C" {
    pub fn select(
        __n: ::libc::c_int,
        __readfds: *mut _types_fd_set,
        __writefds: *mut _types_fd_set,
        __exceptfds: *mut _types_fd_set,
        __timeout: *mut timeval,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pselect(
        __n: ::libc::c_int,
        __readfds: *mut _types_fd_set,
        __writefds: *mut _types_fd_set,
        __exceptfds: *mut _types_fd_set,
        __timeout: *const timespec,
        __set: *const sigset_t,
    ) -> ::libc::c_int;
}
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type u_char = ::libc::c_uchar;
pub type u_short = ::libc::c_ushort;
pub type u_int = ::libc::c_uint;
pub type u_long = ::libc::c_ulong;
pub type ushort = ::libc::c_ushort;
pub type uint = ::libc::c_uint;
pub type ulong = ::libc::c_ulong;
pub type blkcnt_t = __blkcnt_t;
pub type blksize_t = __blksize_t;
pub type clock_t = ::libc::c_ulong;
pub type daddr_t = ::libc::c_long;
pub type caddr_t = *mut ::libc::c_char;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type id_t = __id_t;
pub type ino_t = __ino_t;
pub type off_t = __off_t;
pub type dev_t = __dev_t;
pub type uid_t = __uid_t;
pub type gid_t = __gid_t;
pub type pid_t = __pid_t;
pub type key_t = __key_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type useconds_t = __useconds_t;
pub type sbintime_t = __int64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::libc::c_int,
}
pub type pthread_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_attr_t {
    pub is_initialized: ::libc::c_int,
    pub stackaddr: *mut ::libc::c_void,
    pub stacksize: ::libc::c_int,
    pub contentionscope: ::libc::c_int,
    pub inheritsched: ::libc::c_int,
    pub schedpolicy: ::libc::c_int,
    pub schedparam: sched_param,
    pub detachstate: ::libc::c_int,
}
pub type pthread_mutex_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutexattr_t {
    pub is_initialized: ::libc::c_int,
    pub recursive: ::libc::c_int,
}
pub type pthread_cond_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_condattr_t {
    pub is_initialized: ::libc::c_int,
    pub clock: clock_t,
}
pub type pthread_key_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_once_t {
    pub is_initialized: ::libc::c_int,
    pub init_executed: ::libc::c_int,
}
pub const DECOMPRESS_DUMMY: decompressType = 0;
pub const DECOMPRESS_LZSS: decompressType = 16;
pub const DECOMPRESS_LZ10: decompressType = 16;
pub const DECOMPRESS_LZ11: decompressType = 17;
pub const DECOMPRESS_HUFF1: decompressType = 33;
pub const DECOMPRESS_HUFF2: decompressType = 34;
pub const DECOMPRESS_HUFF3: decompressType = 35;
pub const DECOMPRESS_HUFF4: decompressType = 36;
pub const DECOMPRESS_HUFF5: decompressType = 37;
pub const DECOMPRESS_HUFF6: decompressType = 38;
pub const DECOMPRESS_HUFF7: decompressType = 39;
pub const DECOMPRESS_HUFF8: decompressType = 40;
pub const DECOMPRESS_HUFF: decompressType = 40;
pub const DECOMPRESS_RLE: decompressType = 48;
pub type decompressType = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct decompressIOVec {
    pub data: *mut ::libc::c_void,
    pub size: usize,
}
pub type decompressCallback = ::core::option::Option<
    unsafe extern "C" fn(userdata: *mut ::libc::c_void, buffer: *mut ::libc::c_void, size: usize)
        -> isize,
>;
extern "C" {
    pub fn decompressCallback_FD(
        userdata: *mut ::libc::c_void,
        buffer: *mut ::libc::c_void,
        size: usize,
    ) -> isize;
}
extern "C" {
    pub fn decompressCallback_Stdio(
        userdata: *mut ::libc::c_void,
        buffer: *mut ::libc::c_void,
        size: usize,
    ) -> isize;
}
extern "C" {
    pub fn decompressHeader(
        type_: *mut decompressType,
        size: *mut usize,
        callback: decompressCallback,
        userdata: *mut ::libc::c_void,
        insize: usize,
    ) -> isize;
}
extern "C" {
    pub fn decompressV(
        iov: *const decompressIOVec,
        iovcnt: usize,
        callback: decompressCallback,
        userdata: *mut ::libc::c_void,
        insize: usize,
    ) -> bool;
}
extern "C" {
    pub fn decompressV_LZSS(
        iov: *const decompressIOVec,
        iovcnt: usize,
        callback: decompressCallback,
        userdata: *mut ::libc::c_void,
        insize: usize,
    ) -> bool;
}
extern "C" {
    pub fn decompressV_LZ11(
        iov: *const decompressIOVec,
        iovcnt: usize,
        callback: decompressCallback,
        userdata: *mut ::libc::c_void,
        insize: usize,
    ) -> bool;
}
extern "C" {
    pub fn decompressV_Huff(
        bits: usize,
        iov: *const decompressIOVec,
        iovcnt: usize,
        callback: decompressCallback,
        userdata: *mut ::libc::c_void,
        insize: usize,
    ) -> bool;
}
extern "C" {
    pub fn decompressV_RLE(
        iov: *const decompressIOVec,
        iovcnt: usize,
        callback: decompressCallback,
        userdata: *mut ::libc::c_void,
        insize: usize,
    ) -> bool;
}
extern "C" {
    pub fn decode_utf8(out: *mut u32, in_: *const u8) -> isize;
}
extern "C" {
    pub fn decode_utf16(out: *mut u32, in_: *const u16) -> isize;
}
extern "C" {
    pub fn encode_utf8(out: *mut u8, in_: u32) -> isize;
}
extern "C" {
    pub fn encode_utf16(out: *mut u16, in_: u32) -> isize;
}
extern "C" {
    pub fn utf8_to_utf16(out: *mut u16, in_: *const u8, len: usize) -> isize;
}
extern "C" {
    pub fn utf8_to_utf32(out: *mut u32, in_: *const u8, len: usize) -> isize;
}
extern "C" {
    pub fn utf16_to_utf8(out: *mut u8, in_: *const u16, len: usize) -> isize;
}
extern "C" {
    pub fn utf16_to_utf32(out: *mut u32, in_: *const u16, len: usize) -> isize;
}
extern "C" {
    pub fn utf32_to_utf8(out: *mut u8, in_: *const u32, len: usize) -> isize;
}
extern "C" {
    pub fn utf32_to_utf16(out: *mut u16, in_: *const u32, len: usize) -> isize;
}
extern "C" {
    pub fn linearAlloc(size: usize) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn linearMemAlign(size: usize, alignment: usize) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn linearRealloc(mem: *mut ::libc::c_void, size: usize) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn linearGetSize(mem: *mut ::libc::c_void) -> usize;
}
extern "C" {
    pub fn linearFree(mem: *mut ::libc::c_void);
}
extern "C" {
    pub fn linearSpaceFree() -> u32;
}
extern "C" {
    pub fn mappableAlloc(size: usize) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn mappableGetSize(mem: *mut ::libc::c_void) -> usize;
}
extern "C" {
    pub fn mappableFree(mem: *mut ::libc::c_void);
}
extern "C" {
    pub fn mappableSpaceFree() -> u32;
}
extern "C" {
    pub fn vramAlloc(size: usize) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn vramMemAlign(size: usize, alignment: usize) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn vramRealloc(mem: *mut ::libc::c_void, size: usize) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn vramGetSize(mem: *mut ::libc::c_void) -> usize;
}
extern "C" {
    pub fn vramFree(mem: *mut ::libc::c_void);
}
extern "C" {
    pub fn vramSpaceFree() -> u32;
}
pub const AC_OPEN: acSecurityMode = 0;
pub const AC_WEP_40BIT: acSecurityMode = 1;
pub const AC_WEP_104BIT: acSecurityMode = 2;
pub const AC_WEP_128BIT: acSecurityMode = 3;
pub const AC_WPA_TKIP: acSecurityMode = 4;
pub const AC_WPA2_TKIP: acSecurityMode = 5;
pub const AC_WPA_AES: acSecurityMode = 6;
pub const AC_WPA2_AES: acSecurityMode = 7;
pub type acSecurityMode = u32;
extern "C" {
    pub fn acInit() -> Result;
}
extern "C" {
    pub fn acExit();
}
extern "C" {
    pub fn acWaitInternetConnection() -> Result;
}
extern "C" {
    pub fn ACU_GetWifiStatus(out: *mut u32) -> Result;
}
extern "C" {
    pub fn ACU_GetStatus(out: *mut u32) -> Result;
}
extern "C" {
    pub fn ACU_GetSecurityMode(mode: *mut acSecurityMode) -> Result;
}
extern "C" {
    pub fn ACU_GetSSID(SSID: *mut ::libc::c_char) -> Result;
}
extern "C" {
    pub fn ACU_GetSSIDLength(out: *mut u32) -> Result;
}
extern "C" {
    pub fn ACU_GetProxyEnable(enable: *mut bool) -> Result;
}
extern "C" {
    pub fn ACU_GetProxyPort(out: *mut u32) -> Result;
}
extern "C" {
    pub fn ACU_GetProxyUserName(username: *mut ::libc::c_char) -> Result;
}
extern "C" {
    pub fn ACU_GetProxyPassword(password: *mut ::libc::c_char) -> Result;
}
extern "C" {
    pub fn ACU_GetLastErrorCode(errorCode: *mut u32) -> Result;
}
extern "C" {
    pub fn ACU_GetLastDetailErrorCode(errorCode: *mut u32) -> Result;
}
pub const FS_OPEN_READ: _bindgen_ty_8 = 1;
pub const FS_OPEN_WRITE: _bindgen_ty_8 = 2;
pub const FS_OPEN_CREATE: _bindgen_ty_8 = 4;
pub type _bindgen_ty_8 = u32;
pub const FS_WRITE_FLUSH: _bindgen_ty_9 = 1;
pub const FS_WRITE_UPDATE_TIME: _bindgen_ty_9 = 256;
pub type _bindgen_ty_9 = u32;
pub const FS_ATTRIBUTE_DIRECTORY: _bindgen_ty_10 = 1;
pub const FS_ATTRIBUTE_HIDDEN: _bindgen_ty_10 = 256;
pub const FS_ATTRIBUTE_ARCHIVE: _bindgen_ty_10 = 65536;
pub const FS_ATTRIBUTE_READ_ONLY: _bindgen_ty_10 = 16777216;
pub type _bindgen_ty_10 = u32;
pub const MEDIATYPE_NAND: FS_MediaType = 0;
pub const MEDIATYPE_SD: FS_MediaType = 1;
pub const MEDIATYPE_GAME_CARD: FS_MediaType = 2;
pub type FS_MediaType = u32;
pub const SYSTEM_MEDIATYPE_CTR_NAND: FS_SystemMediaType = 0;
pub const SYSTEM_MEDIATYPE_TWL_NAND: FS_SystemMediaType = 1;
pub const SYSTEM_MEDIATYPE_SD: FS_SystemMediaType = 2;
pub const SYSTEM_MEDIATYPE_TWL_PHOTO: FS_SystemMediaType = 3;
pub type FS_SystemMediaType = u32;
pub const ARCHIVE_ROMFS: FS_ArchiveID = 3;
pub const ARCHIVE_SAVEDATA: FS_ArchiveID = 4;
pub const ARCHIVE_EXTDATA: FS_ArchiveID = 6;
pub const ARCHIVE_SHARED_EXTDATA: FS_ArchiveID = 7;
pub const ARCHIVE_SYSTEM_SAVEDATA: FS_ArchiveID = 8;
pub const ARCHIVE_SDMC: FS_ArchiveID = 9;
pub const ARCHIVE_SDMC_WRITE_ONLY: FS_ArchiveID = 10;
pub const ARCHIVE_BOSS_EXTDATA: FS_ArchiveID = 305419896;
pub const ARCHIVE_CARD_SPIFS: FS_ArchiveID = 305419897;
pub const ARCHIVE_EXTDATA_AND_BOSS_EXTDATA: FS_ArchiveID = 305419899;
pub const ARCHIVE_SYSTEM_SAVEDATA2: FS_ArchiveID = 305419900;
pub const ARCHIVE_NAND_RW: FS_ArchiveID = 305419901;
pub const ARCHIVE_NAND_RO: FS_ArchiveID = 305419902;
pub const ARCHIVE_NAND_RO_WRITE_ACCESS: FS_ArchiveID = 305419903;
pub const ARCHIVE_SAVEDATA_AND_CONTENT: FS_ArchiveID = 591751050;
pub const ARCHIVE_SAVEDATA_AND_CONTENT2: FS_ArchiveID = 591751054;
pub const ARCHIVE_NAND_CTR_FS: FS_ArchiveID = 1450741931;
pub const ARCHIVE_TWL_PHOTO: FS_ArchiveID = 1450741932;
pub const ARCHIVE_TWL_SOUND: FS_ArchiveID = 1450741933;
pub const ARCHIVE_NAND_TWL_FS: FS_ArchiveID = 1450741934;
pub const ARCHIVE_NAND_W_FS: FS_ArchiveID = 1450741935;
pub const ARCHIVE_GAMECARD_SAVEDATA: FS_ArchiveID = 1450741937;
pub const ARCHIVE_USER_SAVEDATA: FS_ArchiveID = 1450741938;
pub const ARCHIVE_DEMO_SAVEDATA: FS_ArchiveID = 1450741940;
pub type FS_ArchiveID = u32;
pub const PATH_INVALID: FS_PathType = 0;
pub const PATH_EMPTY: FS_PathType = 1;
pub const PATH_BINARY: FS_PathType = 2;
pub const PATH_ASCII: FS_PathType = 3;
pub const PATH_UTF16: FS_PathType = 4;
pub type FS_PathType = u32;
pub const SECUREVALUE_SLOT_SD: FS_SecureValueSlot = 4096;
pub type FS_SecureValueSlot = u32;
pub const BAUDRATE_512KHZ: FS_CardSpiBaudRate = 0;
pub const BAUDRATE_1MHZ: FS_CardSpiBaudRate = 1;
pub const BAUDRATE_2MHZ: FS_CardSpiBaudRate = 2;
pub const BAUDRATE_4MHZ: FS_CardSpiBaudRate = 3;
pub const BAUDRATE_8MHZ: FS_CardSpiBaudRate = 4;
pub const BAUDRATE_16MHZ: FS_CardSpiBaudRate = 5;
pub type FS_CardSpiBaudRate = u32;
pub const BUSMODE_1BIT: FS_CardSpiBusMode = 0;
pub const BUSMODE_4BIT: FS_CardSpiBusMode = 1;
pub type FS_CardSpiBusMode = u32;
pub const SPECIALCONTENT_UPDATE: FS_SpecialContentType = 1;
pub const SPECIALCONTENT_MANUAL: FS_SpecialContentType = 2;
pub const SPECIALCONTENT_DLP_CHILD: FS_SpecialContentType = 3;
pub type FS_SpecialContentType = u32;
pub const CARD_CTR: FS_CardType = 0;
pub const CARD_TWL: FS_CardType = 1;
pub type FS_CardType = u32;
pub const FS_ACTION_UNKNOWN: FS_Action = 0;
pub type FS_Action = u32;
pub const ARCHIVE_ACTION_COMMIT_SAVE_DATA: FS_ArchiveAction = 0;
pub const ARCHIVE_ACTION_GET_TIMESTAMP: FS_ArchiveAction = 1;
pub type FS_ArchiveAction = u32;
pub const SECURESAVE_ACTION_DELETE: FS_SecureSaveAction = 0;
pub const SECURESAVE_ACTION_FORMAT: FS_SecureSaveAction = 1;
pub type FS_SecureSaveAction = u32;
pub const FILE_ACTION_UNKNOWN: FS_FileAction = 0;
pub type FS_FileAction = u32;
pub const DIRECTORY_ACTION_UNKNOWN: FS_DirectoryAction = 0;
pub type FS_DirectoryAction = u32;
#[repr(C)]
pub struct FS_DirectoryEntry {
    pub name: [u16; 262usize],
    pub shortName: [::libc::c_char; 10usize],
    pub shortExt: [::libc::c_char; 4usize],
    pub valid: u8,
    pub reserved: u8,
    pub attributes: u32,
    pub fileSize: u64,
}
#[repr(C)]
pub struct FS_ArchiveResource {
    pub sectorSize: u32,
    pub clusterSize: u32,
    pub totalClusters: u32,
    pub freeClusters: u32,
}
#[repr(C)]
pub struct FS_ProgramInfo {
    pub programId: u64,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub padding: [u8; 7usize],
}
impl FS_ProgramInfo {
    #[inline]
    pub fn mediaType(&self) -> FS_MediaType {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_mediaType(&mut self, val: FS_MediaType) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(mediaType: FS_MediaType) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let mediaType: u32 = unsafe { ::core::mem::transmute(mediaType) };
            mediaType as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct FS_ProductInfo {
    pub productCode: [::libc::c_char; 16usize],
    pub companyCode: [::libc::c_char; 2usize],
    pub remasterVersion: u16,
}
#[repr(C)]
pub struct FS_IntegrityVerificationSeed {
    pub aesCbcMac: [u8; 16usize],
    pub movableSed: [u8; 288usize],
}
#[repr(C, packed)]
pub struct FS_ExtSaveDataInfo {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub unknown: u8,
    pub reserved1: u16,
    pub saveId: u64,
    pub reserved2: u32,
}
impl FS_ExtSaveDataInfo {
    #[inline]
    pub fn mediaType(&self) -> FS_MediaType {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_mediaType(&mut self, val: FS_MediaType) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(mediaType: FS_MediaType) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let mediaType: u32 = unsafe { ::core::mem::transmute(mediaType) };
            mediaType as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct FS_SystemSaveDataInfo {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub unknown: u8,
    pub reserved: u16,
    pub saveId: u32,
}
impl FS_SystemSaveDataInfo {
    #[inline]
    pub fn mediaType(&self) -> FS_MediaType {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_mediaType(&mut self, val: FS_MediaType) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(mediaType: FS_MediaType) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let mediaType: u32 = unsafe { ::core::mem::transmute(mediaType) };
            mediaType as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct FS_DeviceMoveContext {
    pub ivs: [u8; 16usize],
    pub encryptParameter: [u8; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FS_Path {
    pub type_: FS_PathType,
    pub size: u32,
    pub data: *const ::libc::c_void,
}
pub type FS_Archive = u64;
extern "C" {
    pub fn fsInit() -> Result;
}
extern "C" {
    pub fn fsExit();
}
extern "C" {
    pub fn fsUseSession(session: Handle);
}
extern "C" {
    pub fn fsEndUseSession();
}
extern "C" {
    pub fn fsExemptFromSession(archive: FS_Archive);
}
extern "C" {
    pub fn fsUnexemptFromSession(archive: FS_Archive);
}
extern "C" {
    pub fn fsMakePath(type_: FS_PathType, path: *const ::libc::c_void) -> FS_Path;
}
extern "C" {
    pub fn fsGetSessionHandle() -> *mut Handle;
}
extern "C" {
    pub fn FSUSER_Control(
        action: FS_Action,
        input: *mut ::libc::c_void,
        inputSize: u32,
        output: *mut ::libc::c_void,
        outputSize: u32,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_Initialize(session: Handle) -> Result;
}
extern "C" {
    pub fn FSUSER_OpenFile(
        out: *mut Handle,
        archive: FS_Archive,
        path: FS_Path,
        openFlags: u32,
        attributes: u32,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_OpenFileDirectly(
        out: *mut Handle,
        archiveId: FS_ArchiveID,
        archivePath: FS_Path,
        filePath: FS_Path,
        openFlags: u32,
        attributes: u32,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_DeleteFile(archive: FS_Archive, path: FS_Path) -> Result;
}
extern "C" {
    pub fn FSUSER_RenameFile(
        srcArchive: FS_Archive,
        srcPath: FS_Path,
        dstArchive: FS_Archive,
        dstPath: FS_Path,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_DeleteDirectory(archive: FS_Archive, path: FS_Path) -> Result;
}
extern "C" {
    pub fn FSUSER_DeleteDirectoryRecursively(archive: FS_Archive, path: FS_Path) -> Result;
}
extern "C" {
    pub fn FSUSER_CreateFile(
        archive: FS_Archive,
        path: FS_Path,
        attributes: u32,
        fileSize: u64,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_CreateDirectory(archive: FS_Archive, path: FS_Path, attributes: u32) -> Result;
}
extern "C" {
    pub fn FSUSER_RenameDirectory(
        srcArchive: FS_Archive,
        srcPath: FS_Path,
        dstArchive: FS_Archive,
        dstPath: FS_Path,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_OpenDirectory(out: *mut Handle, archive: FS_Archive, path: FS_Path) -> Result;
}
extern "C" {
    pub fn FSUSER_OpenArchive(archive: *mut FS_Archive, id: FS_ArchiveID, path: FS_Path) -> Result;
}
extern "C" {
    pub fn FSUSER_ControlArchive(
        archive: FS_Archive,
        action: FS_ArchiveAction,
        input: *mut ::libc::c_void,
        inputSize: u32,
        output: *mut ::libc::c_void,
        outputSize: u32,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_CloseArchive(archive: FS_Archive) -> Result;
}
extern "C" {
    pub fn FSUSER_GetFreeBytes(freeBytes: *mut u64, archive: FS_Archive) -> Result;
}
extern "C" {
    pub fn FSUSER_GetCardType(type_: *mut FS_CardType) -> Result;
}
extern "C" {
    pub fn FSUSER_GetSdmcArchiveResource(archiveResource: *mut FS_ArchiveResource) -> Result;
}
extern "C" {
    pub fn FSUSER_GetNandArchiveResource(archiveResource: *mut FS_ArchiveResource) -> Result;
}
extern "C" {
    pub fn FSUSER_GetSdmcFatfsError(error: *mut u32) -> Result;
}
extern "C" {
    pub fn FSUSER_IsSdmcDetected(detected: *mut bool) -> Result;
}
extern "C" {
    pub fn FSUSER_IsSdmcWritable(writable: *mut bool) -> Result;
}
extern "C" {
    pub fn FSUSER_GetSdmcCid(out: *mut u8, length: u32) -> Result;
}
extern "C" {
    pub fn FSUSER_GetNandCid(out: *mut u8, length: u32) -> Result;
}
extern "C" {
    pub fn FSUSER_GetSdmcSpeedInfo(speedInfo: *mut u32) -> Result;
}
extern "C" {
    pub fn FSUSER_GetNandSpeedInfo(speedInfo: *mut u32) -> Result;
}
extern "C" {
    pub fn FSUSER_GetSdmcLog(out: *mut u8, length: u32) -> Result;
}
extern "C" {
    pub fn FSUSER_GetNandLog(out: *mut u8, length: u32) -> Result;
}
extern "C" {
    pub fn FSUSER_ClearSdmcLog() -> Result;
}
extern "C" {
    pub fn FSUSER_ClearNandLog() -> Result;
}
extern "C" {
    pub fn FSUSER_CardSlotIsInserted(inserted: *mut bool) -> Result;
}
extern "C" {
    pub fn FSUSER_CardSlotPowerOn(status: *mut bool) -> Result;
}
extern "C" {
    pub fn FSUSER_CardSlotPowerOff(status: *mut bool) -> Result;
}
extern "C" {
    pub fn FSUSER_CardSlotGetCardIFPowerStatus(status: *mut bool) -> Result;
}
extern "C" {
    pub fn FSUSER_CardNorDirectCommand(commandId: u8) -> Result;
}
extern "C" {
    pub fn FSUSER_CardNorDirectCommandWithAddress(commandId: u8, address: u32) -> Result;
}
extern "C" {
    pub fn FSUSER_CardNorDirectRead(commandId: u8, size: u32, output: *mut u8) -> Result;
}
extern "C" {
    pub fn FSUSER_CardNorDirectReadWithAddress(
        commandId: u8,
        address: u32,
        size: u32,
        output: *mut u8,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_CardNorDirectWrite(commandId: u8, size: u32, input: *mut u8) -> Result;
}
extern "C" {
    pub fn FSUSER_CardNorDirectWriteWithAddress(
        commandId: u8,
        address: u32,
        size: u32,
        input: *mut u8,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_CardNorDirectRead_4xIO(
        commandId: u8,
        address: u32,
        size: u32,
        output: *mut u8,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_CardNorDirectCpuWriteWithoutVerify(
        address: u32,
        size: u32,
        input: *mut u8,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_CardNorDirectSectorEraseWithoutVerify(address: u32) -> Result;
}
extern "C" {
    pub fn FSUSER_GetProductInfo(info: *mut FS_ProductInfo, processId: u32) -> Result;
}
extern "C" {
    pub fn FSUSER_GetProgramLaunchInfo(info: *mut FS_ProgramInfo, processId: u32) -> Result;
}
extern "C" {
    pub fn FSUSER_SetCardSpiBaudRate(baudRate: FS_CardSpiBaudRate) -> Result;
}
extern "C" {
    pub fn FSUSER_SetCardSpiBusMode(busMode: FS_CardSpiBusMode) -> Result;
}
extern "C" {
    pub fn FSUSER_SendInitializeInfoTo9() -> Result;
}
extern "C" {
    pub fn FSUSER_GetSpecialContentIndex(
        index: *mut u16,
        mediaType: FS_MediaType,
        programId: u64,
        type_: FS_SpecialContentType,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_GetLegacyRomHeader(
        mediaType: FS_MediaType,
        programId: u64,
        header: *mut u8,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_GetLegacyBannerData(
        mediaType: FS_MediaType,
        programId: u64,
        banner: *mut u8,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_CheckAuthorityToAccessExtSaveData(
        access: *mut bool,
        mediaType: FS_MediaType,
        saveId: u64,
        processId: u32,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_QueryTotalQuotaSize(
        quotaSize: *mut u64,
        directories: u32,
        files: u32,
        fileSizeCount: u32,
        fileSizes: *mut u64,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_AbnegateAccessRight(accessRight: u32) -> Result;
}
extern "C" {
    pub fn FSUSER_DeleteSdmcRoot() -> Result;
}
extern "C" {
    pub fn FSUSER_DeleteAllExtSaveDataOnNand() -> Result;
}
extern "C" {
    pub fn FSUSER_InitializeCtrFileSystem() -> Result;
}
extern "C" {
    pub fn FSUSER_CreateSeed() -> Result;
}
extern "C" {
    pub fn FSUSER_GetFormatInfo(
        totalSize: *mut u32,
        directories: *mut u32,
        files: *mut u32,
        duplicateData: *mut bool,
        archiveId: FS_ArchiveID,
        path: FS_Path,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_GetLegacyRomHeader2(
        headerSize: u32,
        mediaType: FS_MediaType,
        programId: u64,
        header: *mut u8,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_GetSdmcCtrRootPath(out: *mut u8, length: u32) -> Result;
}
extern "C" {
    pub fn FSUSER_GetArchiveResource(
        archiveResource: *mut FS_ArchiveResource,
        mediaType: FS_SystemMediaType,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_ExportIntegrityVerificationSeed(
        seed: *mut FS_IntegrityVerificationSeed,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_ImportIntegrityVerificationSeed(
        seed: *mut FS_IntegrityVerificationSeed,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_FormatSaveData(
        archiveId: FS_ArchiveID,
        path: FS_Path,
        blocks: u32,
        directories: u32,
        files: u32,
        directoryBuckets: u32,
        fileBuckets: u32,
        duplicateData: bool,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_GetLegacySubBannerData(
        bannerSize: u32,
        mediaType: FS_MediaType,
        programId: u64,
        banner: *mut u8,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_UpdateSha256Context(
        data: *const ::libc::c_void,
        inputSize: u32,
        hash: *mut u8,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_ReadSpecialFile(
        bytesRead: *mut u32,
        fileOffset: u64,
        size: u32,
        data: *mut u8,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_GetSpecialFileSize(fileSize: *mut u64) -> Result;
}
extern "C" {
    pub fn FSUSER_CreateExtSaveData(
        info: FS_ExtSaveDataInfo,
        directories: u32,
        files: u32,
        sizeLimit: u64,
        smdhSize: u32,
        smdh: *mut u8,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_DeleteExtSaveData(info: FS_ExtSaveDataInfo) -> Result;
}
extern "C" {
    pub fn FSUSER_ReadExtSaveDataIcon(
        bytesRead: *mut u32,
        info: FS_ExtSaveDataInfo,
        smdhSize: u32,
        smdh: *mut u8,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_GetExtDataBlockSize(
        totalBlocks: *mut u64,
        freeBlocks: *mut u64,
        blockSize: *mut u32,
        info: FS_ExtSaveDataInfo,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_EnumerateExtSaveData(
        idsWritten: *mut u32,
        idsSize: u32,
        mediaType: FS_MediaType,
        idSize: u32,
        shared: bool,
        ids: *mut u8,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_CreateSystemSaveData(
        info: FS_SystemSaveDataInfo,
        totalSize: u32,
        blockSize: u32,
        directories: u32,
        files: u32,
        directoryBuckets: u32,
        fileBuckets: u32,
        duplicateData: bool,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_DeleteSystemSaveData(info: FS_SystemSaveDataInfo) -> Result;
}
extern "C" {
    pub fn FSUSER_StartDeviceMoveAsSource(context: *mut FS_DeviceMoveContext) -> Result;
}
extern "C" {
    pub fn FSUSER_StartDeviceMoveAsDestination(
        context: FS_DeviceMoveContext,
        clear: bool,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_SetArchivePriority(archive: FS_Archive, priority: u32) -> Result;
}
extern "C" {
    pub fn FSUSER_GetArchivePriority(priority: *mut u32, archive: FS_Archive) -> Result;
}
extern "C" {
    pub fn FSUSER_SetCtrCardLatencyParameter(latency: u64, emulateEndurance: bool) -> Result;
}
extern "C" {
    pub fn FSUSER_SwitchCleanupInvalidSaveData(enable: bool) -> Result;
}
extern "C" {
    pub fn FSUSER_EnumerateSystemSaveData(
        idsWritten: *mut u32,
        idsSize: u32,
        ids: *mut u32,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_InitializeWithSdkVersion(session: Handle, version: u32) -> Result;
}
extern "C" {
    pub fn FSUSER_SetPriority(priority: u32) -> Result;
}
extern "C" {
    pub fn FSUSER_GetPriority(priority: *mut u32) -> Result;
}
extern "C" {
    pub fn FSUSER_SetSaveDataSecureValue(
        value: u64,
        slot: FS_SecureValueSlot,
        titleUniqueId: u32,
        titleVariation: u8,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_GetSaveDataSecureValue(
        exists: *mut bool,
        value: *mut u64,
        slot: FS_SecureValueSlot,
        titleUniqueId: u32,
        titleVariation: u8,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_ControlSecureSave(
        action: FS_SecureSaveAction,
        input: *mut ::libc::c_void,
        inputSize: u32,
        output: *mut ::libc::c_void,
        outputSize: u32,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_GetMediaType(mediaType: *mut FS_MediaType) -> Result;
}
extern "C" {
    pub fn FSFILE_Control(
        handle: Handle,
        action: FS_FileAction,
        input: *mut ::libc::c_void,
        inputSize: u32,
        output: *mut ::libc::c_void,
        outputSize: u32,
    ) -> Result;
}
extern "C" {
    pub fn FSFILE_OpenSubFile(
        handle: Handle,
        subFile: *mut Handle,
        offset: u64,
        size: u64,
    ) -> Result;
}
extern "C" {
    pub fn FSFILE_Read(
        handle: Handle,
        bytesRead: *mut u32,
        offset: u64,
        buffer: *mut ::libc::c_void,
        size: u32,
    ) -> Result;
}
extern "C" {
    pub fn FSFILE_Write(
        handle: Handle,
        bytesWritten: *mut u32,
        offset: u64,
        buffer: *const ::libc::c_void,
        size: u32,
        flags: u32,
    ) -> Result;
}
extern "C" {
    pub fn FSFILE_GetSize(handle: Handle, size: *mut u64) -> Result;
}
extern "C" {
    pub fn FSFILE_SetSize(handle: Handle, size: u64) -> Result;
}
extern "C" {
    pub fn FSFILE_GetAttributes(handle: Handle, attributes: *mut u32) -> Result;
}
extern "C" {
    pub fn FSFILE_SetAttributes(handle: Handle, attributes: u32) -> Result;
}
extern "C" {
    pub fn FSFILE_Close(handle: Handle) -> Result;
}
extern "C" {
    pub fn FSFILE_Flush(handle: Handle) -> Result;
}
extern "C" {
    pub fn FSFILE_SetPriority(handle: Handle, priority: u32) -> Result;
}
extern "C" {
    pub fn FSFILE_GetPriority(handle: Handle, priority: *mut u32) -> Result;
}
extern "C" {
    pub fn FSFILE_OpenLinkFile(handle: Handle, linkFile: *mut Handle) -> Result;
}
extern "C" {
    pub fn FSDIR_Control(
        handle: Handle,
        action: FS_DirectoryAction,
        input: *mut ::libc::c_void,
        inputSize: u32,
        output: *mut ::libc::c_void,
        outputSize: u32,
    ) -> Result;
}
extern "C" {
    pub fn FSDIR_Read(
        handle: Handle,
        entriesRead: *mut u32,
        entryCount: u32,
        entries: *mut FS_DirectoryEntry,
    ) -> Result;
}
extern "C" {
    pub fn FSDIR_Close(handle: Handle) -> Result;
}
extern "C" {
    pub fn FSDIR_SetPriority(handle: Handle, priority: u32) -> Result;
}
extern "C" {
    pub fn FSDIR_GetPriority(handle: Handle, priority: *mut u32) -> Result;
}
#[repr(C)]
pub struct AM_TitleEntry {
    pub titleID: u64,
    pub size: u64,
    pub version: u16,
    pub unk: [u8; 6usize],
}
pub const AM_STATUS_MASK_INSTALLING: _bindgen_ty_11 = 1;
pub const AM_STATUS_MASK_AWAITING_FINALIZATION: _bindgen_ty_11 = 2;
pub type _bindgen_ty_11 = u32;
pub const AM_STATUS_ABORTED: AM_InstallStatus = 2;
pub const AM_STATUS_SAVED: AM_InstallStatus = 3;
pub const AM_STATUS_INSTALL_IN_PROGRESS: AM_InstallStatus = 2050;
pub const AM_STATUS_AWAITING_FINALIZATION: AM_InstallStatus = 2051;
pub type AM_InstallStatus = u32;
#[repr(C)]
pub struct AM_PendingTitleEntry {
    pub titleId: u64,
    pub version: u16,
    pub status: u16,
    pub titleType: u32,
    pub unk: [u8; 8usize],
}
pub const AM_DELETE_PENDING_NON_SYSTEM: _bindgen_ty_12 = 1;
pub const AM_DELETE_PENDING_SYSTEM: _bindgen_ty_12 = 2;
pub type _bindgen_ty_12 = u32;
#[repr(C)]
pub struct AM_TWLPartitionInfo {
    pub capacity: u64,
    pub freeSpace: u64,
    pub titlesCapacity: u64,
    pub titlesFreeSpace: u64,
}
extern "C" {
    pub fn amInit() -> Result;
}
extern "C" {
    pub fn amAppInit() -> Result;
}
extern "C" {
    pub fn amExit();
}
extern "C" {
    pub fn amGetSessionHandle() -> *mut Handle;
}
extern "C" {
    pub fn AM_GetTitleCount(mediatype: FS_MediaType, count: *mut u32) -> Result;
}
extern "C" {
    pub fn AM_GetTitleList(
        titlesRead: *mut u32,
        mediatype: FS_MediaType,
        titleCount: u32,
        titleIds: *mut u64,
    ) -> Result;
}
extern "C" {
    pub fn AM_GetTitleInfo(
        mediatype: FS_MediaType,
        titleCount: u32,
        titleIds: *mut u64,
        titleInfo: *mut AM_TitleEntry,
    ) -> Result;
}
extern "C" {
    pub fn AM_GetTicketCount(count: *mut u32) -> Result;
}
extern "C" {
    pub fn AM_GetTicketList(
        ticketsRead: *mut u32,
        ticketCount: u32,
        skip: u32,
        ticketIds: *mut u64,
    ) -> Result;
}
extern "C" {
    pub fn AM_GetPendingTitleCount(
        count: *mut u32,
        mediatype: FS_MediaType,
        statusMask: u32,
    ) -> Result;
}
extern "C" {
    pub fn AM_GetPendingTitleList(
        titlesRead: *mut u32,
        titleCount: u32,
        mediatype: FS_MediaType,
        statusMask: u32,
        titleIds: *mut u64,
    ) -> Result;
}
extern "C" {
    pub fn AM_GetPendingTitleInfo(
        titleCount: u32,
        mediatype: FS_MediaType,
        titleIds: *mut u64,
        titleInfo: *mut AM_PendingTitleEntry,
    ) -> Result;
}
extern "C" {
    pub fn AM_GetDeviceId(deviceID: *mut u32) -> Result;
}
extern "C" {
    pub fn AM_ExportTwlBackup(
        titleID: u64,
        operation: u8,
        workbuf: *mut ::libc::c_void,
        workbuf_size: u32,
        filepath: *const ::libc::c_char,
    ) -> Result;
}
extern "C" {
    pub fn AM_ImportTwlBackup(
        filehandle: Handle,
        operation: u8,
        buffer: *mut ::libc::c_void,
        size: u32,
    ) -> Result;
}
extern "C" {
    pub fn AM_ReadTwlBackupInfo(
        filehandle: Handle,
        outinfo: *mut ::libc::c_void,
        outinfo_size: u32,
        workbuf: *mut ::libc::c_void,
        workbuf_size: u32,
        banner: *mut ::libc::c_void,
        banner_size: u32,
    ) -> Result;
}
extern "C" {
    pub fn AM_GetTWLPartitionInfo(info: *mut AM_TWLPartitionInfo) -> Result;
}
extern "C" {
    pub fn AM_StartCiaInstall(mediatype: FS_MediaType, ciaHandle: *mut Handle) -> Result;
}
extern "C" {
    pub fn AM_StartDlpChildCiaInstall(ciaHandle: *mut Handle) -> Result;
}
extern "C" {
    pub fn AM_CancelCIAInstall(ciaHandle: Handle) -> Result;
}
extern "C" {
    pub fn AM_FinishCiaInstall(ciaHandle: Handle) -> Result;
}
extern "C" {
    pub fn AM_FinishCiaInstallWithoutCommit(ciaHandle: Handle) -> Result;
}
extern "C" {
    pub fn AM_CommitImportPrograms(
        mediaType: FS_MediaType,
        titleCount: u32,
        temp: bool,
        titleIds: *const u64,
    ) -> Result;
}
extern "C" {
    pub fn AM_DeleteTitle(mediatype: FS_MediaType, titleID: u64) -> Result;
}
extern "C" {
    pub fn AM_DeleteAppTitle(mediatype: FS_MediaType, titleID: u64) -> Result;
}
extern "C" {
    pub fn AM_DeleteTicket(ticketId: u64) -> Result;
}
extern "C" {
    pub fn AM_DeletePendingTitle(mediatype: FS_MediaType, titleId: u64) -> Result;
}
extern "C" {
    pub fn AM_DeletePendingTitles(mediatype: FS_MediaType, flags: u32) -> Result;
}
extern "C" {
    pub fn AM_DeleteAllPendingTitles(mediatype: FS_MediaType) -> Result;
}
extern "C" {
    pub fn AM_InstallNativeFirm() -> Result;
}
extern "C" {
    pub fn AM_InstallFirm(titleID: u64) -> Result;
}
extern "C" {
    pub fn AM_GetTitleProductCode(
        mediatype: FS_MediaType,
        titleId: u64,
        productCode: *mut ::libc::c_char,
    ) -> Result;
}
extern "C" {
    pub fn AM_GetTitleExtDataId(
        extDataId: *mut u64,
        mediatype: FS_MediaType,
        titleId: u64,
    ) -> Result;
}
extern "C" {
    pub fn AM_GetCiaFileInfo(
        mediatype: FS_MediaType,
        titleEntry: *mut AM_TitleEntry,
        fileHandle: Handle,
    ) -> Result;
}
extern "C" {
    pub fn AM_GetCiaIcon(icon: *mut ::libc::c_void, fileHandle: Handle) -> Result;
}
extern "C" {
    pub fn AM_GetCiaDependencies(dependencies: *mut u64, fileHandle: Handle) -> Result;
}
extern "C" {
    pub fn AM_GetCiaMetaOffset(metaOffset: *mut u64, fileHandle: Handle) -> Result;
}
extern "C" {
    pub fn AM_GetCiaCoreVersion(coreVersion: *mut u32, fileHandle: Handle) -> Result;
}
extern "C" {
    pub fn AM_GetCiaRequiredSpace(
        requiredSpace: *mut u64,
        mediaType: FS_MediaType,
        fileHandle: Handle,
    ) -> Result;
}
extern "C" {
    pub fn AM_GetCiaMetaSection(meta: *mut ::libc::c_void, size: u32, fileHandle: Handle)
        -> Result;
}
extern "C" {
    pub fn AM_InitializeExternalTitleDatabase(overwrite: bool) -> Result;
}
extern "C" {
    pub fn AM_QueryAvailableExternalTitleDatabase(available: *mut bool) -> Result;
}
extern "C" {
    pub fn AM_InstallTicketBegin(ticketHandle: *mut Handle) -> Result;
}
extern "C" {
    pub fn AM_InstallTicketAbort(ticketHandle: Handle) -> Result;
}
extern "C" {
    pub fn AM_InstallTicketFinish(ticketHandle: Handle) -> Result;
}
extern "C" {
    pub fn AM_InstallTitleBegin(mediaType: FS_MediaType, titleId: u64, unk: bool) -> Result;
}
extern "C" {
    pub fn AM_InstallTitleStop() -> Result;
}
extern "C" {
    pub fn AM_InstallTitleResume(mediaType: FS_MediaType, titleId: u64) -> Result;
}
extern "C" {
    pub fn AM_InstallTitleAbort() -> Result;
}
extern "C" {
    pub fn AM_InstallTitleFinish() -> Result;
}
extern "C" {
    pub fn AM_CommitImportTitles(
        mediaType: FS_MediaType,
        titleCount: u32,
        temp: bool,
        titleIds: *const u64,
    ) -> Result;
}
extern "C" {
    pub fn AM_InstallTmdBegin(tmdHandle: *mut Handle) -> Result;
}
extern "C" {
    pub fn AM_InstallTmdAbort(tmdHandle: Handle) -> Result;
}
extern "C" {
    pub fn AM_InstallTmdFinish(tmdHandle: Handle, unk: bool) -> Result;
}
extern "C" {
    pub fn AM_CreateImportContentContexts(contentCount: u32, contentIndices: *mut u16) -> Result;
}
extern "C" {
    pub fn AM_InstallContentBegin(contentHandle: *mut Handle, index: u16) -> Result;
}
extern "C" {
    pub fn AM_InstallContentStop(contentHandle: Handle) -> Result;
}
extern "C" {
    pub fn AM_InstallContentResume(
        contentHandle: *mut Handle,
        resumeOffset: *mut u64,
        index: u16,
    ) -> Result;
}
extern "C" {
    pub fn AM_InstallContentCancel(contentHandle: Handle) -> Result;
}
extern "C" {
    pub fn AM_InstallContentFinish(contentHandle: Handle) -> Result;
}
extern "C" {
    pub fn AM_ImportCertificates(
        cert1Size: u32,
        cert1: *mut ::libc::c_void,
        cert2Size: u32,
        cert2: *mut ::libc::c_void,
        cert3Size: u32,
        cert3: *mut ::libc::c_void,
        cert4Size: u32,
        cert4: *mut ::libc::c_void,
    ) -> Result;
}
extern "C" {
    pub fn AM_ImportCertificate(certSize: u32, cert: *mut ::libc::c_void) -> Result;
}
extern "C" {
    pub fn AM_CommitImportTitlesAndUpdateFirmwareAuto(
        mediaType: FS_MediaType,
        titleCount: u32,
        temp: bool,
        titleIds: *mut u64,
    ) -> Result;
}
extern "C" {
    pub fn AM_DeleteAllDemoLaunchInfos() -> Result;
}
extern "C" {
    pub fn AM_DeleteAllTemporaryTitles() -> Result;
}
extern "C" {
    pub fn AM_DeleteAllExpiredTitles(mediatype: FS_MediaType) -> Result;
}
extern "C" {
    pub fn AM_DeleteAllTwlTitles() -> Result;
}
extern "C" {
    pub fn ampxiInit(servhandle: Handle) -> Result;
}
extern "C" {
    pub fn ampxiExit();
}
extern "C" {
    pub fn AMPXI_WriteTWLSavedata(
        titleid: u64,
        buffer: *mut u8,
        size: u32,
        image_filepos: u32,
        section_type: u8,
        operation: u8,
    ) -> Result;
}
extern "C" {
    pub fn AMPXI_InstallTitlesFinish(
        mediaType: FS_MediaType,
        db: u8,
        titlecount: u32,
        tidlist: *mut u64,
    ) -> Result;
}
pub const APPID_NONE: NS_APPID = 0;
pub const APPID_HOMEMENU: NS_APPID = 257;
pub const APPID_CAMERA: NS_APPID = 272;
pub const APPID_FRIENDS_LIST: NS_APPID = 274;
pub const APPID_GAME_NOTES: NS_APPID = 275;
pub const APPID_WEB: NS_APPID = 276;
pub const APPID_INSTRUCTION_MANUAL: NS_APPID = 277;
pub const APPID_NOTIFICATIONS: NS_APPID = 278;
pub const APPID_MIIVERSE: NS_APPID = 279;
pub const APPID_MIIVERSE_POSTING: NS_APPID = 280;
pub const APPID_AMIIBO_SETTINGS: NS_APPID = 281;
pub const APPID_APPLICATION: NS_APPID = 768;
pub const APPID_ESHOP: NS_APPID = 769;
pub const APPID_SOFTWARE_KEYBOARD: NS_APPID = 1025;
pub const APPID_APPLETED: NS_APPID = 1026;
pub const APPID_PNOTE_AP: NS_APPID = 1028;
pub const APPID_SNOTE_AP: NS_APPID = 1029;
pub const APPID_ERROR: NS_APPID = 1030;
pub const APPID_MINT: NS_APPID = 1031;
pub const APPID_EXTRAPAD: NS_APPID = 1032;
pub const APPID_MEMOLIB: NS_APPID = 1033;
pub type NS_APPID = u32;
pub const APTPOS_NONE: APT_AppletPos = -1;
pub const APTPOS_APP: APT_AppletPos = 0;
pub const APTPOS_APPLIB: APT_AppletPos = 1;
pub const APTPOS_SYS: APT_AppletPos = 2;
pub const APTPOS_SYSLIB: APT_AppletPos = 3;
pub const APTPOS_RESIDENT: APT_AppletPos = 4;
pub type APT_AppletPos = i32;
pub type APT_AppletAttr = u8;
pub const APTREPLY_REJECT: APT_QueryReply = 0;
pub const APTREPLY_ACCEPT: APT_QueryReply = 1;
pub const APTREPLY_LATER: APT_QueryReply = 2;
pub type APT_QueryReply = u32;
pub const APTSIGNAL_NONE: APT_Signal = 0;
pub const APTSIGNAL_HOMEBUTTON: APT_Signal = 1;
pub const APTSIGNAL_HOMEBUTTON2: APT_Signal = 2;
pub const APTSIGNAL_SLEEP_QUERY: APT_Signal = 3;
pub const APTSIGNAL_SLEEP_CANCEL: APT_Signal = 4;
pub const APTSIGNAL_SLEEP_ENTER: APT_Signal = 5;
pub const APTSIGNAL_SLEEP_WAKEUP: APT_Signal = 6;
pub const APTSIGNAL_SHUTDOWN: APT_Signal = 7;
pub const APTSIGNAL_POWERBUTTON: APT_Signal = 8;
pub const APTSIGNAL_POWERBUTTON2: APT_Signal = 9;
pub const APTSIGNAL_TRY_SLEEP: APT_Signal = 10;
pub const APTSIGNAL_ORDERTOCLOSE: APT_Signal = 11;
pub type APT_Signal = u32;
pub const APTCMD_NONE: APT_Command = 0;
pub const APTCMD_WAKEUP: APT_Command = 1;
pub const APTCMD_REQUEST: APT_Command = 2;
pub const APTCMD_RESPONSE: APT_Command = 3;
pub const APTCMD_EXIT: APT_Command = 4;
pub const APTCMD_MESSAGE: APT_Command = 5;
pub const APTCMD_HOMEBUTTON_ONCE: APT_Command = 6;
pub const APTCMD_HOMEBUTTON_TWICE: APT_Command = 7;
pub const APTCMD_DSP_SLEEP: APT_Command = 8;
pub const APTCMD_DSP_WAKEUP: APT_Command = 9;
pub const APTCMD_WAKEUP_EXIT: APT_Command = 10;
pub const APTCMD_WAKEUP_PAUSE: APT_Command = 11;
pub const APTCMD_WAKEUP_CANCEL: APT_Command = 12;
pub const APTCMD_WAKEUP_CANCELALL: APT_Command = 13;
pub const APTCMD_WAKEUP_POWERBUTTON: APT_Command = 14;
pub const APTCMD_WAKEUP_JUMPTOHOME: APT_Command = 15;
pub const APTCMD_SYSAPPLET_REQUEST: APT_Command = 16;
pub const APTCMD_WAKEUP_LAUNCHAPP: APT_Command = 17;
pub type APT_Command = u32;
#[repr(C)]
pub struct aptCaptureBufInfo {
    pub size: u32,
    pub is3D: u32,
    pub top: aptCaptureBufInfo__bindgen_ty_1,
    pub bottom: aptCaptureBufInfo__bindgen_ty_1,
}
#[repr(C)]
pub struct aptCaptureBufInfo__bindgen_ty_1 {
    pub leftOffset: u32,
    pub rightOffset: u32,
    pub format: u32,
}
pub const APTHOOK_ONSUSPEND: APT_HookType = 0;
pub const APTHOOK_ONRESTORE: APT_HookType = 1;
pub const APTHOOK_ONSLEEP: APT_HookType = 2;
pub const APTHOOK_ONWAKEUP: APT_HookType = 3;
pub const APTHOOK_ONEXIT: APT_HookType = 4;
pub const APTHOOK_COUNT: APT_HookType = 5;
pub type APT_HookType = u32;
pub type aptHookFn =
    ::core::option::Option<unsafe extern "C" fn(hook: APT_HookType, param: *mut ::libc::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tag_aptHookCookie {
    pub next: *mut tag_aptHookCookie,
    pub callback: aptHookFn,
    pub param: *mut ::libc::c_void,
}
pub type aptHookCookie = tag_aptHookCookie;
pub type aptMessageCb = ::core::option::Option<
    unsafe extern "C" fn(
        user: *mut ::libc::c_void,
        sender: NS_APPID,
        msg: *mut ::libc::c_void,
        msgsize: usize,
    ),
>;
extern "C" {
    pub fn aptInit() -> Result;
}
extern "C" {
    pub fn aptExit();
}
extern "C" {
    pub fn aptSendCommand(aptcmdbuf: *mut u32) -> Result;
}
extern "C" {
    pub fn aptIsSleepAllowed() -> bool;
}
extern "C" {
    pub fn aptSetSleepAllowed(allowed: bool);
}
extern "C" {
    pub fn aptMainLoop() -> bool;
}
extern "C" {
    pub fn aptHook(cookie: *mut aptHookCookie, callback: aptHookFn, param: *mut ::libc::c_void);
}
extern "C" {
    pub fn aptUnhook(cookie: *mut aptHookCookie);
}
extern "C" {
    pub fn aptSetMessageCallback(callback: aptMessageCb, user: *mut ::libc::c_void);
}
extern "C" {
    pub fn aptLaunchLibraryApplet(
        appId: NS_APPID,
        buf: *mut ::libc::c_void,
        bufsize: usize,
        handle: Handle,
    ) -> bool;
}
extern "C" {
    pub fn aptSetChainloader(programID: u64, mediatype: u8);
}
extern "C" {
    pub fn APT_GetLockHandle(flags: u16, lockHandle: *mut Handle) -> Result;
}
extern "C" {
    pub fn APT_Initialize(
        appId: NS_APPID,
        attr: APT_AppletAttr,
        signalEvent: *mut Handle,
        resumeEvent: *mut Handle,
    ) -> Result;
}
extern "C" {
    pub fn APT_Finalize(appId: NS_APPID) -> Result;
}
extern "C" {
    pub fn APT_HardwareResetAsync() -> Result;
}
extern "C" {
    pub fn APT_Enable(attr: APT_AppletAttr) -> Result;
}
extern "C" {
    pub fn APT_GetAppletManInfo(
        inpos: APT_AppletPos,
        outpos: *mut APT_AppletPos,
        req_appid: *mut NS_APPID,
        menu_appid: *mut NS_APPID,
        active_appid: *mut NS_APPID,
    ) -> Result;
}
extern "C" {
    pub fn APT_GetAppletInfo(
        appID: NS_APPID,
        pProgramID: *mut u64,
        pMediaType: *mut u8,
        pRegistered: *mut bool,
        pLoadState: *mut bool,
        pAttributes: *mut APT_AppletAttr,
    ) -> Result;
}
extern "C" {
    pub fn APT_GetAppletProgramInfo(id: u32, flags: u32, titleversion: *mut u16) -> Result;
}
extern "C" {
    pub fn APT_GetProgramID(pProgramID: *mut u64) -> Result;
}
extern "C" {
    pub fn APT_PrepareToJumpToHomeMenu() -> Result;
}
extern "C" {
    pub fn APT_JumpToHomeMenu(
        param: *const ::libc::c_void,
        paramSize: usize,
        handle: Handle,
    ) -> Result;
}
extern "C" {
    pub fn APT_PrepareToJumpToApplication(exiting: bool) -> Result;
}
extern "C" {
    pub fn APT_JumpToApplication(
        param: *const ::libc::c_void,
        paramSize: usize,
        handle: Handle,
    ) -> Result;
}
extern "C" {
    pub fn APT_IsRegistered(appID: NS_APPID, out: *mut bool) -> Result;
}
extern "C" {
    pub fn APT_InquireNotification(appID: u32, signalType: *mut APT_Signal) -> Result;
}
extern "C" {
    pub fn APT_NotifyToWait(appID: NS_APPID) -> Result;
}
extern "C" {
    pub fn APT_AppletUtility(
        id: ::libc::c_int,
        out: *mut ::libc::c_void,
        outSize: usize,
        in_: *const ::libc::c_void,
        inSize: usize,
    ) -> Result;
}
extern "C" {
    pub fn APT_SleepIfShellClosed() -> Result;
}
extern "C" {
    pub fn APT_TryLockTransition(transition: u32, succeeded: *mut bool) -> Result;
}
extern "C" {
    pub fn APT_UnlockTransition(transition: u32) -> Result;
}
extern "C" {
    pub fn APT_GlanceParameter(
        appID: NS_APPID,
        buffer: *mut ::libc::c_void,
        bufferSize: usize,
        sender: *mut NS_APPID,
        command: *mut APT_Command,
        actualSize: *mut usize,
        parameter: *mut Handle,
    ) -> Result;
}
extern "C" {
    pub fn APT_ReceiveParameter(
        appID: NS_APPID,
        buffer: *mut ::libc::c_void,
        bufferSize: usize,
        sender: *mut NS_APPID,
        command: *mut APT_Command,
        actualSize: *mut usize,
        parameter: *mut Handle,
    ) -> Result;
}
extern "C" {
    pub fn APT_SendParameter(
        source: NS_APPID,
        dest: NS_APPID,
        command: APT_Command,
        buffer: *const ::libc::c_void,
        bufferSize: u32,
        parameter: Handle,
    ) -> Result;
}
extern "C" {
    pub fn APT_CancelParameter(source: NS_APPID, dest: NS_APPID, success: *mut bool) -> Result;
}
extern "C" {
    pub fn APT_SendCaptureBufferInfo(captureBuf: *const aptCaptureBufInfo) -> Result;
}
extern "C" {
    pub fn APT_ReplySleepQuery(appID: NS_APPID, reply: APT_QueryReply) -> Result;
}
extern "C" {
    pub fn APT_ReplySleepNotificationComplete(appID: NS_APPID) -> Result;
}
extern "C" {
    pub fn APT_PrepareToCloseApplication(cancelPreload: bool) -> Result;
}
extern "C" {
    pub fn APT_CloseApplication(
        param: *const ::libc::c_void,
        paramSize: usize,
        handle: Handle,
    ) -> Result;
}
extern "C" {
    pub fn APT_SetAppCpuTimeLimit(percent: u32) -> Result;
}
extern "C" {
    pub fn APT_GetAppCpuTimeLimit(percent: *mut u32) -> Result;
}
extern "C" {
    pub fn APT_CheckNew3DS(out: *mut bool) -> Result;
}
extern "C" {
    pub fn APT_PrepareToDoApplicationJump(flags: u8, programID: u64, mediatype: u8) -> Result;
}
extern "C" {
    pub fn APT_DoApplicationJump(
        param: *const ::libc::c_void,
        paramSize: usize,
        hmac: *const ::libc::c_void,
    ) -> Result;
}
extern "C" {
    pub fn APT_PrepareToStartLibraryApplet(appID: NS_APPID) -> Result;
}
extern "C" {
    pub fn APT_StartLibraryApplet(
        appID: NS_APPID,
        param: *const ::libc::c_void,
        paramSize: usize,
        handle: Handle,
    ) -> Result;
}
extern "C" {
    pub fn APT_PrepareToStartSystemApplet(appID: NS_APPID) -> Result;
}
extern "C" {
    pub fn APT_StartSystemApplet(
        appID: NS_APPID,
        param: *const ::libc::c_void,
        paramSize: usize,
        handle: Handle,
    ) -> Result;
}
extern "C" {
    pub fn APT_GetSharedFont(fontHandle: *mut Handle, mapAddr: *mut u32) -> Result;
}
extern "C" {
    pub fn APT_ReceiveDeliverArg(
        param: *const ::libc::c_void,
        paramSize: usize,
        hmac: *const ::libc::c_void,
        sender: *mut u64,
        received: *mut bool,
    ) -> Result;
}
#[repr(C)]
pub struct bossContext {
    pub property: [u32; 7usize],
    pub url: [::libc::c_char; 512usize],
    pub property_x8: u32,
    pub property_x9: u8,
    pub property_xa: [u8; 256usize],
    pub property_xb: [u8; 512usize],
    pub property_xd: [::libc::c_char; 864usize],
    pub property_xe: u32,
    pub property_xf: [u32; 3usize],
    pub property_x10: u8,
    pub property_x11: u8,
    pub property_x12: u8,
    pub property_x13: u32,
    pub property_x14: u32,
    pub property_x15: [u8; 64usize],
    pub property_x16: u32,
    pub property_x3b: u32,
    pub property_x3e: [u8; 512usize],
}
pub const BOSSTASKSTATUS_STARTED: bossTaskStatus = 2;
pub const BOSSTASKSTATUS_ERROR: bossTaskStatus = 7;
pub type bossTaskStatus = u32;
pub const bossNsDataHeaderInfoType_ContentSize: bossNsDataHeaderInfoTypes = 3;
pub type bossNsDataHeaderInfoTypes = u32;
pub const bossNsDataHeaderInfoTypeSize_ContentSize: bossNsDataHeaderInfoTypeSizes = 4;
pub type bossNsDataHeaderInfoTypeSizes = u32;
extern "C" {
    pub fn bossInit(programID: u64, force_user: bool) -> Result;
}
extern "C" {
    pub fn bossReinit(programID: u64) -> Result;
}
extern "C" {
    pub fn bossExit();
}
extern "C" {
    pub fn bossGetSessionHandle() -> Handle;
}
extern "C" {
    pub fn bossSetStorageInfo(extdataID: u64, boss_size: u32, mediaType: u8) -> Result;
}
extern "C" {
    pub fn bossUnregisterStorage() -> Result;
}
extern "C" {
    pub fn bossRegisterTask(taskID: *const ::libc::c_char, unk0: u8, unk1: u8) -> Result;
}
extern "C" {
    pub fn bossSendProperty(PropertyID: u16, buf: *const ::libc::c_void, size: u32) -> Result;
}
extern "C" {
    pub fn bossDeleteNsData(NsDataId: u32) -> Result;
}
extern "C" {
    pub fn bossGetNsDataHeaderInfo(
        NsDataId: u32,
        type_: u8,
        buffer: *mut ::libc::c_void,
        size: u32,
    ) -> Result;
}
extern "C" {
    pub fn bossReadNsData(
        NsDataId: u32,
        offset: u64,
        buffer: *mut ::libc::c_void,
        size: u32,
        transfer_total: *mut u32,
        unk_out: *mut u32,
    ) -> Result;
}
extern "C" {
    pub fn bossStartTaskImmediate(taskID: *const ::libc::c_char) -> Result;
}
extern "C" {
    pub fn bossStartBgImmediate(taskID: *const ::libc::c_char) -> Result;
}
extern "C" {
    pub fn bossDeleteTask(taskID: *const ::libc::c_char, unk: u32) -> Result;
}
extern "C" {
    pub fn bossGetTaskState(
        taskID: *const ::libc::c_char,
        inval: s8,
        status: *mut u8,
        out1: *mut u32,
        out2: *mut u8,
    ) -> Result;
}
extern "C" {
    pub fn bossGetTaskProperty0(taskID: *const ::libc::c_char, out: *mut u8) -> Result;
}
extern "C" {
    pub fn bossSetupContextDefault(
        ctx: *mut bossContext,
        seconds_interval: u32,
        url: *const ::libc::c_char,
    );
}
extern "C" {
    pub fn bossSendContextConfig(ctx: *mut bossContext) -> Result;
}
pub const INPUT_YUV422_INDIV_8: Y2RU_InputFormat = 0;
pub const INPUT_YUV420_INDIV_8: Y2RU_InputFormat = 1;
pub const INPUT_YUV422_INDIV_16: Y2RU_InputFormat = 2;
pub const INPUT_YUV420_INDIV_16: Y2RU_InputFormat = 3;
pub const INPUT_YUV422_BATCH: Y2RU_InputFormat = 4;
pub type Y2RU_InputFormat = u32;
pub const OUTPUT_RGB_32: Y2RU_OutputFormat = 0;
pub const OUTPUT_RGB_24: Y2RU_OutputFormat = 1;
pub const OUTPUT_RGB_16_555: Y2RU_OutputFormat = 2;
pub const OUTPUT_RGB_16_565: Y2RU_OutputFormat = 3;
pub type Y2RU_OutputFormat = u32;
pub const ROTATION_NONE: Y2RU_Rotation = 0;
pub const ROTATION_CLOCKWISE_90: Y2RU_Rotation = 1;
pub const ROTATION_CLOCKWISE_180: Y2RU_Rotation = 2;
pub const ROTATION_CLOCKWISE_270: Y2RU_Rotation = 3;
pub type Y2RU_Rotation = u32;
pub const BLOCK_LINE: Y2RU_BlockAlignment = 0;
pub const BLOCK_8_BY_8: Y2RU_BlockAlignment = 1;
pub type Y2RU_BlockAlignment = u32;
#[repr(C)]
pub struct Y2RU_ColorCoefficients {
    pub rgb_Y: u16,
    pub r_V: u16,
    pub g_V: u16,
    pub g_U: u16,
    pub b_U: u16,
    pub r_offset: u16,
    pub g_offset: u16,
    pub b_offset: u16,
}
pub const COEFFICIENT_ITU_R_BT_601: Y2RU_StandardCoefficient = 0;
pub const COEFFICIENT_ITU_R_BT_709: Y2RU_StandardCoefficient = 1;
pub const COEFFICIENT_ITU_R_BT_601_SCALING: Y2RU_StandardCoefficient = 2;
pub const COEFFICIENT_ITU_R_BT_709_SCALING: Y2RU_StandardCoefficient = 3;
pub type Y2RU_StandardCoefficient = u32;
#[repr(C)]
#[repr(align(4))]
pub struct Y2RU_ConversionParams {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
    pub input_line_width: s16,
    pub input_lines: s16,
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub unused: u8,
    pub alpha: u16,
    pub __bindgen_align: [u32; 0usize],
}
impl Y2RU_ConversionParams {
    #[inline]
    pub fn input_format(&self) -> Y2RU_InputFormat {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_input_format(&mut self, val: Y2RU_InputFormat) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn output_format(&self) -> Y2RU_OutputFormat {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_output_format(&mut self, val: Y2RU_OutputFormat) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn rotation(&self) -> Y2RU_Rotation {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_rotation(&mut self, val: Y2RU_Rotation) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn block_alignment(&self) -> Y2RU_BlockAlignment {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_block_alignment(&mut self, val: Y2RU_BlockAlignment) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        input_format: Y2RU_InputFormat,
        output_format: Y2RU_OutputFormat,
        rotation: Y2RU_Rotation,
        block_alignment: Y2RU_BlockAlignment,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let input_format: u32 = unsafe { ::core::mem::transmute(input_format) };
            input_format as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let output_format: u32 = unsafe { ::core::mem::transmute(output_format) };
            output_format as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let rotation: u32 = unsafe { ::core::mem::transmute(rotation) };
            rotation as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let block_alignment: u32 = unsafe { ::core::mem::transmute(block_alignment) };
            block_alignment as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn standard_coefficient(&self) -> Y2RU_StandardCoefficient {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_standard_coefficient(&mut self, val: Y2RU_StandardCoefficient) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        standard_coefficient: Y2RU_StandardCoefficient,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let standard_coefficient: u32 = unsafe { ::core::mem::transmute(standard_coefficient) };
            standard_coefficient as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct Y2RU_DitheringWeightParams {
    pub w0_xEven_yEven: u16,
    pub w0_xOdd_yEven: u16,
    pub w0_xEven_yOdd: u16,
    pub w0_xOdd_yOdd: u16,
    pub w1_xEven_yEven: u16,
    pub w1_xOdd_yEven: u16,
    pub w1_xEven_yOdd: u16,
    pub w1_xOdd_yOdd: u16,
    pub w2_xEven_yEven: u16,
    pub w2_xOdd_yEven: u16,
    pub w2_xEven_yOdd: u16,
    pub w2_xOdd_yOdd: u16,
    pub w3_xEven_yEven: u16,
    pub w3_xOdd_yEven: u16,
    pub w3_xEven_yOdd: u16,
    pub w3_xOdd_yOdd: u16,
}
extern "C" {
    pub fn y2rInit() -> Result;
}
extern "C" {
    pub fn y2rExit();
}
extern "C" {
    pub fn Y2RU_SetInputFormat(format: Y2RU_InputFormat) -> Result;
}
extern "C" {
    pub fn Y2RU_GetInputFormat(format: *mut Y2RU_InputFormat) -> Result;
}
extern "C" {
    pub fn Y2RU_SetOutputFormat(format: Y2RU_OutputFormat) -> Result;
}
extern "C" {
    pub fn Y2RU_GetOutputFormat(format: *mut Y2RU_OutputFormat) -> Result;
}
extern "C" {
    pub fn Y2RU_SetRotation(rotation: Y2RU_Rotation) -> Result;
}
extern "C" {
    pub fn Y2RU_GetRotation(rotation: *mut Y2RU_Rotation) -> Result;
}
extern "C" {
    pub fn Y2RU_SetBlockAlignment(alignment: Y2RU_BlockAlignment) -> Result;
}
extern "C" {
    pub fn Y2RU_GetBlockAlignment(alignment: *mut Y2RU_BlockAlignment) -> Result;
}
extern "C" {
    pub fn Y2RU_SetSpacialDithering(enable: bool) -> Result;
}
extern "C" {
    pub fn Y2RU_GetSpacialDithering(enabled: *mut bool) -> Result;
}
extern "C" {
    pub fn Y2RU_SetTemporalDithering(enable: bool) -> Result;
}
extern "C" {
    pub fn Y2RU_GetTemporalDithering(enabled: *mut bool) -> Result;
}
extern "C" {
    pub fn Y2RU_SetInputLineWidth(line_width: u16) -> Result;
}
extern "C" {
    pub fn Y2RU_GetInputLineWidth(line_width: *mut u16) -> Result;
}
extern "C" {
    pub fn Y2RU_SetInputLines(num_lines: u16) -> Result;
}
extern "C" {
    pub fn Y2RU_GetInputLines(num_lines: *mut u16) -> Result;
}
extern "C" {
    pub fn Y2RU_SetCoefficients(coefficients: *const Y2RU_ColorCoefficients) -> Result;
}
extern "C" {
    pub fn Y2RU_GetCoefficients(coefficients: *mut Y2RU_ColorCoefficients) -> Result;
}
extern "C" {
    pub fn Y2RU_SetStandardCoefficient(coefficient: Y2RU_StandardCoefficient) -> Result;
}
extern "C" {
    pub fn Y2RU_GetStandardCoefficient(
        coefficients: *mut Y2RU_ColorCoefficients,
        standardCoeff: Y2RU_StandardCoefficient,
    ) -> Result;
}
extern "C" {
    pub fn Y2RU_SetAlpha(alpha: u16) -> Result;
}
extern "C" {
    pub fn Y2RU_GetAlpha(alpha: *mut u16) -> Result;
}
extern "C" {
    pub fn Y2RU_SetTransferEndInterrupt(should_interrupt: bool) -> Result;
}
extern "C" {
    pub fn Y2RU_GetTransferEndInterrupt(should_interrupt: *mut bool) -> Result;
}
extern "C" {
    pub fn Y2RU_GetTransferEndEvent(end_event: *mut Handle) -> Result;
}
extern "C" {
    pub fn Y2RU_SetSendingY(
        src_buf: *const ::libc::c_void,
        image_size: u32,
        transfer_unit: s16,
        transfer_gap: s16,
    ) -> Result;
}
extern "C" {
    pub fn Y2RU_SetSendingU(
        src_buf: *const ::libc::c_void,
        image_size: u32,
        transfer_unit: s16,
        transfer_gap: s16,
    ) -> Result;
}
extern "C" {
    pub fn Y2RU_SetSendingV(
        src_buf: *const ::libc::c_void,
        image_size: u32,
        transfer_unit: s16,
        transfer_gap: s16,
    ) -> Result;
}
extern "C" {
    pub fn Y2RU_SetSendingYUYV(
        src_buf: *const ::libc::c_void,
        image_size: u32,
        transfer_unit: s16,
        transfer_gap: s16,
    ) -> Result;
}
extern "C" {
    pub fn Y2RU_SetReceiving(
        dst_buf: *mut ::libc::c_void,
        image_size: u32,
        transfer_unit: s16,
        transfer_gap: s16,
    ) -> Result;
}
extern "C" {
    pub fn Y2RU_IsDoneSendingY(is_done: *mut bool) -> Result;
}
extern "C" {
    pub fn Y2RU_IsDoneSendingU(is_done: *mut bool) -> Result;
}
extern "C" {
    pub fn Y2RU_IsDoneSendingV(is_done: *mut bool) -> Result;
}
extern "C" {
    pub fn Y2RU_IsDoneSendingYUYV(is_done: *mut bool) -> Result;
}
extern "C" {
    pub fn Y2RU_IsDoneReceiving(is_done: *mut bool) -> Result;
}
extern "C" {
    pub fn Y2RU_SetDitheringWeightParams(params: *const Y2RU_DitheringWeightParams) -> Result;
}
extern "C" {
    pub fn Y2RU_GetDitheringWeightParams(params: *mut Y2RU_DitheringWeightParams) -> Result;
}
extern "C" {
    pub fn Y2RU_SetConversionParams(params: *const Y2RU_ConversionParams) -> Result;
}
extern "C" {
    pub fn Y2RU_StartConversion() -> Result;
}
extern "C" {
    pub fn Y2RU_StopConversion() -> Result;
}
extern "C" {
    pub fn Y2RU_IsBusyConversion(is_busy: *mut bool) -> Result;
}
extern "C" {
    pub fn Y2RU_PingProcess(ping: *mut u8) -> Result;
}
extern "C" {
    pub fn Y2RU_DriverInitialize() -> Result;
}
extern "C" {
    pub fn Y2RU_DriverFinalize() -> Result;
}
pub const PORT_NONE: _bindgen_ty_13 = 0;
pub const PORT_CAM1: _bindgen_ty_13 = 1;
pub const PORT_CAM2: _bindgen_ty_13 = 2;
pub const PORT_BOTH: _bindgen_ty_13 = 3;
pub type _bindgen_ty_13 = u32;
pub const SELECT_NONE: _bindgen_ty_14 = 0;
pub const SELECT_OUT1: _bindgen_ty_14 = 1;
pub const SELECT_IN1: _bindgen_ty_14 = 2;
pub const SELECT_OUT2: _bindgen_ty_14 = 4;
pub const SELECT_IN1_OUT1: _bindgen_ty_14 = 3;
pub const SELECT_OUT1_OUT2: _bindgen_ty_14 = 5;
pub const SELECT_IN1_OUT2: _bindgen_ty_14 = 6;
pub const SELECT_ALL: _bindgen_ty_14 = 7;
pub type _bindgen_ty_14 = u32;
pub const CONTEXT_NONE: CAMU_Context = 0;
pub const CONTEXT_A: CAMU_Context = 1;
pub const CONTEXT_B: CAMU_Context = 2;
pub const CONTEXT_BOTH: CAMU_Context = 3;
pub type CAMU_Context = u32;
pub const FLIP_NONE: CAMU_Flip = 0;
pub const FLIP_HORIZONTAL: CAMU_Flip = 1;
pub const FLIP_VERTICAL: CAMU_Flip = 2;
pub const FLIP_REVERSE: CAMU_Flip = 3;
pub type CAMU_Flip = u32;
pub const SIZE_VGA: CAMU_Size = 0;
pub const SIZE_QVGA: CAMU_Size = 1;
pub const SIZE_QQVGA: CAMU_Size = 2;
pub const SIZE_CIF: CAMU_Size = 3;
pub const SIZE_QCIF: CAMU_Size = 4;
pub const SIZE_DS_LCD: CAMU_Size = 5;
pub const SIZE_DS_LCDx4: CAMU_Size = 6;
pub const SIZE_CTR_TOP_LCD: CAMU_Size = 7;
pub const SIZE_CTR_BOTTOM_LCD: CAMU_Size = 1;
pub type CAMU_Size = u32;
pub const FRAME_RATE_15: CAMU_FrameRate = 0;
pub const FRAME_RATE_15_TO_5: CAMU_FrameRate = 1;
pub const FRAME_RATE_15_TO_2: CAMU_FrameRate = 2;
pub const FRAME_RATE_10: CAMU_FrameRate = 3;
pub const FRAME_RATE_8_5: CAMU_FrameRate = 4;
pub const FRAME_RATE_5: CAMU_FrameRate = 5;
pub const FRAME_RATE_20: CAMU_FrameRate = 6;
pub const FRAME_RATE_20_TO_5: CAMU_FrameRate = 7;
pub const FRAME_RATE_30: CAMU_FrameRate = 8;
pub const FRAME_RATE_30_TO_5: CAMU_FrameRate = 9;
pub const FRAME_RATE_15_TO_10: CAMU_FrameRate = 10;
pub const FRAME_RATE_20_TO_10: CAMU_FrameRate = 11;
pub const FRAME_RATE_30_TO_10: CAMU_FrameRate = 12;
pub type CAMU_FrameRate = u32;
pub const WHITE_BALANCE_AUTO: CAMU_WhiteBalance = 0;
pub const WHITE_BALANCE_3200K: CAMU_WhiteBalance = 1;
pub const WHITE_BALANCE_4150K: CAMU_WhiteBalance = 2;
pub const WHITE_BALANCE_5200K: CAMU_WhiteBalance = 3;
pub const WHITE_BALANCE_6000K: CAMU_WhiteBalance = 4;
pub const WHITE_BALANCE_7000K: CAMU_WhiteBalance = 5;
pub const WHITE_BALANCE_NORMAL: CAMU_WhiteBalance = 0;
pub const WHITE_BALANCE_TUNGSTEN: CAMU_WhiteBalance = 1;
pub const WHITE_BALANCE_WHITE_FLUORESCENT_LIGHT: CAMU_WhiteBalance = 2;
pub const WHITE_BALANCE_DAYLIGHT: CAMU_WhiteBalance = 3;
pub const WHITE_BALANCE_CLOUDY: CAMU_WhiteBalance = 4;
pub const WHITE_BALANCE_HORIZON: CAMU_WhiteBalance = 4;
pub const WHITE_BALANCE_SHADE: CAMU_WhiteBalance = 5;
pub type CAMU_WhiteBalance = u32;
pub const PHOTO_MODE_NORMAL: CAMU_PhotoMode = 0;
pub const PHOTO_MODE_PORTRAIT: CAMU_PhotoMode = 1;
pub const PHOTO_MODE_LANDSCAPE: CAMU_PhotoMode = 2;
pub const PHOTO_MODE_NIGHTVIEW: CAMU_PhotoMode = 3;
pub const PHOTO_MODE_LETTER: CAMU_PhotoMode = 4;
pub type CAMU_PhotoMode = u32;
pub const EFFECT_NONE: CAMU_Effect = 0;
pub const EFFECT_MONO: CAMU_Effect = 1;
pub const EFFECT_SEPIA: CAMU_Effect = 2;
pub const EFFECT_NEGATIVE: CAMU_Effect = 3;
pub const EFFECT_NEGAFILM: CAMU_Effect = 4;
pub const EFFECT_SEPIA01: CAMU_Effect = 5;
pub type CAMU_Effect = u32;
pub const CONTRAST_PATTERN_01: CAMU_Contrast = 0;
pub const CONTRAST_PATTERN_02: CAMU_Contrast = 1;
pub const CONTRAST_PATTERN_03: CAMU_Contrast = 2;
pub const CONTRAST_PATTERN_04: CAMU_Contrast = 3;
pub const CONTRAST_PATTERN_05: CAMU_Contrast = 4;
pub const CONTRAST_PATTERN_06: CAMU_Contrast = 5;
pub const CONTRAST_PATTERN_07: CAMU_Contrast = 6;
pub const CONTRAST_PATTERN_08: CAMU_Contrast = 7;
pub const CONTRAST_PATTERN_09: CAMU_Contrast = 8;
pub const CONTRAST_PATTERN_10: CAMU_Contrast = 9;
pub const CONTRAST_PATTERN_11: CAMU_Contrast = 10;
pub const CONTRAST_LOW: CAMU_Contrast = 4;
pub const CONTRAST_NORMAL: CAMU_Contrast = 5;
pub const CONTRAST_HIGH: CAMU_Contrast = 6;
pub type CAMU_Contrast = u32;
pub const LENS_CORRECTION_OFF: CAMU_LensCorrection = 0;
pub const LENS_CORRECTION_ON_70: CAMU_LensCorrection = 1;
pub const LENS_CORRECTION_ON_90: CAMU_LensCorrection = 2;
pub const LENS_CORRECTION_DARK: CAMU_LensCorrection = 0;
pub const LENS_CORRECTION_NORMAL: CAMU_LensCorrection = 1;
pub const LENS_CORRECTION_BRIGHT: CAMU_LensCorrection = 2;
pub type CAMU_LensCorrection = u32;
pub const OUTPUT_YUV_422: CAMU_OutputFormat = 0;
pub const OUTPUT_RGB_565: CAMU_OutputFormat = 1;
pub type CAMU_OutputFormat = u32;
pub const SHUTTER_SOUND_TYPE_NORMAL: CAMU_ShutterSoundType = 0;
pub const SHUTTER_SOUND_TYPE_MOVIE: CAMU_ShutterSoundType = 1;
pub const SHUTTER_SOUND_TYPE_MOVIE_END: CAMU_ShutterSoundType = 2;
pub type CAMU_ShutterSoundType = u32;
#[repr(C)]
pub struct CAMU_ImageQualityCalibrationData {
    pub aeBaseTarget: s16,
    pub kRL: s16,
    pub kGL: s16,
    pub kBL: s16,
    pub ccmPosition: s16,
    pub awbCcmL9Right: u16,
    pub awbCcmL9Left: u16,
    pub awbCcmL10Right: u16,
    pub awbCcmL10Left: u16,
    pub awbX0Right: u16,
    pub awbX0Left: u16,
}
#[repr(C)]
pub struct CAMU_StereoCameraCalibrationData {
    pub isValidRotationXY: u8,
    pub padding: [u8; 3usize],
    pub scale: f32,
    pub rotationZ: f32,
    pub translationX: f32,
    pub translationY: f32,
    pub rotationX: f32,
    pub rotationY: f32,
    pub angleOfViewRight: f32,
    pub angleOfViewLeft: f32,
    pub distanceToChart: f32,
    pub distanceCameras: f32,
    pub imageWidth: s16,
    pub imageHeight: s16,
    pub reserved: [u8; 16usize],
}
#[repr(C)]
pub struct CAMU_PackageParameterCameraSelect {
    pub camera: u8,
    pub exposure: s8,
    pub whiteBalance: u8,
    pub sharpness: s8,
    pub autoExposureOn: u8,
    pub autoWhiteBalanceOn: u8,
    pub frameRate: u8,
    pub photoMode: u8,
    pub contrast: u8,
    pub lensCorrection: u8,
    pub noiseFilterOn: u8,
    pub padding: u8,
    pub autoExposureWindowX: s16,
    pub autoExposureWindowY: s16,
    pub autoExposureWindowWidth: s16,
    pub autoExposureWindowHeight: s16,
    pub autoWhiteBalanceWindowX: s16,
    pub autoWhiteBalanceWindowY: s16,
    pub autoWhiteBalanceWindowWidth: s16,
    pub autoWhiteBalanceWindowHeight: s16,
}
#[repr(C)]
pub struct CAMU_PackageParameterContext {
    pub camera: u8,
    pub context: u8,
    pub flip: u8,
    pub effect: u8,
    pub size: u8,
}
#[repr(C)]
pub struct CAMU_PackageParameterContextDetail {
    pub camera: u8,
    pub context: u8,
    pub flip: u8,
    pub effect: u8,
    pub width: s16,
    pub height: s16,
    pub cropX0: s16,
    pub cropY0: s16,
    pub cropX1: s16,
    pub cropY1: s16,
}
extern "C" {
    pub fn camInit() -> Result;
}
extern "C" {
    pub fn camExit();
}
extern "C" {
    pub fn CAMU_StartCapture(port: u32) -> Result;
}
extern "C" {
    pub fn CAMU_StopCapture(port: u32) -> Result;
}
extern "C" {
    pub fn CAMU_IsBusy(busy: *mut bool, port: u32) -> Result;
}
extern "C" {
    pub fn CAMU_ClearBuffer(port: u32) -> Result;
}
extern "C" {
    pub fn CAMU_GetVsyncInterruptEvent(event: *mut Handle, port: u32) -> Result;
}
extern "C" {
    pub fn CAMU_GetBufferErrorInterruptEvent(event: *mut Handle, port: u32) -> Result;
}
extern "C" {
    pub fn CAMU_SetReceiving(
        event: *mut Handle,
        dst: *mut ::libc::c_void,
        port: u32,
        imageSize: u32,
        transferUnit: s16,
    ) -> Result;
}
extern "C" {
    pub fn CAMU_IsFinishedReceiving(finishedReceiving: *mut bool, port: u32) -> Result;
}
extern "C" {
    pub fn CAMU_SetTransferLines(port: u32, lines: s16, width: s16, height: s16) -> Result;
}
extern "C" {
    pub fn CAMU_GetMaxLines(maxLines: *mut s16, width: s16, height: s16) -> Result;
}
extern "C" {
    pub fn CAMU_SetTransferBytes(port: u32, bytes: u32, width: s16, height: s16) -> Result;
}
extern "C" {
    pub fn CAMU_GetTransferBytes(transferBytes: *mut u32, port: u32) -> Result;
}
extern "C" {
    pub fn CAMU_GetMaxBytes(maxBytes: *mut u32, width: s16, height: s16) -> Result;
}
extern "C" {
    pub fn CAMU_SetTrimming(port: u32, trimming: bool) -> Result;
}
extern "C" {
    pub fn CAMU_IsTrimming(trimming: *mut bool, port: u32) -> Result;
}
extern "C" {
    pub fn CAMU_SetTrimmingParams(
        port: u32,
        xStart: s16,
        yStart: s16,
        xEnd: s16,
        yEnd: s16,
    ) -> Result;
}
extern "C" {
    pub fn CAMU_GetTrimmingParams(
        xStart: *mut s16,
        yStart: *mut s16,
        xEnd: *mut s16,
        yEnd: *mut s16,
        port: u32,
    ) -> Result;
}
extern "C" {
    pub fn CAMU_SetTrimmingParamsCenter(
        port: u32,
        trimWidth: s16,
        trimHeight: s16,
        camWidth: s16,
        camHeight: s16,
    ) -> Result;
}
extern "C" {
    pub fn CAMU_Activate(select: u32) -> Result;
}
extern "C" {
    pub fn CAMU_SwitchContext(select: u32, context: CAMU_Context) -> Result;
}
extern "C" {
    pub fn CAMU_SetExposure(select: u32, exposure: s8) -> Result;
}
extern "C" {
    pub fn CAMU_SetWhiteBalance(select: u32, whiteBalance: CAMU_WhiteBalance) -> Result;
}
extern "C" {
    pub fn CAMU_SetWhiteBalanceWithoutBaseUp(
        select: u32,
        whiteBalance: CAMU_WhiteBalance,
    ) -> Result;
}
extern "C" {
    pub fn CAMU_SetSharpness(select: u32, sharpness: s8) -> Result;
}
extern "C" {
    pub fn CAMU_SetAutoExposure(select: u32, autoExposure: bool) -> Result;
}
extern "C" {
    pub fn CAMU_IsAutoExposure(autoExposure: *mut bool, select: u32) -> Result;
}
extern "C" {
    pub fn CAMU_SetAutoWhiteBalance(select: u32, autoWhiteBalance: bool) -> Result;
}
extern "C" {
    pub fn CAMU_IsAutoWhiteBalance(autoWhiteBalance: *mut bool, select: u32) -> Result;
}
extern "C" {
    pub fn CAMU_FlipImage(select: u32, flip: CAMU_Flip, context: CAMU_Context) -> Result;
}
extern "C" {
    pub fn CAMU_SetDetailSize(
        select: u32,
        width: s16,
        height: s16,
        cropX0: s16,
        cropY0: s16,
        cropX1: s16,
        cropY1: s16,
        context: CAMU_Context,
    ) -> Result;
}
extern "C" {
    pub fn CAMU_SetSize(select: u32, size: CAMU_Size, context: CAMU_Context) -> Result;
}
extern "C" {
    pub fn CAMU_SetFrameRate(select: u32, frameRate: CAMU_FrameRate) -> Result;
}
extern "C" {
    pub fn CAMU_SetPhotoMode(select: u32, photoMode: CAMU_PhotoMode) -> Result;
}
extern "C" {
    pub fn CAMU_SetEffect(select: u32, effect: CAMU_Effect, context: CAMU_Context) -> Result;
}
extern "C" {
    pub fn CAMU_SetContrast(select: u32, contrast: CAMU_Contrast) -> Result;
}
extern "C" {
    pub fn CAMU_SetLensCorrection(select: u32, lensCorrection: CAMU_LensCorrection) -> Result;
}
extern "C" {
    pub fn CAMU_SetOutputFormat(
        select: u32,
        format: CAMU_OutputFormat,
        context: CAMU_Context,
    ) -> Result;
}
extern "C" {
    pub fn CAMU_SetAutoExposureWindow(
        select: u32,
        x: s16,
        y: s16,
        width: s16,
        height: s16,
    ) -> Result;
}
extern "C" {
    pub fn CAMU_SetAutoWhiteBalanceWindow(
        select: u32,
        x: s16,
        y: s16,
        width: s16,
        height: s16,
    ) -> Result;
}
extern "C" {
    pub fn CAMU_SetNoiseFilter(select: u32, noiseFilter: bool) -> Result;
}
extern "C" {
    pub fn CAMU_SynchronizeVsyncTiming(select1: u32, select2: u32) -> Result;
}
extern "C" {
    pub fn CAMU_GetLatestVsyncTiming(timing: *mut s64, port: u32, past: u32) -> Result;
}
extern "C" {
    pub fn CAMU_GetStereoCameraCalibrationData(
        data: *mut CAMU_StereoCameraCalibrationData,
    ) -> Result;
}
extern "C" {
    pub fn CAMU_SetStereoCameraCalibrationData(data: CAMU_StereoCameraCalibrationData) -> Result;
}
extern "C" {
    pub fn CAMU_WriteRegisterI2c(select: u32, addr: u16, data: u16) -> Result;
}
extern "C" {
    pub fn CAMU_WriteMcuVariableI2c(select: u32, addr: u16, data: u16) -> Result;
}
extern "C" {
    pub fn CAMU_ReadRegisterI2cExclusive(data: *mut u16, select: u32, addr: u16) -> Result;
}
extern "C" {
    pub fn CAMU_ReadMcuVariableI2cExclusive(data: *mut u16, select: u32, addr: u16) -> Result;
}
extern "C" {
    pub fn CAMU_SetImageQualityCalibrationData(data: CAMU_ImageQualityCalibrationData) -> Result;
}
extern "C" {
    pub fn CAMU_GetImageQualityCalibrationData(
        data: *mut CAMU_ImageQualityCalibrationData,
    ) -> Result;
}
extern "C" {
    pub fn CAMU_SetPackageParameterWithoutContext(
        param: CAMU_PackageParameterCameraSelect,
    ) -> Result;
}
extern "C" {
    pub fn CAMU_SetPackageParameterWithContext(param: CAMU_PackageParameterContext) -> Result;
}
extern "C" {
    pub fn CAMU_SetPackageParameterWithContextDetail(
        param: CAMU_PackageParameterContextDetail,
    ) -> Result;
}
extern "C" {
    pub fn CAMU_GetSuitableY2rStandardCoefficient(
        coefficient: *mut Y2RU_StandardCoefficient,
    ) -> Result;
}
extern "C" {
    pub fn CAMU_PlayShutterSound(sound: CAMU_ShutterSoundType) -> Result;
}
extern "C" {
    pub fn CAMU_DriverInitialize() -> Result;
}
extern "C" {
    pub fn CAMU_DriverFinalize() -> Result;
}
extern "C" {
    pub fn CAMU_GetActivatedCamera(select: *mut u32) -> Result;
}
extern "C" {
    pub fn CAMU_GetSleepCamera(select: *mut u32) -> Result;
}
extern "C" {
    pub fn CAMU_SetSleepCamera(select: u32) -> Result;
}
extern "C" {
    pub fn CAMU_SetBrightnessSynchronization(brightnessSynchronization: bool) -> Result;
}
extern "C" {
    pub fn cfgnorInit(value: u8) -> Result;
}
extern "C" {
    pub fn cfgnorExit();
}
extern "C" {
    pub fn cfgnorDumpFlash(buf: *mut u32, size: u32) -> Result;
}
extern "C" {
    pub fn cfgnorWriteFlash(buf: *mut u32, size: u32) -> Result;
}
extern "C" {
    pub fn CFGNOR_Initialize(value: u8) -> Result;
}
extern "C" {
    pub fn CFGNOR_Shutdown() -> Result;
}
extern "C" {
    pub fn CFGNOR_ReadData(offset: u32, buf: *mut u32, size: u32) -> Result;
}
extern "C" {
    pub fn CFGNOR_WriteData(offset: u32, buf: *mut u32, size: u32) -> Result;
}
pub const CFG_REGION_JPN: CFG_Region = 0;
pub const CFG_REGION_USA: CFG_Region = 1;
pub const CFG_REGION_EUR: CFG_Region = 2;
pub const CFG_REGION_AUS: CFG_Region = 3;
pub const CFG_REGION_CHN: CFG_Region = 4;
pub const CFG_REGION_KOR: CFG_Region = 5;
pub const CFG_REGION_TWN: CFG_Region = 6;
pub type CFG_Region = u32;
pub const CFG_LANGUAGE_JP: CFG_Language = 0;
pub const CFG_LANGUAGE_EN: CFG_Language = 1;
pub const CFG_LANGUAGE_FR: CFG_Language = 2;
pub const CFG_LANGUAGE_DE: CFG_Language = 3;
pub const CFG_LANGUAGE_IT: CFG_Language = 4;
pub const CFG_LANGUAGE_ES: CFG_Language = 5;
pub const CFG_LANGUAGE_ZH: CFG_Language = 6;
pub const CFG_LANGUAGE_KO: CFG_Language = 7;
pub const CFG_LANGUAGE_NL: CFG_Language = 8;
pub const CFG_LANGUAGE_PT: CFG_Language = 9;
pub const CFG_LANGUAGE_RU: CFG_Language = 10;
pub const CFG_LANGUAGE_TW: CFG_Language = 11;
pub type CFG_Language = u32;
extern "C" {
    pub fn cfguInit() -> Result;
}
extern "C" {
    pub fn cfguExit();
}
extern "C" {
    pub fn CFGU_SecureInfoGetRegion(region: *mut u8) -> Result;
}
extern "C" {
    pub fn CFGU_GenHashConsoleUnique(appIDSalt: u32, hash: *mut u64) -> Result;
}
extern "C" {
    pub fn CFGU_GetRegionCanadaUSA(value: *mut u8) -> Result;
}
extern "C" {
    pub fn CFGU_GetSystemModel(model: *mut u8) -> Result;
}
extern "C" {
    pub fn CFGU_GetModelNintendo2DS(value: *mut u8) -> Result;
}
extern "C" {
    pub fn CFGU_GetCountryCodeString(code: u16, string: *mut u16) -> Result;
}
extern "C" {
    pub fn CFGU_GetCountryCodeID(string: u16, code: *mut u16) -> Result;
}
extern "C" {
    pub fn CFGU_IsNFCSupported(isSupported: *mut bool) -> Result;
}
extern "C" {
    pub fn CFGU_GetConfigInfoBlk2(size: u32, blkID: u32, outData: *mut u8) -> Result;
}
extern "C" {
    pub fn CFG_GetConfigInfoBlk4(size: u32, blkID: u32, outData: *mut u8) -> Result;
}
extern "C" {
    pub fn CFG_GetConfigInfoBlk8(size: u32, blkID: u32, outData: *mut u8) -> Result;
}
extern "C" {
    pub fn CFG_SetConfigInfoBlk4(size: u32, blkID: u32, inData: *mut u8) -> Result;
}
extern "C" {
    pub fn CFG_SetConfigInfoBlk8(size: u32, blkID: u32, inData: *mut u8) -> Result;
}
extern "C" {
    pub fn CFG_UpdateConfigSavegame() -> Result;
}
extern "C" {
    pub fn CFGU_GetSystemLanguage(language: *mut u8) -> Result;
}
extern "C" {
    pub fn CFGI_RestoreLocalFriendCodeSeed() -> Result;
}
extern "C" {
    pub fn CFGI_RestoreSecureInfo() -> Result;
}
extern "C" {
    pub fn CFGI_DeleteConfigSavefile() -> Result;
}
extern "C" {
    pub fn CFGI_FormatConfig() -> Result;
}
extern "C" {
    pub fn CFGI_ClearParentalControls() -> Result;
}
extern "C" {
    pub fn CFGI_VerifySigLocalFriendCodeSeed() -> Result;
}
extern "C" {
    pub fn CFGI_VerifySigSecureInfo() -> Result;
}
extern "C" {
    pub fn CFGI_SecureInfoGetSerialNumber(serial: *mut u8) -> Result;
}
extern "C" {
    pub fn CFGI_GetLocalFriendCodeSeedData(data: *mut u8) -> Result;
}
extern "C" {
    pub fn CFGI_GetLocalFriendCodeSeed(seed: *mut u64) -> Result;
}
extern "C" {
    pub fn CFGI_GetSecureInfoData(data: *mut u8) -> Result;
}
extern "C" {
    pub fn CFGI_GetSecureInfoSignature(data: *mut u8) -> Result;
}
pub const CSND_ENCODING_PCM8: _bindgen_ty_15 = 0;
pub const CSND_ENCODING_PCM16: _bindgen_ty_15 = 1;
pub const CSND_ENCODING_ADPCM: _bindgen_ty_15 = 2;
pub const CSND_ENCODING_PSG: _bindgen_ty_15 = 3;
pub type _bindgen_ty_15 = u32;
pub const CSND_LOOPMODE_MANUAL: _bindgen_ty_16 = 0;
pub const CSND_LOOPMODE_NORMAL: _bindgen_ty_16 = 1;
pub const CSND_LOOPMODE_ONESHOT: _bindgen_ty_16 = 2;
pub const CSND_LOOPMODE_NORELOAD: _bindgen_ty_16 = 3;
pub type _bindgen_ty_16 = u32;
pub const SOUND_LINEAR_INTERP: _bindgen_ty_17 = 64;
pub const SOUND_REPEAT: _bindgen_ty_17 = 1024;
pub const SOUND_ONE_SHOT: _bindgen_ty_17 = 2048;
pub const SOUND_FORMAT_8BIT: _bindgen_ty_17 = 0;
pub const SOUND_FORMAT_16BIT: _bindgen_ty_17 = 4096;
pub const SOUND_FORMAT_ADPCM: _bindgen_ty_17 = 8192;
pub const SOUND_FORMAT_PSG: _bindgen_ty_17 = 12288;
pub const SOUND_ENABLE: _bindgen_ty_17 = 16384;
pub type _bindgen_ty_17 = u32;
pub const CAPTURE_REPEAT: _bindgen_ty_18 = 0;
pub const CAPTURE_ONE_SHOT: _bindgen_ty_18 = 1;
pub const CAPTURE_FORMAT_16BIT: _bindgen_ty_18 = 0;
pub const CAPTURE_FORMAT_8BIT: _bindgen_ty_18 = 2;
pub const CAPTURE_ENABLE: _bindgen_ty_18 = 32768;
pub type _bindgen_ty_18 = u32;
pub const DutyCycle_0: CSND_DutyCycle = 7;
pub const DutyCycle_12: CSND_DutyCycle = 0;
pub const DutyCycle_25: CSND_DutyCycle = 1;
pub const DutyCycle_37: CSND_DutyCycle = 2;
pub const DutyCycle_50: CSND_DutyCycle = 3;
pub const DutyCycle_62: CSND_DutyCycle = 4;
pub const DutyCycle_75: CSND_DutyCycle = 5;
pub const DutyCycle_87: CSND_DutyCycle = 6;
pub type CSND_DutyCycle = u32;
#[repr(C)]
pub struct CSND_ChnInfo {
    pub value: __BindgenUnionField<[u32; 3usize]>,
    pub __bindgen_anon_1: __BindgenUnionField<CSND_ChnInfo__bindgen_ty_1>,
    pub bindgen_union_field: [u32; 3usize],
}
#[repr(C)]
pub struct CSND_ChnInfo__bindgen_ty_1 {
    pub active: u8,
    pub _pad1: u8,
    pub _pad2: u16,
    pub adpcmSample: s16,
    pub adpcmIndex: u8,
    pub _pad3: u8,
    pub unknownZero: u32,
}
#[repr(C)]
pub struct CSND_CapInfo {
    pub value: __BindgenUnionField<[u32; 2usize]>,
    pub __bindgen_anon_1: __BindgenUnionField<CSND_CapInfo__bindgen_ty_1>,
    pub bindgen_union_field: [u32; 2usize],
}
#[repr(C)]
pub struct CSND_CapInfo__bindgen_ty_1 {
    pub active: u8,
    pub _pad1: u8,
    pub _pad2: u16,
    pub unknownZero: u32,
}
extern "C" {
    pub static mut csndSharedMem: *mut vu32;
}
extern "C" {
    pub static mut csndSharedMemSize: u32;
}
extern "C" {
    pub static mut csndChannels: u32;
}
extern "C" {
    pub fn CSND_AcquireCapUnit(capUnit: *mut u32) -> Result;
}
extern "C" {
    pub fn CSND_ReleaseCapUnit(capUnit: u32) -> Result;
}
extern "C" {
    pub fn CSND_FlushDataCache(adr: *const ::libc::c_void, size: u32) -> Result;
}
extern "C" {
    pub fn CSND_StoreDataCache(adr: *const ::libc::c_void, size: u32) -> Result;
}
extern "C" {
    pub fn CSND_InvalidateDataCache(adr: *const ::libc::c_void, size: u32) -> Result;
}
extern "C" {
    pub fn CSND_Reset() -> Result;
}
extern "C" {
    pub fn csndInit() -> Result;
}
extern "C" {
    pub fn csndExit();
}
extern "C" {
    pub fn csndAddCmd(cmdid: ::libc::c_int) -> *mut u32;
}
extern "C" {
    pub fn csndWriteCmd(cmdid: ::libc::c_int, cmdparams: *mut u8);
}
extern "C" {
    pub fn csndExecCmds(waitDone: bool) -> Result;
}
extern "C" {
    pub fn CSND_SetPlayStateR(channel: u32, value: u32);
}
extern "C" {
    pub fn CSND_SetPlayState(channel: u32, value: u32);
}
extern "C" {
    pub fn CSND_SetEncoding(channel: u32, value: u32);
}
extern "C" {
    pub fn CSND_SetBlock(channel: u32, block: ::libc::c_int, physaddr: u32, size: u32);
}
extern "C" {
    pub fn CSND_SetLooping(channel: u32, value: u32);
}
extern "C" {
    pub fn CSND_SetBit7(channel: u32, set: bool);
}
extern "C" {
    pub fn CSND_SetInterp(channel: u32, interp: bool);
}
extern "C" {
    pub fn CSND_SetDuty(channel: u32, duty: CSND_DutyCycle);
}
extern "C" {
    pub fn CSND_SetTimer(channel: u32, timer: u32);
}
extern "C" {
    pub fn CSND_SetVol(channel: u32, chnVolumes: u32, capVolumes: u32);
}
extern "C" {
    pub fn CSND_SetAdpcmState(
        channel: u32,
        block: ::libc::c_int,
        sample: ::libc::c_int,
        index: ::libc::c_int,
    );
}
extern "C" {
    pub fn CSND_SetAdpcmReload(channel: u32, reload: bool);
}
extern "C" {
    pub fn CSND_SetChnRegs(
        flags: u32,
        physaddr0: u32,
        physaddr1: u32,
        totalbytesize: u32,
        chnVolumes: u32,
        capVolumes: u32,
    );
}
extern "C" {
    pub fn CSND_SetChnRegsPSG(flags: u32, chnVolumes: u32, capVolumes: u32, duty: CSND_DutyCycle);
}
extern "C" {
    pub fn CSND_SetChnRegsNoise(flags: u32, chnVolumes: u32, capVolumes: u32);
}
extern "C" {
    pub fn CSND_CapEnable(capUnit: u32, enable: bool);
}
extern "C" {
    pub fn CSND_CapSetRepeat(capUnit: u32, repeat: bool);
}
extern "C" {
    pub fn CSND_CapSetFormat(capUnit: u32, eightbit: bool);
}
extern "C" {
    pub fn CSND_CapSetBit2(capUnit: u32, set: bool);
}
extern "C" {
    pub fn CSND_CapSetTimer(capUnit: u32, timer: u32);
}
extern "C" {
    pub fn CSND_CapSetBuffer(capUnit: u32, addr: u32, size: u32);
}
extern "C" {
    pub fn CSND_SetCapRegs(capUnit: u32, flags: u32, addr: u32, size: u32);
}
extern "C" {
    pub fn CSND_SetDspFlags(waitDone: bool) -> Result;
}
extern "C" {
    pub fn CSND_UpdateInfo(waitDone: bool) -> Result;
}
extern "C" {
    pub fn csndPlaySound(
        chn: ::libc::c_int,
        flags: u32,
        sampleRate: u32,
        vol: f32,
        pan: f32,
        data0: *mut ::libc::c_void,
        data1: *mut ::libc::c_void,
        size: u32,
    ) -> Result;
}
extern "C" {
    pub fn csndGetDspFlags(outSemFlags: *mut u32, outIrqFlags: *mut u32);
}
extern "C" {
    pub fn csndGetChnInfo(channel: u32) -> *mut CSND_ChnInfo;
}
extern "C" {
    pub fn csndGetCapInfo(capUnit: u32) -> *mut CSND_CapInfo;
}
extern "C" {
    pub fn csndGetState(channel: u32, out: *mut CSND_ChnInfo) -> Result;
}
extern "C" {
    pub fn csndIsPlaying(channel: u32, status: *mut u8) -> Result;
}
pub const DSP_INTERRUPT_PIPE: DSP_InterruptType = 2;
pub type DSP_InterruptType = u32;
pub const DSP_PIPE_INPUT: DSP_PipeDirection = 0;
pub const DSP_PIPE_OUTPUT: DSP_PipeDirection = 1;
pub type DSP_PipeDirection = u32;
extern "C" {
    pub fn dspInit() -> Result;
}
extern "C" {
    pub fn dspExit();
}
extern "C" {
    pub fn DSP_GetHeadphoneStatus(is_inserted: *mut bool) -> Result;
}
extern "C" {
    pub fn DSP_FlushDataCache(address: *const ::libc::c_void, size: u32) -> Result;
}
extern "C" {
    pub fn DSP_InvalidateDataCache(address: *const ::libc::c_void, size: u32) -> Result;
}
extern "C" {
    pub fn DSP_GetSemaphoreHandle(semaphore: *mut Handle) -> Result;
}
extern "C" {
    pub fn DSP_SetSemaphore(value: u16) -> Result;
}
extern "C" {
    pub fn DSP_SetSemaphoreMask(mask: u16) -> Result;
}
extern "C" {
    pub fn DSP_LoadComponent(
        component: *const ::libc::c_void,
        size: u32,
        prog_mask: u16,
        data_mask: u16,
        is_loaded: *mut bool,
    ) -> Result;
}
extern "C" {
    pub fn DSP_UnloadComponent() -> Result;
}
extern "C" {
    pub fn DSP_RegisterInterruptEvents(handle: Handle, interrupt: u32, channel: u32) -> Result;
}
extern "C" {
    pub fn DSP_ReadPipeIfPossible(
        channel: u32,
        peer: u32,
        buffer: *mut ::libc::c_void,
        length: u16,
        length_read: *mut u16,
    ) -> Result;
}
extern "C" {
    pub fn DSP_WriteProcessPipe(channel: u32, buffer: *const ::libc::c_void, length: u32)
        -> Result;
}
extern "C" {
    pub fn DSP_ConvertProcessAddressFromDspDram(dsp_address: u32, arm_address: *mut u32) -> Result;
}
extern "C" {
    pub fn DSP_RecvData(regNo: u16, value: *mut u16) -> Result;
}
extern "C" {
    pub fn DSP_RecvDataIsReady(regNo: u16, is_ready: *mut bool) -> Result;
}
extern "C" {
    pub fn DSP_SendData(regNo: u16, value: u16) -> Result;
}
extern "C" {
    pub fn DSP_SendDataIsEmpty(regNo: u16, is_empty: *mut bool) -> Result;
}
pub const GSPLCD_SCREEN_TOP: _bindgen_ty_19 = 1;
pub const GSPLCD_SCREEN_BOTTOM: _bindgen_ty_19 = 2;
pub const GSPLCD_SCREEN_BOTH: _bindgen_ty_19 = 3;
pub type _bindgen_ty_19 = u32;
extern "C" {
    pub fn gspLcdInit() -> Result;
}
extern "C" {
    pub fn gspLcdExit();
}
extern "C" {
    pub fn GSPLCD_PowerOnAllBacklights() -> Result;
}
extern "C" {
    pub fn GSPLCD_PowerOffAllBacklights() -> Result;
}
extern "C" {
    pub fn GSPLCD_PowerOnBacklight(screen: u32) -> Result;
}
extern "C" {
    pub fn GSPLCD_PowerOffBacklight(screen: u32) -> Result;
}
extern "C" {
    pub fn GSPLCD_SetLedForceOff(disable: bool) -> Result;
}
extern "C" {
    pub fn GSPLCD_GetVendors(vendors: *mut u8) -> Result;
}
extern "C" {
    pub fn GSPLCD_GetBrightness(screen: u32, brightness: *mut u32) -> Result;
}
extern "C" {
    pub fn GSPLCD_SetBrightness(screen: u32, brightness: u32) -> Result;
}
extern "C" {
    pub fn GSPLCD_SetBrightnessRaw(screen: u32, brightness: u32) -> Result;
}
pub const KEY_A: _bindgen_ty_20 = 1;
pub const KEY_B: _bindgen_ty_20 = 2;
pub const KEY_SELECT: _bindgen_ty_20 = 4;
pub const KEY_START: _bindgen_ty_20 = 8;
pub const KEY_DRIGHT: _bindgen_ty_20 = 16;
pub const KEY_DLEFT: _bindgen_ty_20 = 32;
pub const KEY_DUP: _bindgen_ty_20 = 64;
pub const KEY_DDOWN: _bindgen_ty_20 = 128;
pub const KEY_R: _bindgen_ty_20 = 256;
pub const KEY_L: _bindgen_ty_20 = 512;
pub const KEY_X: _bindgen_ty_20 = 1024;
pub const KEY_Y: _bindgen_ty_20 = 2048;
pub const KEY_ZL: _bindgen_ty_20 = 16384;
pub const KEY_ZR: _bindgen_ty_20 = 32768;
pub const KEY_TOUCH: _bindgen_ty_20 = 1048576;
pub const KEY_CSTICK_RIGHT: _bindgen_ty_20 = 16777216;
pub const KEY_CSTICK_LEFT: _bindgen_ty_20 = 33554432;
pub const KEY_CSTICK_UP: _bindgen_ty_20 = 67108864;
pub const KEY_CSTICK_DOWN: _bindgen_ty_20 = 134217728;
pub const KEY_CPAD_RIGHT: _bindgen_ty_20 = 268435456;
pub const KEY_CPAD_LEFT: _bindgen_ty_20 = 536870912;
pub const KEY_CPAD_UP: _bindgen_ty_20 = 1073741824;
pub const KEY_CPAD_DOWN: _bindgen_ty_20 = 2147483648;
pub const KEY_UP: _bindgen_ty_20 = 1073741888;
pub const KEY_DOWN: _bindgen_ty_20 = 2147483776;
pub const KEY_LEFT: _bindgen_ty_20 = 536870944;
pub const KEY_RIGHT: _bindgen_ty_20 = 268435472;
pub type _bindgen_ty_20 = u32;
#[repr(C)]
pub struct touchPosition {
    pub px: u16,
    pub py: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct circlePosition {
    pub dx: s16,
    pub dy: s16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct accelVector {
    pub x: s16,
    pub y: s16,
    pub z: s16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct angularRate {
    pub x: s16,
    pub z: s16,
    pub y: s16,
}
pub const HIDEVENT_PAD0: HID_Event = 0;
pub const HIDEVENT_PAD1: HID_Event = 1;
pub const HIDEVENT_Accel: HID_Event = 2;
pub const HIDEVENT_Gyro: HID_Event = 3;
pub const HIDEVENT_DebugPad: HID_Event = 4;
pub const HIDEVENT_MAX: HID_Event = 5;
pub type HID_Event = u32;
extern "C" {
    pub static mut hidMemHandle: Handle;
}
extern "C" {
    pub static mut hidSharedMem: *mut vu32;
}
extern "C" {
    pub fn hidInit() -> Result;
}
extern "C" {
    pub fn hidExit();
}
extern "C" {
    pub fn hidScanInput();
}
extern "C" {
    pub fn hidKeysHeld() -> u32;
}
extern "C" {
    pub fn hidKeysDown() -> u32;
}
extern "C" {
    pub fn hidKeysUp() -> u32;
}
extern "C" {
    pub fn hidTouchRead(pos: *mut touchPosition);
}
extern "C" {
    pub fn hidCircleRead(pos: *mut circlePosition);
}
extern "C" {
    pub fn hidAccelRead(vector: *mut accelVector);
}
extern "C" {
    pub fn hidGyroRead(rate: *mut angularRate);
}
extern "C" {
    pub fn hidWaitForEvent(id: HID_Event, nextEvent: bool);
}
extern "C" {
    pub fn HIDUSER_GetHandles(
        outMemHandle: *mut Handle,
        eventpad0: *mut Handle,
        eventpad1: *mut Handle,
        eventaccel: *mut Handle,
        eventgyro: *mut Handle,
        eventdebugpad: *mut Handle,
    ) -> Result;
}
extern "C" {
    pub fn HIDUSER_EnableAccelerometer() -> Result;
}
extern "C" {
    pub fn HIDUSER_DisableAccelerometer() -> Result;
}
extern "C" {
    pub fn HIDUSER_EnableGyroscope() -> Result;
}
extern "C" {
    pub fn HIDUSER_DisableGyroscope() -> Result;
}
extern "C" {
    pub fn HIDUSER_GetGyroscopeRawToDpsCoefficient(coeff: *mut f32) -> Result;
}
extern "C" {
    pub fn HIDUSER_GetSoundVolume(volume: *mut u8) -> Result;
}
extern "C" {
    pub static mut irrstMemHandle: Handle;
}
extern "C" {
    pub static mut irrstSharedMem: *mut vu32;
}
extern "C" {
    pub fn irrstInit() -> Result;
}
extern "C" {
    pub fn irrstExit();
}
extern "C" {
    pub fn irrstScanInput();
}
extern "C" {
    pub fn irrstKeysHeld() -> u32;
}
extern "C" {
    pub fn irrstCstickRead(pos: *mut circlePosition);
}
extern "C" {
    pub fn irrstWaitForEvent(nextEvent: bool);
}
extern "C" {
    pub fn IRRST_GetHandles(outMemHandle: *mut Handle, outEventHandle: *mut Handle) -> Result;
}
extern "C" {
    pub fn IRRST_Initialize(unk1: u32, unk2: u8) -> Result;
}
extern "C" {
    pub fn IRRST_Shutdown() -> Result;
}
#[repr(C)]
pub struct sslcContext {
    pub servhandle: Handle,
    pub sslchandle: u32,
    pub sharedmem_handle: Handle,
}
pub const SSLC_DefaultRootCert_Nintendo_CA: SSLC_DefaultRootCert = 1;
pub const SSLC_DefaultRootCert_Nintendo_CA_G2: SSLC_DefaultRootCert = 2;
pub const SSLC_DefaultRootCert_Nintendo_CA_G3: SSLC_DefaultRootCert = 3;
pub const SSLC_DefaultRootCert_Nintendo_Class2_CA: SSLC_DefaultRootCert = 4;
pub const SSLC_DefaultRootCert_Nintendo_Class2_CA_G2: SSLC_DefaultRootCert = 5;
pub const SSLC_DefaultRootCert_Nintendo_Class2_CA_G3: SSLC_DefaultRootCert = 6;
pub const SSLC_DefaultRootCert_CyberTrust: SSLC_DefaultRootCert = 7;
pub const SSLC_DefaultRootCert_AddTrust_External_CA: SSLC_DefaultRootCert = 8;
pub const SSLC_DefaultRootCert_COMODO: SSLC_DefaultRootCert = 9;
pub const SSLC_DefaultRootCert_USERTrust: SSLC_DefaultRootCert = 10;
pub const SSLC_DefaultRootCert_DigiCert_EV: SSLC_DefaultRootCert = 11;
pub type SSLC_DefaultRootCert = u32;
pub const SSLC_DefaultClientCert_ClCertA: SSLC_DefaultClientCert = 64;
pub type SSLC_DefaultClientCert = u32;
pub const SSLCOPT_Default: _bindgen_ty_21 = 0;
pub const SSLCOPT_DisableVerify: _bindgen_ty_21 = 512;
pub const SSLCOPT_TLSv10: _bindgen_ty_21 = 2048;
pub type _bindgen_ty_21 = u32;
extern "C" {
    pub fn sslcInit(session_handle: Handle) -> Result;
}
extern "C" {
    pub fn sslcExit();
}
extern "C" {
    pub fn sslcCreateRootCertChain(RootCertChain_contexthandle: *mut u32) -> Result;
}
extern "C" {
    pub fn sslcDestroyRootCertChain(RootCertChain_contexthandle: u32) -> Result;
}
extern "C" {
    pub fn sslcAddTrustedRootCA(
        RootCertChain_contexthandle: u32,
        cert: *const u8,
        certsize: u32,
        cert_contexthandle: *mut u32,
    ) -> Result;
}
extern "C" {
    pub fn sslcRootCertChainAddDefaultCert(
        RootCertChain_contexthandle: u32,
        certID: SSLC_DefaultRootCert,
        cert_contexthandle: *mut u32,
    ) -> Result;
}
extern "C" {
    pub fn sslcRootCertChainRemoveCert(
        RootCertChain_contexthandle: u32,
        cert_contexthandle: u32,
    ) -> Result;
}
extern "C" {
    pub fn sslcCreate8CertChain(CertChain_contexthandle: *mut u32) -> Result;
}
extern "C" {
    pub fn sslcDestroy8CertChain(CertChain_contexthandle: u32) -> Result;
}
extern "C" {
    pub fn sslc8CertChainAddCert(
        CertChain_contexthandle: u32,
        cert: *const u8,
        certsize: u32,
        cert_contexthandle: *mut u32,
    ) -> Result;
}
extern "C" {
    pub fn sslc8CertChainAddDefaultCert(
        CertChain_contexthandle: u32,
        certID: u8,
        cert_contexthandle: *mut u32,
    ) -> Result;
}
extern "C" {
    pub fn sslc8CertChainRemoveCert(
        CertChain_contexthandle: u32,
        cert_contexthandle: u32,
    ) -> Result;
}
extern "C" {
    pub fn sslcOpenClientCertContext(
        cert: *const u8,
        certsize: u32,
        key: *const u8,
        keysize: u32,
        ClientCert_contexthandle: *mut u32,
    ) -> Result;
}
extern "C" {
    pub fn sslcOpenDefaultClientCertContext(
        certID: SSLC_DefaultClientCert,
        ClientCert_contexthandle: *mut u32,
    ) -> Result;
}
extern "C" {
    pub fn sslcCloseClientCertContext(ClientCert_contexthandle: u32) -> Result;
}
extern "C" {
    pub fn sslcSeedRNG() -> Result;
}
extern "C" {
    pub fn sslcGenerateRandomData(buf: *mut u8, size: u32) -> Result;
}
extern "C" {
    pub fn sslcCreateContext(
        context: *mut sslcContext,
        sockfd: ::libc::c_int,
        input_opt: u32,
        hostname: *const ::libc::c_char,
    ) -> Result;
}
extern "C" {
    pub fn sslcDestroyContext(context: *mut sslcContext) -> Result;
}
extern "C" {
    pub fn sslcStartConnection(
        context: *mut sslcContext,
        internal_retval: *mut ::libc::c_int,
        out: *mut u32,
    ) -> Result;
}
extern "C" {
    pub fn sslcRead(
        context: *mut sslcContext,
        buf: *mut ::libc::c_void,
        len: usize,
        peek: bool,
    ) -> Result;
}
extern "C" {
    pub fn sslcWrite(context: *mut sslcContext, buf: *const ::libc::c_void, len: usize) -> Result;
}
extern "C" {
    pub fn sslcContextSetRootCertChain(context: *mut sslcContext, handle: u32) -> Result;
}
extern "C" {
    pub fn sslcContextSetClientCert(context: *mut sslcContext, handle: u32) -> Result;
}
extern "C" {
    pub fn sslcContextSetHandle8(context: *mut sslcContext, handle: u32) -> Result;
}
extern "C" {
    pub fn sslcContextClearOpt(context: *mut sslcContext, bitmask: u32) -> Result;
}
extern "C" {
    pub fn sslcContextGetProtocolCipher(
        context: *mut sslcContext,
        outprotocols: *mut ::libc::c_char,
        outprotocols_maxsize: u32,
        outcipher: *mut ::libc::c_char,
        outcipher_maxsize: u32,
    ) -> Result;
}
extern "C" {
    pub fn sslcContextGetState(context: *mut sslcContext, out: *mut u32) -> Result;
}
extern "C" {
    pub fn sslcContextInitSharedmem(context: *mut sslcContext, buf: *mut u8, size: u32) -> Result;
}
extern "C" {
    pub fn sslcAddCert(context: *mut sslcContext, buf: *const u8, size: u32) -> Result;
}
#[repr(C)]
pub struct httpcContext {
    pub servhandle: Handle,
    pub httphandle: u32,
}
pub const HTTPC_METHOD_GET: HTTPC_RequestMethod = 1;
pub const HTTPC_METHOD_POST: HTTPC_RequestMethod = 2;
pub const HTTPC_METHOD_HEAD: HTTPC_RequestMethod = 3;
pub const HTTPC_METHOD_PUT: HTTPC_RequestMethod = 4;
pub const HTTPC_METHOD_DELETE: HTTPC_RequestMethod = 5;
pub type HTTPC_RequestMethod = u32;
pub const HTTPC_STATUS_REQUEST_IN_PROGRESS: HTTPC_RequestStatus = 5;
pub const HTTPC_STATUS_DOWNLOAD_READY: HTTPC_RequestStatus = 7;
pub type HTTPC_RequestStatus = u32;
pub const HTTPC_KEEPALIVE_DISABLED: HTTPC_KeepAlive = 0;
pub const HTTPC_KEEPALIVE_ENABLED: HTTPC_KeepAlive = 1;
pub type HTTPC_KeepAlive = u32;
extern "C" {
    pub fn httpcInit(sharedmem_size: u32) -> Result;
}
extern "C" {
    pub fn httpcExit();
}
extern "C" {
    pub fn httpcOpenContext(
        context: *mut httpcContext,
        method: HTTPC_RequestMethod,
        url: *const ::libc::c_char,
        use_defaultproxy: u32,
    ) -> Result;
}
extern "C" {
    pub fn httpcCloseContext(context: *mut httpcContext) -> Result;
}
extern "C" {
    pub fn httpcCancelConnection(context: *mut httpcContext) -> Result;
}
extern "C" {
    pub fn httpcAddRequestHeaderField(
        context: *mut httpcContext,
        name: *const ::libc::c_char,
        value: *const ::libc::c_char,
    ) -> Result;
}
extern "C" {
    pub fn httpcAddPostDataAscii(
        context: *mut httpcContext,
        name: *const ::libc::c_char,
        value: *const ::libc::c_char,
    ) -> Result;
}
extern "C" {
    pub fn httpcAddPostDataBinary(
        context: *mut httpcContext,
        name: *const ::libc::c_char,
        value: *const u8,
        len: u32,
    ) -> Result;
}
extern "C" {
    pub fn httpcAddPostDataRaw(context: *mut httpcContext, data: *const u32, len: u32) -> Result;
}
extern "C" {
    pub fn httpcBeginRequest(context: *mut httpcContext) -> Result;
}
extern "C" {
    pub fn httpcReceiveData(context: *mut httpcContext, buffer: *mut u8, size: u32) -> Result;
}
extern "C" {
    pub fn httpcReceiveDataTimeout(
        context: *mut httpcContext,
        buffer: *mut u8,
        size: u32,
        timeout: u64,
    ) -> Result;
}
extern "C" {
    pub fn httpcGetRequestState(
        context: *mut httpcContext,
        out: *mut HTTPC_RequestStatus,
    ) -> Result;
}
extern "C" {
    pub fn httpcGetDownloadSizeState(
        context: *mut httpcContext,
        downloadedsize: *mut u32,
        contentsize: *mut u32,
    ) -> Result;
}
extern "C" {
    pub fn httpcGetResponseStatusCode(context: *mut httpcContext, out: *mut u32) -> Result;
}
extern "C" {
    pub fn httpcGetResponseStatusCodeTimeout(
        context: *mut httpcContext,
        out: *mut u32,
        timeout: u64,
    ) -> Result;
}
extern "C" {
    pub fn httpcGetResponseHeader(
        context: *mut httpcContext,
        name: *const ::libc::c_char,
        value: *mut ::libc::c_char,
        valuebuf_maxsize: u32,
    ) -> Result;
}
extern "C" {
    pub fn httpcAddTrustedRootCA(
        context: *mut httpcContext,
        cert: *const u8,
        certsize: u32,
    ) -> Result;
}
extern "C" {
    pub fn httpcAddDefaultCert(context: *mut httpcContext, certID: SSLC_DefaultRootCert) -> Result;
}
extern "C" {
    pub fn httpcSelectRootCertChain(
        context: *mut httpcContext,
        RootCertChain_contexthandle: u32,
    ) -> Result;
}
extern "C" {
    pub fn httpcSetClientCert(
        context: *mut httpcContext,
        cert: *const u8,
        certsize: u32,
        privk: *const u8,
        privk_size: u32,
    ) -> Result;
}
extern "C" {
    pub fn httpcSetClientCertDefault(
        context: *mut httpcContext,
        certID: SSLC_DefaultClientCert,
    ) -> Result;
}
extern "C" {
    pub fn httpcSetClientCertContext(
        context: *mut httpcContext,
        ClientCert_contexthandle: u32,
    ) -> Result;
}
extern "C" {
    pub fn httpcSetSSLOpt(context: *mut httpcContext, options: u32) -> Result;
}
extern "C" {
    pub fn httpcSetSSLClearOpt(context: *mut httpcContext, options: u32) -> Result;
}
extern "C" {
    pub fn httpcCreateRootCertChain(RootCertChain_contexthandle: *mut u32) -> Result;
}
extern "C" {
    pub fn httpcDestroyRootCertChain(RootCertChain_contexthandle: u32) -> Result;
}
extern "C" {
    pub fn httpcRootCertChainAddCert(
        RootCertChain_contexthandle: u32,
        cert: *const u8,
        certsize: u32,
        cert_contexthandle: *mut u32,
    ) -> Result;
}
extern "C" {
    pub fn httpcRootCertChainAddDefaultCert(
        RootCertChain_contexthandle: u32,
        certID: SSLC_DefaultRootCert,
        cert_contexthandle: *mut u32,
    ) -> Result;
}
extern "C" {
    pub fn httpcRootCertChainRemoveCert(
        RootCertChain_contexthandle: u32,
        cert_contexthandle: u32,
    ) -> Result;
}
extern "C" {
    pub fn httpcOpenClientCertContext(
        cert: *const u8,
        certsize: u32,
        privk: *const u8,
        privk_size: u32,
        ClientCert_contexthandle: *mut u32,
    ) -> Result;
}
extern "C" {
    pub fn httpcOpenDefaultClientCertContext(
        certID: SSLC_DefaultClientCert,
        ClientCert_contexthandle: *mut u32,
    ) -> Result;
}
extern "C" {
    pub fn httpcCloseClientCertContext(ClientCert_contexthandle: u32) -> Result;
}
extern "C" {
    pub fn httpcDownloadData(
        context: *mut httpcContext,
        buffer: *mut u8,
        size: u32,
        downloadedsize: *mut u32,
    ) -> Result;
}
extern "C" {
    pub fn httpcSetKeepAlive(context: *mut httpcContext, option: HTTPC_KeepAlive) -> Result;
}
#[repr(C)]
pub struct udsNodeInfo {
    pub uds_friendcodeseed: u64,
    pub __bindgen_anon_1: udsNodeInfo__bindgen_ty_1,
    pub NetworkNodeID: u16,
    pub pad_x22: u16,
    pub word_x24: u32,
}
#[repr(C)]
pub struct udsNodeInfo__bindgen_ty_1 {
    pub usercfg: __BindgenUnionField<[u8; 24usize]>,
    pub __bindgen_anon_1: __BindgenUnionField<udsNodeInfo__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: [u16; 12usize],
}
#[repr(C)]
pub struct udsNodeInfo__bindgen_ty_1__bindgen_ty_1 {
    pub username: [u16; 10usize],
    pub unk_x1c: u16,
    pub flag: u8,
    pub pad_x1f: u8,
}
#[repr(C)]
pub struct udsConnectionStatus {
    pub status: u32,
    pub unk_x4: u32,
    pub cur_NetworkNodeID: u16,
    pub unk_xa: u16,
    pub unk_xc: [u32; 8usize],
    pub total_nodes: u8,
    pub max_nodes: u8,
    pub node_bitmask: u16,
}
#[repr(C)]
pub struct udsNetworkStruct {
    pub host_macaddress: [u8; 6usize],
    pub channel: u8,
    pub pad_x7: u8,
    pub initialized_flag: u8,
    pub unk_x9: [u8; 3usize],
    pub oui_value: [u8; 3usize],
    pub oui_type: u8,
    pub wlancommID: u32,
    pub id8: u8,
    pub unk_x15: u8,
    pub attributes: u16,
    pub networkID: u32,
    pub total_nodes: u8,
    pub max_nodes: u8,
    pub unk_x1e: u8,
    pub unk_x1f: u8,
    pub unk_x20: [u8; 31usize],
    pub appdata_size: u8,
    pub appdata: [u8; 200usize],
}
#[repr(C)]
pub struct udsBindContext {
    pub BindNodeID: u32,
    pub event: Handle,
    pub spectator: bool,
}
#[repr(C)]
pub struct nwmScanInputStruct {
    pub unk_x0: u16,
    pub unk_x2: u16,
    pub unk_x4: u16,
    pub unk_x6: u16,
    pub mac_address: [u8; 6usize],
    pub unk_xe: [u8; 38usize],
}
#[repr(C)]
pub struct nwmBeaconDataReplyHeader {
    pub maxsize: u32,
    pub size: u32,
    pub total_entries: u32,
}
#[repr(C)]
pub struct nwmBeaconDataReplyEntry {
    pub size: u32,
    pub unk_x4: u8,
    pub channel: u8,
    pub unk_x6: u8,
    pub unk_x7: u8,
    pub mac_address: [u8; 6usize],
    pub unk_xe: [u8; 6usize],
    pub unk_x14: u32,
    pub val_x1c: u32,
}
#[repr(C)]
pub struct udsNetworkScanInfo {
    pub datareply_entry: nwmBeaconDataReplyEntry,
    pub network: udsNetworkStruct,
    pub nodes: [udsNodeInfo; 16usize],
}
pub const UDSNETATTR_DisableConnectSpectators: _bindgen_ty_22 = 1;
pub const UDSNETATTR_DisableConnectClients: _bindgen_ty_22 = 2;
pub const UDSNETATTR_x4: _bindgen_ty_22 = 4;
pub const UDSNETATTR_Default: _bindgen_ty_22 = 32768;
pub type _bindgen_ty_22 = u32;
pub const UDS_SENDFLAG_Default: _bindgen_ty_23 = 1;
pub const UDS_SENDFLAG_Broadcast: _bindgen_ty_23 = 2;
pub type _bindgen_ty_23 = u32;
pub const UDSCONTYPE_Client: udsConnectionType = 1;
pub const UDSCONTYPE_Spectator: udsConnectionType = 2;
pub type udsConnectionType = u32;
extern "C" {
    pub fn udsInit(sharedmem_size: usize, username: *const ::libc::c_char) -> Result;
}
extern "C" {
    pub fn udsExit();
}
extern "C" {
    pub fn udsGenerateNodeInfo(
        nodeinfo: *mut udsNodeInfo,
        username: *const ::libc::c_char,
    ) -> Result;
}
extern "C" {
    pub fn udsGetNodeInfoUsername(
        nodeinfo: *const udsNodeInfo,
        username: *mut ::libc::c_char,
    ) -> Result;
}
extern "C" {
    pub fn udsCheckNodeInfoInitialized(nodeinfo: *const udsNodeInfo) -> bool;
}
extern "C" {
    pub fn udsGenerateDefaultNetworkStruct(
        network: *mut udsNetworkStruct,
        wlancommID: u32,
        id8: u8,
        max_nodes: u8,
    );
}
extern "C" {
    pub fn udsScanBeacons(
        outbuf: *mut ::libc::c_void,
        maxsize: usize,
        networks: *mut *mut udsNetworkScanInfo,
        total_networks: *mut usize,
        wlancommID: u32,
        id8: u8,
        host_macaddress: *const u8,
        connected: bool,
    ) -> Result;
}
extern "C" {
    pub fn udsSetApplicationData(buf: *const ::libc::c_void, size: usize) -> Result;
}
extern "C" {
    pub fn udsGetApplicationData(
        buf: *mut ::libc::c_void,
        size: usize,
        actual_size: *mut usize,
    ) -> Result;
}
extern "C" {
    pub fn udsGetNetworkStructApplicationData(
        network: *const udsNetworkStruct,
        buf: *mut ::libc::c_void,
        size: usize,
        actual_size: *mut usize,
    ) -> Result;
}
extern "C" {
    pub fn udsBind(
        bindcontext: *mut udsBindContext,
        NetworkNodeID: u16,
        spectator: bool,
        data_channel: u8,
        recv_buffer_size: u32,
    ) -> Result;
}
extern "C" {
    pub fn udsUnbind(bindcontext: *mut udsBindContext) -> Result;
}
extern "C" {
    pub fn udsWaitDataAvailable(
        bindcontext: *const udsBindContext,
        nextEvent: bool,
        wait: bool,
    ) -> bool;
}
extern "C" {
    pub fn udsPullPacket(
        bindcontext: *const udsBindContext,
        buf: *mut ::libc::c_void,
        size: usize,
        actual_size: *mut usize,
        src_NetworkNodeID: *mut u16,
    ) -> Result;
}
extern "C" {
    pub fn udsSendTo(
        dst_NetworkNodeID: u16,
        data_channel: u8,
        flags: u8,
        buf: *const ::libc::c_void,
        size: usize,
    ) -> Result;
}
extern "C" {
    pub fn udsGetChannel(channel: *mut u8) -> Result;
}
extern "C" {
    pub fn udsCreateNetwork(
        network: *const udsNetworkStruct,
        passphrase: *const ::libc::c_void,
        passphrase_size: usize,
        context: *mut udsBindContext,
        data_channel: u8,
        recv_buffer_size: u32,
    ) -> Result;
}
extern "C" {
    pub fn udsConnectNetwork(
        network: *const udsNetworkStruct,
        passphrase: *const ::libc::c_void,
        passphrase_size: usize,
        context: *mut udsBindContext,
        recv_NetworkNodeID: u16,
        connection_type: udsConnectionType,
        data_channel: u8,
        recv_buffer_size: u32,
    ) -> Result;
}
extern "C" {
    pub fn udsDestroyNetwork() -> Result;
}
extern "C" {
    pub fn udsDisconnectNetwork() -> Result;
}
extern "C" {
    pub fn udsEjectClient(NetworkNodeID: u16) -> Result;
}
extern "C" {
    pub fn udsEjectSpectator() -> Result;
}
extern "C" {
    pub fn udsUpdateNetworkAttribute(bitmask: u16, flag: bool) -> Result;
}
extern "C" {
    pub fn udsSetNewConnectionsBlocked(block: bool, clients: bool, flag: bool) -> Result;
}
extern "C" {
    pub fn udsAllowSpectators() -> Result;
}
extern "C" {
    pub fn udsGetConnectionStatus(output: *mut udsConnectionStatus) -> Result;
}
extern "C" {
    pub fn udsWaitConnectionStatusEvent(nextEvent: bool, wait: bool) -> bool;
}
extern "C" {
    pub fn udsGetNodeInformation(NetworkNodeID: u16, output: *mut udsNodeInfo) -> Result;
}
pub const EXCLUSIVE_STATE_NONE: ndmExclusiveState = 0;
pub const EXCLUSIVE_STATE_INFRASTRUCTURE: ndmExclusiveState = 1;
pub const EXCLUSIVE_STATE_LOCAL_COMMUNICATIONS: ndmExclusiveState = 2;
pub const EXCLUSIVE_STATE_STREETPASS: ndmExclusiveState = 3;
pub const EXCLUSIVE_STATE_STREETPASS_DATA: ndmExclusiveState = 4;
pub type ndmExclusiveState = u32;
pub const STATE_INITIAL: ndmState = 0;
pub const STATE_SUSPENDED: ndmState = 1;
pub const STATE_INFRASTRUCTURE_CONNECTING: ndmState = 2;
pub const STATE_INFRASTRUCTURE_CONNECTED: ndmState = 3;
pub const STATE_INFRASTRUCTURE_WORKING: ndmState = 4;
pub const STATE_INFRASTRUCTURE_SUSPENDING: ndmState = 5;
pub const STATE_INFRASTRUCTURE_FORCE_SUSPENDING: ndmState = 6;
pub const STATE_INFRASTRUCTURE_DISCONNECTING: ndmState = 7;
pub const STATE_INFRASTRUCTURE_FORCE_DISCONNECTING: ndmState = 8;
pub const STATE_CEC_WORKING: ndmState = 9;
pub const STATE_CEC_FORCE_SUSPENDING: ndmState = 10;
pub const STATE_CEC_SUSPENDING: ndmState = 11;
pub type ndmState = u32;
pub const DAEMON_CEC: ndmDaemon = 0;
pub const DAEMON_BOSS: ndmDaemon = 1;
pub const DAEMON_NIM: ndmDaemon = 2;
pub const DAEMON_FRIENDS: ndmDaemon = 3;
pub type ndmDaemon = u32;
pub const DAEMON_MASK_CEC: ndmDaemonMask = 1;
pub const DAEMON_MASK_BOSS: ndmDaemonMask = 2;
pub const DAEMON_MASK_NIM: ndmDaemonMask = 4;
pub const DAEMON_MASK_FRIENDS: ndmDaemonMask = 8;
pub const DAEMON_MASK_BACKGROUOND: ndmDaemonMask = 7;
pub const DAEMON_MASK_ALL: ndmDaemonMask = 15;
pub const DAEMON_MASK_DEFAULT: ndmDaemonMask = 9;
pub type ndmDaemonMask = u32;
pub const DAEMON_STATUS_BUSY: ndmDaemonStatus = 0;
pub const DAEMON_STATUS_IDLE: ndmDaemonStatus = 1;
pub const DAEMON_STATUS_SUSPENDING: ndmDaemonStatus = 2;
pub const DAEMON_STATUS_SUSPENDED: ndmDaemonStatus = 3;
pub type ndmDaemonStatus = u32;
extern "C" {
    pub fn ndmuInit() -> Result;
}
extern "C" {
    pub fn ndmuExit();
}
extern "C" {
    pub fn NDMU_EnterExclusiveState(state: ndmExclusiveState) -> Result;
}
extern "C" {
    pub fn NDMU_LeaveExclusiveState() -> Result;
}
extern "C" {
    pub fn NDMU_GetExclusiveState(state: *mut ndmExclusiveState) -> Result;
}
extern "C" {
    pub fn NDMU_LockState() -> Result;
}
extern "C" {
    pub fn NDMU_UnlockState() -> Result;
}
extern "C" {
    pub fn NDMU_SuspendDaemons(mask: ndmDaemonMask) -> Result;
}
extern "C" {
    pub fn NDMU_ResumeDaemons(mask: ndmDaemonMask) -> Result;
}
extern "C" {
    pub fn NDMU_SuspendScheduler(flag: u32) -> Result;
}
extern "C" {
    pub fn NDMU_ResumeScheduler() -> Result;
}
extern "C" {
    pub fn NDMU_GetCurrentState(state: *mut ndmState) -> Result;
}
extern "C" {
    pub fn NDMU_QueryStatus(status: *mut ndmDaemonStatus) -> Result;
}
extern "C" {
    pub fn NDMU_SetScanInterval(interval: u32) -> Result;
}
extern "C" {
    pub fn NDMU_GetScanInterval(interval: *mut u32) -> Result;
}
extern "C" {
    pub fn NDMU_GetRetryInterval(interval: *mut u32) -> Result;
}
extern "C" {
    pub fn NDMU_ResetDaemons() -> Result;
}
extern "C" {
    pub fn NDMU_GetDefaultDaemons(mask: *mut ndmDaemonMask) -> Result;
}
extern "C" {
    pub fn NDMU_ClearMacFilter() -> Result;
}
pub const IM_DEFAULT: NIM_InstallationMode = 0;
pub const IM_UNKNOWN1: NIM_InstallationMode = 1;
pub const IM_UNKNOWN2: NIM_InstallationMode = 2;
pub const IM_REINSTALL: NIM_InstallationMode = 3;
pub type NIM_InstallationMode = u32;
pub const DS_NOT_INITIALIZED: NIM_DownloadState = 0;
pub const DS_INITIALIZED: NIM_DownloadState = 1;
pub const DS_DOWNLOAD_TMD: NIM_DownloadState = 2;
pub const DS_PREPARE_SAVE_DATA: NIM_DownloadState = 3;
pub const DS_DOWNLOAD_CONTENTS: NIM_DownloadState = 4;
pub const DS_WAIT_COMMIT: NIM_DownloadState = 5;
pub const DS_COMMITTING: NIM_DownloadState = 6;
pub const DS_FINISHED: NIM_DownloadState = 7;
pub const DS_VERSION_ERROR: NIM_DownloadState = 8;
pub const DS_CREATE_CONTEXT: NIM_DownloadState = 9;
pub const DS_CANNOT_RECOVER: NIM_DownloadState = 10;
pub const DS_INVALID: NIM_DownloadState = 11;
pub type NIM_DownloadState = u32;
#[repr(C)]
pub struct NIM_TitleConfig {
    pub titleId: u64,
    pub version: u32,
    pub unknown_0: u32,
    pub ratingAge: u8,
    pub mediaType: u8,
    pub padding: [u8; 2usize],
    pub unknown_1: u32,
}
#[repr(C)]
pub struct NIM_TitleProgress {
    pub state: u32,
    pub lastResult: Result,
    pub downloadedSize: u64,
    pub totalSize: u64,
}
extern "C" {
    pub fn nimsInit(buffer: *mut ::libc::c_void, buffer_len: usize) -> Result;
}
extern "C" {
    pub fn nimsInitWithTIN(
        buffer: *mut ::libc::c_void,
        buffer_len: usize,
        TIN: *const ::libc::c_char,
    ) -> Result;
}
extern "C" {
    pub fn nimsExit();
}
extern "C" {
    pub fn nimsGetSessionHandle() -> *mut Handle;
}
extern "C" {
    pub fn NIMS_SetAttribute(attr: *const ::libc::c_char, val: *const ::libc::c_char) -> Result;
}
extern "C" {
    pub fn NIMS_WantUpdate(want_update: *mut bool) -> Result;
}
extern "C" {
    pub fn NIMS_MakeTitleConfig(
        cfg: *mut NIM_TitleConfig,
        titleId: u64,
        version: u32,
        ratingAge: u8,
        mediaType: FS_MediaType,
    );
}
extern "C" {
    pub fn NIMS_RegisterTask(
        cfg: *const NIM_TitleConfig,
        name: *const ::libc::c_char,
        maker: *const ::libc::c_char,
    ) -> Result;
}
extern "C" {
    pub fn NIMS_IsTaskRegistered(titleId: u64, registered: *mut bool) -> Result;
}
extern "C" {
    pub fn NIMS_UnregisterTask(titleId: u64) -> Result;
}
extern "C" {
    pub fn NIMS_StartDownload(cfg: *const NIM_TitleConfig, mode: NIM_InstallationMode) -> Result;
}
extern "C" {
    pub fn NIMS_StartDownloadSimple(cfg: *const NIM_TitleConfig) -> Result;
}
extern "C" {
    pub fn NIMS_GetProgress(tp: *mut NIM_TitleProgress) -> Result;
}
extern "C" {
    pub fn NIMS_CancelDownload() -> Result;
}
extern "C" {
    pub fn nwmExtInit() -> Result;
}
extern "C" {
    pub fn nwmExtExit();
}
extern "C" {
    pub fn NWMEXT_ControlWirelessEnabled(enableWifi: bool) -> Result;
}
extern "C" {
    pub fn iruInit(sharedmem_addr: *mut u32, sharedmem_size: u32) -> Result;
}
extern "C" {
    pub fn iruExit();
}
extern "C" {
    pub fn iruGetServHandle() -> Handle;
}
extern "C" {
    pub fn iruSendData(buf: *mut u8, size: u32, wait: bool) -> Result;
}
extern "C" {
    pub fn iruRecvData(
        buf: *mut u8,
        size: u32,
        flag: u8,
        transfercount: *mut u32,
        wait: bool,
    ) -> Result;
}
extern "C" {
    pub fn IRU_Initialize() -> Result;
}
extern "C" {
    pub fn IRU_Shutdown() -> Result;
}
extern "C" {
    pub fn IRU_StartSendTransfer(buf: *mut u8, size: u32) -> Result;
}
extern "C" {
    pub fn IRU_WaitSendTransfer() -> Result;
}
extern "C" {
    pub fn IRU_StartRecvTransfer(size: u32, flag: u8) -> Result;
}
extern "C" {
    pub fn IRU_WaitRecvTransfer(transfercount: *mut u32) -> Result;
}
extern "C" {
    pub fn IRU_SetBitRate(value: u8) -> Result;
}
extern "C" {
    pub fn IRU_GetBitRate(out: *mut u8) -> Result;
}
extern "C" {
    pub fn IRU_SetIRLEDState(value: u32) -> Result;
}
extern "C" {
    pub fn IRU_GetIRLEDRecvState(out: *mut u32) -> Result;
}
extern "C" {
    pub fn nsInit() -> Result;
}
extern "C" {
    pub fn nsExit();
}
extern "C" {
    pub fn NS_LaunchFIRM(titleid: u64) -> Result;
}
extern "C" {
    pub fn NS_LaunchTitle(titleid: u64, launch_flags: u32, procid: *mut u32) -> Result;
}
extern "C" {
    pub fn NS_TerminateTitle() -> Result;
}
extern "C" {
    pub fn NS_LaunchApplicationFIRM(titleid: u64, flags: u32) -> Result;
}
extern "C" {
    pub fn NS_RebootToTitle(mediatype: u8, titleid: u64) -> Result;
}
extern "C" {
    pub fn NS_TerminateProcessTID(titleid: u64, timeout: u64) -> Result;
}
extern "C" {
    pub fn NS_RebootSystem() -> Result;
}
extern "C" {
    pub fn pmInit() -> Result;
}
extern "C" {
    pub fn pmExit();
}
extern "C" {
    pub fn PM_LaunchTitle(mediatype: u8, titleid: u64, launch_flags: u32) -> Result;
}
extern "C" {
    pub fn PM_GetTitleExheaderFlags(mediatype: u8, titleid: u64, out: *mut u8) -> Result;
}
extern "C" {
    pub fn PM_SetFIRMLaunchParams(size: u32, in_: *mut u8) -> Result;
}
extern "C" {
    pub fn PM_GetFIRMLaunchParams(size: u32, out: *mut u8) -> Result;
}
extern "C" {
    pub fn PM_LaunchFIRMSetParams(firm_titleid_low: u32, size: u32, in_: *mut u8) -> Result;
}
extern "C" {
    pub fn PM_TerminateCurrentApplication(timeout: u64) -> Result;
}
extern "C" {
    pub fn PM_TerminateProcess(pid: u8, timeout: u64) -> Result;
}
extern "C" {
    pub fn PM_UnregisterProcess(tid: u64) -> Result;
}
pub const PS_ALGORITHM_CBC_ENC: PS_AESAlgorithm = 0;
pub const PS_ALGORITHM_CBC_DEC: PS_AESAlgorithm = 1;
pub const PS_ALGORITHM_CTR_ENC: PS_AESAlgorithm = 2;
pub const PS_ALGORITHM_CTR_DEC: PS_AESAlgorithm = 3;
pub const PS_ALGORITHM_CCM_ENC: PS_AESAlgorithm = 4;
pub const PS_ALGORITHM_CCM_DEC: PS_AESAlgorithm = 5;
pub type PS_AESAlgorithm = u32;
pub const PS_KEYSLOT_0D: PS_AESKeyType = 0;
pub const PS_KEYSLOT_2D: PS_AESKeyType = 1;
pub const PS_KEYSLOT_31: PS_AESKeyType = 2;
pub const PS_KEYSLOT_38: PS_AESKeyType = 3;
pub const PS_KEYSLOT_32: PS_AESKeyType = 4;
pub const PS_KEYSLOT_39_DLP: PS_AESKeyType = 5;
pub const PS_KEYSLOT_2E: PS_AESKeyType = 6;
pub const PS_KEYSLOT_INVALID: PS_AESKeyType = 7;
pub const PS_KEYSLOT_36: PS_AESKeyType = 8;
pub const PS_KEYSLOT_39_NFC: PS_AESKeyType = 9;
pub type PS_AESKeyType = u32;
#[repr(C)]
pub struct psRSAContext {
    pub modulo: [u8; 256usize],
    pub exponent: [u8; 256usize],
    pub rsa_bitsize: u32,
    pub unk: u32,
}
extern "C" {
    pub fn psInit() -> Result;
}
extern "C" {
    pub fn psInitHandle(handle: Handle) -> Result;
}
extern "C" {
    pub fn psExit();
}
extern "C" {
    pub fn psGetSessionHandle() -> Handle;
}
extern "C" {
    pub fn PS_SignRsaSha256(hash: *mut u8, ctx: *mut psRSAContext, signature: *mut u8) -> Result;
}
extern "C" {
    pub fn PS_VerifyRsaSha256(hash: *mut u8, ctx: *mut psRSAContext, signature: *mut u8) -> Result;
}
extern "C" {
    pub fn PS_EncryptDecryptAes(
        size: u32,
        in_: *mut u8,
        out: *mut u8,
        aes_algo: PS_AESAlgorithm,
        key_type: PS_AESKeyType,
        iv: *mut u8,
    ) -> Result;
}
extern "C" {
    pub fn PS_EncryptSignDecryptVerifyAesCcm(
        in_: *mut u8,
        in_size: u32,
        out: *mut u8,
        out_size: u32,
        data_len: u32,
        mac_data_len: u32,
        mac_len: u32,
        aes_algo: PS_AESAlgorithm,
        key_type: PS_AESKeyType,
        nonce: *mut u8,
    ) -> Result;
}
extern "C" {
    pub fn PS_GetLocalFriendCodeSeed(seed: *mut u64) -> Result;
}
extern "C" {
    pub fn PS_GetDeviceId(device_id: *mut u32) -> Result;
}
extern "C" {
    pub fn PS_GenerateRandomBytes(out: *mut ::libc::c_void, len: usize) -> Result;
}
extern "C" {
    pub fn ptmuInit() -> Result;
}
extern "C" {
    pub fn ptmuExit();
}
extern "C" {
    pub fn PTMU_GetShellState(out: *mut u8) -> Result;
}
extern "C" {
    pub fn PTMU_GetBatteryLevel(out: *mut u8) -> Result;
}
extern "C" {
    pub fn PTMU_GetBatteryChargeState(out: *mut u8) -> Result;
}
extern "C" {
    pub fn PTMU_GetPedometerState(out: *mut u8) -> Result;
}
extern "C" {
    pub fn PTMU_GetTotalStepCount(steps: *mut u32) -> Result;
}
extern "C" {
    pub fn PTMU_GetAdapterState(out: *mut bool) -> Result;
}
extern "C" {
    pub fn ptmSysmInit() -> Result;
}
extern "C" {
    pub fn ptmSysmExit();
}
extern "C" {
    pub fn PTMSYSM_CheckNew3DS() -> Result;
}
extern "C" {
    pub fn PTMSYSM_ConfigureNew3DSCPU(value: u8) -> Result;
}
extern "C" {
    pub fn PTMSYSM_ShutdownAsync(timeout: u64) -> Result;
}
extern "C" {
    pub fn PTMSYSM_RebootAsync(timeout: u64) -> Result;
}
pub const WAIT_NONE: PXIDEV_WaitType = 0;
pub const WAIT_SLEEP: PXIDEV_WaitType = 1;
pub const WAIT_IREQ_RETURN: PXIDEV_WaitType = 2;
pub const WAIT_IREQ_CONTINUE: PXIDEV_WaitType = 3;
pub type PXIDEV_WaitType = u32;
pub const DEASSERT_NONE: PXIDEV_DeassertType = 0;
pub const DEASSERT_BEFORE_WAIT: PXIDEV_DeassertType = 1;
pub const DEASSERT_AFTER_WAIT: PXIDEV_DeassertType = 2;
pub type PXIDEV_DeassertType = u32;
#[repr(C)]
pub struct PXIDEV_SPIBuffer {
    pub ptr: *mut ::libc::c_void,
    pub size: u32,
    pub transferOption: u8,
    pub waitOperation: u64,
}
extern "C" {
    pub fn pxiDevInit() -> Result;
}
extern "C" {
    pub fn pxiDevExit();
}
extern "C" {
    pub fn PXIDEV_SPIMultiWriteRead(
        header: *mut PXIDEV_SPIBuffer,
        writeBuffer1: *mut PXIDEV_SPIBuffer,
        readBuffer1: *mut PXIDEV_SPIBuffer,
        writeBuffer2: *mut PXIDEV_SPIBuffer,
        readBuffer2: *mut PXIDEV_SPIBuffer,
        footer: *mut PXIDEV_SPIBuffer,
    ) -> Result;
}
extern "C" {
    pub fn PXIDEV_SPIWriteRead(
        bytesRead: *mut u32,
        initialWaitOperation: u64,
        writeBuffer: *mut PXIDEV_SPIBuffer,
        readBuffer: *mut PXIDEV_SPIBuffer,
    ) -> Result;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: ::libc::c_int,
    pub tz_dsttime: ::libc::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bintime {
    pub sec: time_t,
    pub frac: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
pub type __ULong = ::libc::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Bigint {
    pub _next: *mut _Bigint,
    pub _k: ::libc::c_int,
    pub _maxwds: ::libc::c_int,
    pub _sign: ::libc::c_int,
    pub _wds: ::libc::c_int,
    pub _x: [__ULong; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __tm {
    pub __tm_sec: ::libc::c_int,
    pub __tm_min: ::libc::c_int,
    pub __tm_hour: ::libc::c_int,
    pub __tm_mday: ::libc::c_int,
    pub __tm_mon: ::libc::c_int,
    pub __tm_year: ::libc::c_int,
    pub __tm_wday: ::libc::c_int,
    pub __tm_yday: ::libc::c_int,
    pub __tm_isdst: ::libc::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _on_exit_args {
    pub _fnargs: [*mut ::libc::c_void; 32usize],
    pub _dso_handle: [*mut ::libc::c_void; 32usize],
    pub _fntypes: __ULong,
    pub _is_cxa: __ULong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _atexit {
    pub _next: *mut _atexit,
    pub _ind: ::libc::c_int,
    pub _fns: [::core::option::Option<unsafe extern "C" fn()>; 32usize],
    pub _on_exit_args: _on_exit_args,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::libc::c_uchar,
    pub _size: ::libc::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::libc::c_uchar,
    pub _r: ::libc::c_int,
    pub _w: ::libc::c_int,
    pub _flags: ::libc::c_short,
    pub _file: ::libc::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::libc::c_int,
    pub _cookie: *mut ::libc::c_void,
    pub _read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::libc::c_void,
            arg3: *mut ::libc::c_char,
            arg4: ::libc::c_int,
        ) -> ::libc::c_int,
    >,
    pub _write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::libc::c_void,
            arg3: *const ::libc::c_char,
            arg4: ::libc::c_int,
        ) -> ::libc::c_int,
    >,
    pub _seek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::libc::c_void,
            arg3: _fpos_t,
            arg4: ::libc::c_int,
        ) -> _fpos_t,
    >,
    pub _close: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut _reent, arg2: *mut ::libc::c_void) -> ::libc::c_int,
    >,
    pub _ub: __sbuf,
    pub _up: *mut ::libc::c_uchar,
    pub _ur: ::libc::c_int,
    pub _ubuf: [::libc::c_uchar; 3usize],
    pub _nbuf: [::libc::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::libc::c_int,
    pub _offset: _off_t,
    pub _data: *mut _reent,
    pub _lock: _flock_t,
    pub _mbstate: _mbstate_t,
    pub _flags2: ::libc::c_int,
}
pub type __FILE = __sFILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _glue {
    pub _next: *mut _glue,
    pub _niobs: ::libc::c_int,
    pub _iobs: *mut __FILE,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _rand48 {
    pub _seed: [::libc::c_ushort; 3usize],
    pub _mult: [::libc::c_ushort; 3usize],
    pub _add: ::libc::c_ushort,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent {
    pub _errno: ::libc::c_int,
    pub _stdin: *mut __FILE,
    pub _stdout: *mut __FILE,
    pub _stderr: *mut __FILE,
    pub _inc: ::libc::c_int,
    pub _emergency: [::libc::c_char; 25usize],
    pub _unspecified_locale_info: ::libc::c_int,
    pub _locale: *mut __locale_t,
    pub __sdidinit: ::libc::c_int,
    pub __cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent)>,
    pub _result: *mut _Bigint,
    pub _result_k: ::libc::c_int,
    pub _p5s: *mut _Bigint,
    pub _freelist: *mut *mut _Bigint,
    pub _cvtlen: ::libc::c_int,
    pub _cvtbuf: *mut ::libc::c_char,
    pub _new: _reent__bindgen_ty_1,
    pub _atexit: *mut _atexit,
    pub _atexit0: _atexit,
    pub _sig_func: *mut ::core::option::Option<unsafe extern "C" fn(arg1: ::libc::c_int)>,
    pub __sglue: _glue,
    pub __sf: [__FILE; 3usize],
    pub deviceData: *mut ::libc::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _reent__bindgen_ty_1 {
    pub _reent: _reent__bindgen_ty_1__bindgen_ty_1,
    pub _unused: _reent__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u64; 30usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent__bindgen_ty_1__bindgen_ty_1 {
    pub _unused_rand: ::libc::c_uint,
    pub _strtok_last: *mut ::libc::c_char,
    pub _asctime_buf: [::libc::c_char; 26usize],
    pub _localtime_buf: __tm,
    pub _gamma_signgam: ::libc::c_int,
    pub _rand_next: ::libc::c_ulonglong,
    pub _r48: _rand48,
    pub _mblen_state: _mbstate_t,
    pub _mbtowc_state: _mbstate_t,
    pub _wctomb_state: _mbstate_t,
    pub _l64a_buf: [::libc::c_char; 8usize],
    pub _signal_buf: [::libc::c_char; 24usize],
    pub _getdate_err: ::libc::c_int,
    pub _mbrlen_state: _mbstate_t,
    pub _mbrtowc_state: _mbstate_t,
    pub _mbsrtowcs_state: _mbstate_t,
    pub _wcrtomb_state: _mbstate_t,
    pub _wcsrtombs_state: _mbstate_t,
    pub _h_errno: ::libc::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _reent__bindgen_ty_1__bindgen_ty_2 {
    pub _nextf: [*mut ::libc::c_uchar; 30usize],
    pub _nmalloc: [::libc::c_uint; 30usize],
}
extern "C" {
    pub static mut _impure_ptr: *mut _reent;
}
extern "C" {
    pub static mut _global_impure_ptr: *const _reent;
}
extern "C" {
    pub fn _reclaim_reent(arg1: *mut _reent);
}
extern "C" {
    pub fn __getreent() -> *mut _reent;
}
pub type locale_t = *mut __locale_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::libc::c_int,
    pub tm_min: ::libc::c_int,
    pub tm_hour: ::libc::c_int,
    pub tm_mday: ::libc::c_int,
    pub tm_mon: ::libc::c_int,
    pub tm_year: ::libc::c_int,
    pub tm_wday: ::libc::c_int,
    pub tm_yday: ::libc::c_int,
    pub tm_isdst: ::libc::c_int,
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn difftime(_time2: time_t, _time1: time_t) -> f64;
}
extern "C" {
    pub fn mktime(_timeptr: *mut tm) -> time_t;
}
extern "C" {
    pub fn time(_timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn asctime(_tblock: *const tm) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn ctime(_time: *const time_t) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn gmtime(_timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(_timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn strftime(
        _s: *mut ::libc::c_char,
        _maxsize: usize,
        _fmt: *const ::libc::c_char,
        _t: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strftime_l(
        _s: *mut ::libc::c_char,
        _maxsize: usize,
        _fmt: *const ::libc::c_char,
        _t: *const tm,
        _l: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn asctime_r(arg1: *const tm, arg2: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn ctime_r(arg1: *const time_t, arg2: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn gmtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub fn _tzset_r(arg1: *mut _reent);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __tzrule_struct {
    pub ch: ::libc::c_char,
    pub m: ::libc::c_int,
    pub n: ::libc::c_int,
    pub d: ::libc::c_int,
    pub s: ::libc::c_int,
    pub change: time_t,
    pub offset: ::libc::c_long,
}
pub type __tzrule_type = __tzrule_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __tzinfo_struct {
    pub __tznorth: ::libc::c_int,
    pub __tzyear: ::libc::c_int,
    pub __tzrule: [__tzrule_type; 2usize],
}
pub type __tzinfo_type = __tzinfo_struct;
extern "C" {
    pub fn __gettzinfo() -> *mut __tzinfo_type;
}
extern "C" {
    pub static mut _timezone: ::libc::c_long;
}
extern "C" {
    pub static mut _daylight: ::libc::c_int;
}
extern "C" {
    pub static mut _tzname: [*mut ::libc::c_char; 2usize];
}
extern "C" {
    pub fn utimes(__path: *const ::libc::c_char, __tvp: *const timeval) -> ::libc::c_int;
}
extern "C" {
    pub fn adjtime(arg1: *const timeval, arg2: *mut timeval) -> ::libc::c_int;
}
extern "C" {
    pub fn futimes(arg1: ::libc::c_int, arg2: *const timeval) -> ::libc::c_int;
}
extern "C" {
    pub fn lutimes(arg1: *const ::libc::c_char, arg2: *const timeval) -> ::libc::c_int;
}
extern "C" {
    pub fn settimeofday(arg1: *const timeval, arg2: *const timezone) -> ::libc::c_int;
}
extern "C" {
    pub fn getitimer(__which: ::libc::c_int, __value: *mut itimerval) -> ::libc::c_int;
}
extern "C" {
    pub fn setitimer(
        __which: ::libc::c_int,
        __value: *const itimerval,
        __ovalue: *mut itimerval,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gettimeofday(__p: *mut timeval, __tz: *mut ::libc::c_void) -> ::libc::c_int;
}
pub type socklen_t = u32;
pub type sa_family_t = u16;
#[repr(C)]
#[derive(Debug)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: __IncompleteArrayField<::libc::c_char>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_family: sa_family_t,
    pub __ss_padding: [::libc::c_char; 26usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linger {
    pub l_onoff: ::libc::c_int,
    pub l_linger: ::libc::c_int,
}
extern "C" {
    pub fn accept(
        sockfd: ::libc::c_int,
        addr: *mut sockaddr,
        addrlen: *mut socklen_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn bind(sockfd: ::libc::c_int, addr: *const sockaddr, addrlen: socklen_t) -> ::libc::c_int;
}
extern "C" {
    pub fn closesocket(sockfd: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn connect(
        sockfd: ::libc::c_int,
        addr: *const sockaddr,
        addrlen: socklen_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn getpeername(
        sockfd: ::libc::c_int,
        addr: *mut sockaddr,
        addrlen: *mut socklen_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn getsockname(
        sockfd: ::libc::c_int,
        addr: *mut sockaddr,
        addrlen: *mut socklen_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn getsockopt(
        sockfd: ::libc::c_int,
        level: ::libc::c_int,
        optname: ::libc::c_int,
        optval: *mut ::libc::c_void,
        optlen: *mut socklen_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn listen(sockfd: ::libc::c_int, backlog: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn recv(
        sockfd: ::libc::c_int,
        buf: *mut ::libc::c_void,
        len: usize,
        flags: ::libc::c_int,
    ) -> isize;
}
extern "C" {
    pub fn recvfrom(
        sockfd: ::libc::c_int,
        buf: *mut ::libc::c_void,
        len: usize,
        flags: ::libc::c_int,
        src_addr: *mut sockaddr,
        addrlen: *mut socklen_t,
    ) -> isize;
}
extern "C" {
    pub fn send(
        sockfd: ::libc::c_int,
        buf: *const ::libc::c_void,
        len: usize,
        flags: ::libc::c_int,
    ) -> isize;
}
extern "C" {
    pub fn sendto(
        sockfd: ::libc::c_int,
        buf: *const ::libc::c_void,
        len: usize,
        flags: ::libc::c_int,
        dest_addr: *const sockaddr,
        addrlen: socklen_t,
    ) -> isize;
}
extern "C" {
    pub fn setsockopt(
        sockfd: ::libc::c_int,
        level: ::libc::c_int,
        optname: ::libc::c_int,
        optval: *const ::libc::c_void,
        optlen: socklen_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn shutdown(sockfd: ::libc::c_int, how: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn socket(
        domain: ::libc::c_int,
        type_: ::libc::c_int,
        protocol: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn sockatmark(sockfd: ::libc::c_int) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_in {
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [::libc::c_uchar; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
pub const NETOPT_MAC_ADDRESS: NetworkOpt = 4100;
pub const NETOPT_ARP_TABLE: NetworkOpt = 12290;
pub const NETOPT_IP_INFO: NetworkOpt = 16387;
pub const NETOPT_IP_MTU: NetworkOpt = 16388;
pub const NETOPT_ROUTING_TABLE: NetworkOpt = 16390;
pub const NETOPT_UDP_NUMBER: NetworkOpt = 32770;
pub const NETOPT_UDP_TABLE: NetworkOpt = 32771;
pub const NETOPT_TCP_NUMBER: NetworkOpt = 36866;
pub const NETOPT_TCP_TABLE: NetworkOpt = 36867;
pub const NETOPT_DNS_TABLE: NetworkOpt = 45059;
pub const NETOPT_DHCP_LEASE_TIME: NetworkOpt = 49153;
pub type NetworkOpt = u32;
#[repr(C)]
pub struct SOCU_ARPTableEntry {
    pub unk0: u32,
    pub ip: in_addr,
    pub mac: [u8; 6usize],
    pub padding: [u8; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SOCU_IPInfo {
    pub ip: in_addr,
    pub netmask: in_addr,
    pub broadcast: in_addr,
}
#[repr(C)]
pub struct SOCU_RoutingTableEntry {
    pub dest_ip: in_addr,
    pub netmask: in_addr,
    pub gateway: in_addr,
    pub flags: u32,
    pub time: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SOCU_UDPTableEntry {
    pub local: sockaddr_storage,
    pub remote: sockaddr_storage,
}
#[repr(C)]
pub struct SOCU_TCPTableEntry {
    pub state: u32,
    pub local: sockaddr_storage,
    pub remote: sockaddr_storage,
}
#[repr(C)]
pub struct SOCU_DNSTableEntry {
    pub family: u32,
    pub ip: in_addr,
    pub padding: [u8; 12usize],
}
extern "C" {
    pub fn socInit(context_addr: *mut u32, context_size: u32) -> Result;
}
extern "C" {
    pub fn socExit() -> Result;
}
extern "C" {
    pub fn gethostid() -> ::libc::c_long;
}
extern "C" {
    pub fn gethostname(name: *mut ::libc::c_char, namelen: usize) -> ::libc::c_int;
}
extern "C" {
    pub fn SOCU_ShutdownSockets() -> ::libc::c_int;
}
extern "C" {
    pub fn SOCU_CloseSockets() -> ::libc::c_int;
}
extern "C" {
    pub fn SOCU_GetNetworkOpt(
        level: ::libc::c_int,
        optname: NetworkOpt,
        optval: *mut ::libc::c_void,
        optlen: *mut socklen_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn SOCU_GetIPInfo(
        ip: *mut in_addr,
        netmask: *mut in_addr,
        broadcast: *mut in_addr,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn SOCU_AddGlobalSocket(sockfd: ::libc::c_int) -> ::libc::c_int;
}
pub const MICU_ENCODING_PCM8: MICU_Encoding = 0;
pub const MICU_ENCODING_PCM16: MICU_Encoding = 1;
pub const MICU_ENCODING_PCM8_SIGNED: MICU_Encoding = 2;
pub const MICU_ENCODING_PCM16_SIGNED: MICU_Encoding = 3;
pub type MICU_Encoding = u32;
pub const MICU_SAMPLE_RATE_32730: MICU_SampleRate = 0;
pub const MICU_SAMPLE_RATE_16360: MICU_SampleRate = 1;
pub const MICU_SAMPLE_RATE_10910: MICU_SampleRate = 2;
pub const MICU_SAMPLE_RATE_8180: MICU_SampleRate = 3;
pub type MICU_SampleRate = u32;
extern "C" {
    pub fn micInit(buffer: *mut u8, bufferSize: u32) -> Result;
}
extern "C" {
    pub fn micExit();
}
extern "C" {
    pub fn micGetSampleDataSize() -> u32;
}
extern "C" {
    pub fn micGetLastSampleOffset() -> u32;
}
extern "C" {
    pub fn MICU_MapSharedMem(size: u32, handle: Handle) -> Result;
}
extern "C" {
    pub fn MICU_UnmapSharedMem() -> Result;
}
extern "C" {
    pub fn MICU_StartSampling(
        encoding: MICU_Encoding,
        sampleRate: MICU_SampleRate,
        offset: u32,
        size: u32,
        loop_: bool,
    ) -> Result;
}
extern "C" {
    pub fn MICU_AdjustSampling(sampleRate: MICU_SampleRate) -> Result;
}
extern "C" {
    pub fn MICU_StopSampling() -> Result;
}
extern "C" {
    pub fn MICU_IsSampling(sampling: *mut bool) -> Result;
}
extern "C" {
    pub fn MICU_GetEventHandle(handle: *mut Handle) -> Result;
}
extern "C" {
    pub fn MICU_SetGain(gain: u8) -> Result;
}
extern "C" {
    pub fn MICU_GetGain(gain: *mut u8) -> Result;
}
extern "C" {
    pub fn MICU_SetPower(power: bool) -> Result;
}
extern "C" {
    pub fn MICU_GetPower(power: *mut bool) -> Result;
}
extern "C" {
    pub fn MICU_SetClamp(clamp: bool) -> Result;
}
extern "C" {
    pub fn MICU_GetClamp(clamp: *mut bool) -> Result;
}
extern "C" {
    pub fn MICU_SetAllowShellClosed(allowShellClosed: bool) -> Result;
}
pub const MVDMODE_COLORFORMATCONV: MVDSTD_Mode = 0;
pub const MVDMODE_VIDEOPROCESSING: MVDSTD_Mode = 1;
pub type MVDSTD_Mode = u32;
pub const MVD_INPUT_YUYV422: MVDSTD_InputFormat = 65537;
pub const MVD_INPUT_H264: MVDSTD_InputFormat = 131073;
pub type MVDSTD_InputFormat = u32;
pub const MVD_OUTPUT_YUYV422: MVDSTD_OutputFormat = 65537;
pub const MVD_OUTPUT_BGR565: MVDSTD_OutputFormat = 262146;
pub const MVD_OUTPUT_RGB565: MVDSTD_OutputFormat = 262148;
pub type MVDSTD_OutputFormat = u32;
#[repr(C)]
pub struct MVDSTD_Config {
    pub input_type: MVDSTD_InputFormat,
    pub unk_x04: u32,
    pub unk_x08: u32,
    pub inwidth: u32,
    pub inheight: u32,
    pub physaddr_colorconv_indata: u32,
    pub physaddr_colorconv_unk0: u32,
    pub physaddr_colorconv_unk1: u32,
    pub physaddr_colorconv_unk2: u32,
    pub physaddr_colorconv_unk3: u32,
    pub unk_x28: [u32; 6usize],
    pub enable_cropping: u32,
    pub input_crop_x_pos: u32,
    pub input_crop_y_pos: u32,
    pub input_crop_height: u32,
    pub input_crop_width: u32,
    pub unk_x54: u32,
    pub output_type: MVDSTD_OutputFormat,
    pub outwidth: u32,
    pub outheight: u32,
    pub physaddr_outdata0: u32,
    pub physaddr_outdata1: u32,
    pub unk_x6c: [u32; 38usize],
    pub flag_x104: u32,
    pub output_x_pos: u32,
    pub output_y_pos: u32,
    pub output_width_override: u32,
    pub output_height_override: u32,
    pub unk_x118: u32,
}
#[repr(C)]
pub struct MVDSTD_ProcessNALUnitOut {
    pub end_vaddr: u32,
    pub end_physaddr: u32,
    pub remaining_size: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MVDSTD_OutputBuffersEntry {
    pub outdata0: *mut ::libc::c_void,
    pub outdata1: *mut ::libc::c_void,
}
#[repr(C)]
pub struct MVDSTD_OutputBuffersEntryList {
    pub total_entries: u32,
    pub entries: [MVDSTD_OutputBuffersEntry; 17usize],
}
#[repr(C)]
pub struct MVDSTD_InitStruct {
    pub cmd5_inval0: s8,
    pub cmd5_inval1: s8,
    pub cmd5_inval2: s8,
    pub cmd5_inval3: u32,
    pub cmd1b_inval: u8,
}
extern "C" {
    pub fn mvdstdInit(
        mode: MVDSTD_Mode,
        input_type: MVDSTD_InputFormat,
        output_type: MVDSTD_OutputFormat,
        size: u32,
        initstruct: *mut MVDSTD_InitStruct,
    ) -> Result;
}
extern "C" {
    pub fn mvdstdExit();
}
extern "C" {
    pub fn mvdstdGenerateDefaultConfig(
        config: *mut MVDSTD_Config,
        input_width: u32,
        input_height: u32,
        output_width: u32,
        output_height: u32,
        vaddr_colorconv_indata: *mut u32,
        vaddr_outdata0: *mut u32,
        vaddr_outdata1: *mut u32,
    );
}
extern "C" {
    pub fn mvdstdConvertImage(config: *mut MVDSTD_Config) -> Result;
}
extern "C" {
    pub fn mvdstdProcessVideoFrame(
        inbuf_vaddr: *mut ::libc::c_void,
        size: usize,
        flag: u32,
        out: *mut MVDSTD_ProcessNALUnitOut,
    ) -> Result;
}
extern "C" {
    pub fn mvdstdRenderVideoFrame(config: *mut MVDSTD_Config, wait: bool) -> Result;
}
extern "C" {
    pub fn MVDSTD_SetConfig(config: *mut MVDSTD_Config) -> Result;
}
extern "C" {
    pub fn mvdstdSetupOutputBuffers(
        entrylist: *mut MVDSTD_OutputBuffersEntryList,
        bufsize: u32,
    ) -> Result;
}
extern "C" {
    pub fn mvdstdOverrideOutputBuffers(
        cur_outdata0: *mut ::libc::c_void,
        cur_outdata1: *mut ::libc::c_void,
        new_outdata0: *mut ::libc::c_void,
        new_outdata1: *mut ::libc::c_void,
    ) -> Result;
}
pub const NFC_OpType_1: NFC_OpType = 1;
pub const NFC_OpType_NFCTag: NFC_OpType = 2;
pub const NFC_OpType_RawNFC: NFC_OpType = 3;
pub type NFC_OpType = u32;
pub const NFC_TagState_Uninitialized: NFC_TagState = 0;
pub const NFC_TagState_ScanningStopped: NFC_TagState = 1;
pub const NFC_TagState_Scanning: NFC_TagState = 2;
pub const NFC_TagState_InRange: NFC_TagState = 3;
pub const NFC_TagState_OutOfRange: NFC_TagState = 4;
pub const NFC_TagState_DataReady: NFC_TagState = 5;
pub type NFC_TagState = u32;
pub const NFC_amiiboFlag_Setup: _bindgen_ty_24 = 16;
pub const NFC_amiiboFlag_AppDataSetup: _bindgen_ty_24 = 32;
pub type _bindgen_ty_24 = u32;
#[repr(C)]
pub struct NFC_TagInfo {
    pub id_offset_size: u16,
    pub unk_x2: u8,
    pub unk_x3: u8,
    pub id: [u8; 40usize],
}
#[repr(C)]
pub struct NFC_AmiiboSettings {
    pub mii: [u8; 96usize],
    pub nickname: [u16; 11usize],
    pub flags: u8,
    pub countrycodeid: u8,
    pub setupdate_year: u16,
    pub setupdate_month: u8,
    pub setupdate_day: u8,
    pub unk_x7c: [u8; 44usize],
}
#[repr(C)]
pub struct NFC_AmiiboConfig {
    pub lastwritedate_year: u16,
    pub lastwritedate_month: u8,
    pub lastwritedate_day: u8,
    pub write_counter: u16,
    pub characterID: [u8; 3usize],
    pub series: u8,
    pub amiiboID: u16,
    pub type_: u8,
    pub pagex4_byte3: u8,
    pub appdata_size: u16,
    pub zeros: [u8; 48usize],
}
#[repr(C)]
pub struct NFC_AppDataInitStruct {
    pub data_x0: [u8; 12usize],
    pub data_xc: [u8; 48usize],
}
#[repr(C)]
pub struct NFC_AppDataWriteStruct {
    pub id: [u8; 10usize],
    pub id_size: u8,
    pub unused_xb: [u8; 21usize],
}
extern "C" {
    pub fn nfcInit(type_: NFC_OpType) -> Result;
}
extern "C" {
    pub fn nfcExit();
}
extern "C" {
    pub fn nfcGetSessionHandle() -> Handle;
}
extern "C" {
    pub fn nfcStartScanning(inval: u16) -> Result;
}
extern "C" {
    pub fn nfcStopScanning();
}
extern "C" {
    pub fn nfcLoadAmiiboData() -> Result;
}
extern "C" {
    pub fn nfcResetTagScanState() -> Result;
}
extern "C" {
    pub fn nfcUpdateStoredAmiiboData() -> Result;
}
extern "C" {
    pub fn nfcGetTagState(state: *mut NFC_TagState) -> Result;
}
extern "C" {
    pub fn nfcGetTagInfo(out: *mut NFC_TagInfo) -> Result;
}
extern "C" {
    pub fn nfcOpenAppData(amiibo_appid: u32) -> Result;
}
extern "C" {
    pub fn nfcInitializeWriteAppData(
        amiibo_appid: u32,
        buf: *const ::libc::c_void,
        size: usize,
    ) -> Result;
}
extern "C" {
    pub fn nfcReadAppData(buf: *mut ::libc::c_void, size: usize) -> Result;
}
extern "C" {
    pub fn nfcWriteAppData(
        buf: *const ::libc::c_void,
        size: usize,
        taginfo: *mut NFC_TagInfo,
    ) -> Result;
}
extern "C" {
    pub fn nfcGetAmiiboSettings(out: *mut NFC_AmiiboSettings) -> Result;
}
extern "C" {
    pub fn nfcGetAmiiboConfig(out: *mut NFC_AmiiboConfig) -> Result;
}
extern "C" {
    pub fn nfcStartOtherTagScanning(unk0: u16, unk1: u32) -> Result;
}
extern "C" {
    pub fn nfcSendTagCommand(
        inbuf: *const ::libc::c_void,
        insize: usize,
        outbuf: *mut ::libc::c_void,
        outsize: usize,
        actual_transfer_size: *mut usize,
        microseconds: u64,
    ) -> Result;
}
extern "C" {
    pub fn nfcCmd21() -> Result;
}
extern "C" {
    pub fn nfcCmd22() -> Result;
}
#[repr(C)]
pub struct NotificationHeader {
    pub dataSet: bool,
    pub unread: bool,
    pub enableJPEG: bool,
    pub isSpotPass: bool,
    pub isOptedOut: bool,
    pub unkData: [u8; 3usize],
    pub processID: u64,
    pub unkData2: [u8; 8usize],
    pub jumpParam: u64,
    pub unkData3: [u8; 8usize],
    pub time: u64,
    pub title: [u16; 32usize],
}
extern "C" {
    pub fn newsInit() -> Result;
}
extern "C" {
    pub fn newsExit();
}
extern "C" {
    pub fn NEWS_AddNotification(
        title: *const u16,
        titleLength: u32,
        message: *const u16,
        messageLength: u32,
        imageData: *const ::libc::c_void,
        imageSize: u32,
        jpeg: bool,
    ) -> Result;
}
extern "C" {
    pub fn NEWS_GetTotalNotifications(num: *mut u32) -> Result;
}
extern "C" {
    pub fn NEWS_SetNotificationHeader(news_id: u32, header: *const NotificationHeader) -> Result;
}
extern "C" {
    pub fn NEWS_GetNotificationHeader(news_id: u32, header: *mut NotificationHeader) -> Result;
}
extern "C" {
    pub fn NEWS_SetNotificationMessage(news_id: u32, message: *const u16, size: u32) -> Result;
}
extern "C" {
    pub fn NEWS_GetNotificationMessage(news_id: u32, message: *mut u16, size: *mut u32) -> Result;
}
extern "C" {
    pub fn NEWS_SetNotificationImage(
        news_id: u32,
        buffer: *const ::libc::c_void,
        size: u32,
    ) -> Result;
}
extern "C" {
    pub fn NEWS_GetNotificationImage(
        news_id: u32,
        buffer: *mut ::libc::c_void,
        size: *mut u32,
    ) -> Result;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QTM_HeadTrackingInfoCoord {
    pub x: f32,
    pub y: f32,
}
#[repr(C)]
pub struct QTM_HeadTrackingInfo {
    pub flags: [u8; 5usize],
    pub padding: [u8; 3usize],
    pub floatdata_x08: f32,
    pub coords0: [QTM_HeadTrackingInfoCoord; 4usize],
    pub unk_x2c: [u32; 5usize],
}
extern "C" {
    pub fn qtmInit() -> Result;
}
extern "C" {
    pub fn qtmExit();
}
extern "C" {
    pub fn qtmCheckInitialized() -> bool;
}
extern "C" {
    pub fn qtmCheckHeadFullyDetected(info: *mut QTM_HeadTrackingInfo) -> bool;
}
extern "C" {
    pub fn qtmConvertCoordToScreen(
        coord: *mut QTM_HeadTrackingInfoCoord,
        screen_width: *mut f32,
        screen_height: *mut f32,
        x: *mut u32,
        y: *mut u32,
    ) -> Result;
}
extern "C" {
    pub fn QTM_GetHeadTrackingInfo(val: u64, out: *mut QTM_HeadTrackingInfo) -> Result;
}
extern "C" {
    pub fn srvPmInit() -> Result;
}
extern "C" {
    pub fn srvPmExit();
}
extern "C" {
    pub fn srvPmGetSessionHandle() -> *mut Handle;
}
extern "C" {
    pub fn SRVPM_PublishToProcess(notificationId: u32, process: Handle) -> Result;
}
extern "C" {
    pub fn SRVPM_PublishToAll(notificationId: u32) -> Result;
}
extern "C" {
    pub fn SRVPM_RegisterProcess(
        pid: u32,
        count: u32,
        serviceAccessControlList: *const [::libc::c_char; 8usize],
    ) -> Result;
}
extern "C" {
    pub fn SRVPM_UnregisterProcess(pid: u32) -> Result;
}
extern "C" {
    pub fn loaderInit() -> Result;
}
extern "C" {
    pub fn loaderExit();
}
extern "C" {
    pub fn LOADER_LoadProcess(process: *mut Handle, programHandle: u64) -> Result;
}
extern "C" {
    pub fn LOADER_RegisterProgram(
        programHandle: *mut u64,
        titleId: u64,
        mediaType: FS_MediaType,
        updateTitleId: u64,
        updateMediaType: FS_MediaType,
    ) -> Result;
}
extern "C" {
    pub fn LOADER_UnregisterProgram(programHandle: u64) -> Result;
}
extern "C" {
    pub fn LOADER_GetProgramInfo(exheaderInfo: *mut ExHeader_Info, programHandle: u64) -> Result;
}
pub const LED_NORMAL: powerLedState = 1;
pub const LED_SLEEP_MODE: powerLedState = 2;
pub const LED_OFF: powerLedState = 3;
pub const LED_RED: powerLedState = 4;
pub const LED_BLUE: powerLedState = 5;
pub const LED_BLINK_RED: powerLedState = 6;
pub type powerLedState = u32;
extern "C" {
    pub fn mcuHwcInit() -> Result;
}
extern "C" {
    pub fn mcuHwcExit();
}
extern "C" {
    pub fn MCUHWC_ReadRegister(reg: u8, data: *mut ::libc::c_void, size: u32) -> Result;
}
extern "C" {
    pub fn MCUHWC_WriteRegister(reg: u8, data: *const ::libc::c_void, size: u32) -> Result;
}
extern "C" {
    pub fn MCUHWC_GetBatteryVoltage(voltage: *mut u8) -> Result;
}
extern "C" {
    pub fn MCUHWC_GetBatteryLevel(level: *mut u8) -> Result;
}
extern "C" {
    pub fn MCUHWC_GetSoundSliderLevel(level: *mut u8) -> Result;
}
extern "C" {
    pub fn MCUHWC_SetWifiLedState(state: bool) -> Result;
}
extern "C" {
    pub fn MCUHWC_SetPowerLedState(state: powerLedState) -> Result;
}
extern "C" {
    pub fn MCUHWC_Get3dSliderLevel(level: *mut u8) -> Result;
}
extern "C" {
    pub fn MCUHWC_GetFwVerHigh(out: *mut u8) -> Result;
}
extern "C" {
    pub fn MCUHWC_GetFwVerLow(out: *mut u8) -> Result;
}
extern "C" {
    pub fn hbInit() -> Result;
}
extern "C" {
    pub fn hbExit();
}
extern "C" {
    pub fn HB_FlushInvalidateCache() -> Result;
}
extern "C" {
    pub fn HB_GetBootloaderAddresses(
        load3dsx: *mut *mut ::libc::c_void,
        setArgv: *mut *mut ::libc::c_void,
    ) -> Result;
}
extern "C" {
    pub fn HB_ReprotectMemory(
        addr: *mut u32,
        pages: u32,
        mode: u32,
        reprotectedPages: *mut u32,
    ) -> Result;
}
pub const GX_TRANSFER_FMT_RGBA8: GX_TRANSFER_FORMAT = 0;
pub const GX_TRANSFER_FMT_RGB8: GX_TRANSFER_FORMAT = 1;
pub const GX_TRANSFER_FMT_RGB565: GX_TRANSFER_FORMAT = 2;
pub const GX_TRANSFER_FMT_RGB5A1: GX_TRANSFER_FORMAT = 3;
pub const GX_TRANSFER_FMT_RGBA4: GX_TRANSFER_FORMAT = 4;
pub type GX_TRANSFER_FORMAT = u32;
pub const GX_TRANSFER_SCALE_NO: GX_TRANSFER_SCALE = 0;
pub const GX_TRANSFER_SCALE_X: GX_TRANSFER_SCALE = 1;
pub const GX_TRANSFER_SCALE_XY: GX_TRANSFER_SCALE = 2;
pub type GX_TRANSFER_SCALE = u32;
pub const GX_FILL_TRIGGER: GX_FILL_CONTROL = 1;
pub const GX_FILL_FINISHED: GX_FILL_CONTROL = 2;
pub const GX_FILL_16BIT_DEPTH: GX_FILL_CONTROL = 0;
pub const GX_FILL_24BIT_DEPTH: GX_FILL_CONTROL = 256;
pub const GX_FILL_32BIT_DEPTH: GX_FILL_CONTROL = 512;
pub type GX_FILL_CONTROL = u32;
extern "C" {
    pub static mut gxCmdBuf: *mut u32;
}
#[repr(C)]
pub struct gxCmdEntry_s {
    pub data: __BindgenUnionField<[u32; 8usize]>,
    pub __bindgen_anon_1: __BindgenUnionField<gxCmdEntry_s__bindgen_ty_1>,
    pub bindgen_union_field: [u32; 8usize],
}
#[repr(C)]
pub struct gxCmdEntry_s__bindgen_ty_1 {
    pub type_: u8,
    pub unk1: u8,
    pub unk2: u8,
    pub unk3: u8,
    pub args: [u32; 7usize],
}
#[repr(C)]
pub struct tag_gxCmdQueue_s {
    pub entries: *mut gxCmdEntry_s,
    pub maxEntries: u16,
    pub numEntries: u16,
    pub curEntry: u16,
    pub lastEntry: u16,
    pub callback: ::core::option::Option<unsafe extern "C" fn(arg1: *mut tag_gxCmdQueue_s)>,
    pub user: *mut ::libc::c_void,
}
pub type gxCmdQueue_s = tag_gxCmdQueue_s;
extern "C" {
    pub fn gxCmdQueueClear(queue: *mut gxCmdQueue_s);
}
extern "C" {
    pub fn gxCmdQueueAdd(queue: *mut gxCmdQueue_s, entry: *const gxCmdEntry_s);
}
extern "C" {
    pub fn gxCmdQueueRun(queue: *mut gxCmdQueue_s);
}
extern "C" {
    pub fn gxCmdQueueStop(queue: *mut gxCmdQueue_s);
}
extern "C" {
    pub fn gxCmdQueueWait(queue: *mut gxCmdQueue_s, timeout: s64) -> bool;
}
extern "C" {
    pub fn GX_BindQueue(queue: *mut gxCmdQueue_s);
}
extern "C" {
    pub fn GX_RequestDma(src: *mut u32, dst: *mut u32, length: u32) -> Result;
}
extern "C" {
    pub fn GX_ProcessCommandList(buf0a: *mut u32, buf0s: u32, flags: u8) -> Result;
}
extern "C" {
    pub fn GX_MemoryFill(
        buf0a: *mut u32,
        buf0v: u32,
        buf0e: *mut u32,
        control0: u16,
        buf1a: *mut u32,
        buf1v: u32,
        buf1e: *mut u32,
        control1: u16,
    ) -> Result;
}
extern "C" {
    pub fn GX_DisplayTransfer(
        inadr: *mut u32,
        indim: u32,
        outadr: *mut u32,
        outdim: u32,
        flags: u32,
    ) -> Result;
}
extern "C" {
    pub fn GX_TextureCopy(
        inadr: *mut u32,
        indim: u32,
        outadr: *mut u32,
        outdim: u32,
        size: u32,
        flags: u32,
    ) -> Result;
}
extern "C" {
    pub fn GX_FlushCacheRegions(
        buf0a: *mut u32,
        buf0s: u32,
        buf1a: *mut u32,
        buf1s: u32,
        buf2a: *mut u32,
        buf2s: u32,
    ) -> Result;
}
pub const GPU_NEAREST: GPU_TEXTURE_FILTER_PARAM = 0;
pub const GPU_LINEAR: GPU_TEXTURE_FILTER_PARAM = 1;
pub type GPU_TEXTURE_FILTER_PARAM = u32;
pub const GPU_CLAMP_TO_EDGE: GPU_TEXTURE_WRAP_PARAM = 0;
pub const GPU_CLAMP_TO_BORDER: GPU_TEXTURE_WRAP_PARAM = 1;
pub const GPU_REPEAT: GPU_TEXTURE_WRAP_PARAM = 2;
pub const GPU_MIRRORED_REPEAT: GPU_TEXTURE_WRAP_PARAM = 3;
pub type GPU_TEXTURE_WRAP_PARAM = u32;
pub const GPU_TEX_2D: GPU_TEXTURE_MODE_PARAM = 0;
pub const GPU_TEX_CUBE_MAP: GPU_TEXTURE_MODE_PARAM = 1;
pub const GPU_TEX_SHADOW_2D: GPU_TEXTURE_MODE_PARAM = 2;
pub const GPU_TEX_PROJECTION: GPU_TEXTURE_MODE_PARAM = 3;
pub const GPU_TEX_SHADOW_CUBE: GPU_TEXTURE_MODE_PARAM = 4;
pub const GPU_TEX_DISABLED: GPU_TEXTURE_MODE_PARAM = 5;
pub type GPU_TEXTURE_MODE_PARAM = u32;
pub const GPU_TEXUNIT0: GPU_TEXUNIT = 1;
pub const GPU_TEXUNIT1: GPU_TEXUNIT = 2;
pub const GPU_TEXUNIT2: GPU_TEXUNIT = 4;
pub type GPU_TEXUNIT = u32;
pub const GPU_RGBA8: GPU_TEXCOLOR = 0;
pub const GPU_RGB8: GPU_TEXCOLOR = 1;
pub const GPU_RGBA5551: GPU_TEXCOLOR = 2;
pub const GPU_RGB565: GPU_TEXCOLOR = 3;
pub const GPU_RGBA4: GPU_TEXCOLOR = 4;
pub const GPU_LA8: GPU_TEXCOLOR = 5;
pub const GPU_HILO8: GPU_TEXCOLOR = 6;
pub const GPU_L8: GPU_TEXCOLOR = 7;
pub const GPU_A8: GPU_TEXCOLOR = 8;
pub const GPU_LA4: GPU_TEXCOLOR = 9;
pub const GPU_L4: GPU_TEXCOLOR = 10;
pub const GPU_A4: GPU_TEXCOLOR = 11;
pub const GPU_ETC1: GPU_TEXCOLOR = 12;
pub const GPU_ETC1A4: GPU_TEXCOLOR = 13;
pub type GPU_TEXCOLOR = u32;
pub const GPU_TEXFACE_2D: GPU_TEXFACE = 0;
pub const GPU_POSITIVE_X: GPU_TEXFACE = 0;
pub const GPU_NEGATIVE_X: GPU_TEXFACE = 1;
pub const GPU_POSITIVE_Y: GPU_TEXFACE = 2;
pub const GPU_NEGATIVE_Y: GPU_TEXFACE = 3;
pub const GPU_POSITIVE_Z: GPU_TEXFACE = 4;
pub const GPU_NEGATIVE_Z: GPU_TEXFACE = 5;
pub type GPU_TEXFACE = u32;
pub const GPU_PT_CLAMP_TO_ZERO: GPU_PROCTEX_CLAMP = 0;
pub const GPU_PT_CLAMP_TO_EDGE: GPU_PROCTEX_CLAMP = 1;
pub const GPU_PT_REPEAT: GPU_PROCTEX_CLAMP = 2;
pub const GPU_PT_MIRRORED_REPEAT: GPU_PROCTEX_CLAMP = 3;
pub const GPU_PT_PULSE: GPU_PROCTEX_CLAMP = 4;
pub type GPU_PROCTEX_CLAMP = u32;
pub const GPU_PT_U: GPU_PROCTEX_MAPFUNC = 0;
pub const GPU_PT_U2: GPU_PROCTEX_MAPFUNC = 1;
pub const GPU_PT_V: GPU_PROCTEX_MAPFUNC = 2;
pub const GPU_PT_V2: GPU_PROCTEX_MAPFUNC = 3;
pub const GPU_PT_ADD: GPU_PROCTEX_MAPFUNC = 4;
pub const GPU_PT_ADD2: GPU_PROCTEX_MAPFUNC = 5;
pub const GPU_PT_SQRT2: GPU_PROCTEX_MAPFUNC = 6;
pub const GPU_PT_MIN: GPU_PROCTEX_MAPFUNC = 7;
pub const GPU_PT_MAX: GPU_PROCTEX_MAPFUNC = 8;
pub const GPU_PT_RMAX: GPU_PROCTEX_MAPFUNC = 9;
pub type GPU_PROCTEX_MAPFUNC = u32;
pub const GPU_PT_NONE: GPU_PROCTEX_SHIFT = 0;
pub const GPU_PT_ODD: GPU_PROCTEX_SHIFT = 1;
pub const GPU_PT_EVEN: GPU_PROCTEX_SHIFT = 2;
pub type GPU_PROCTEX_SHIFT = u32;
pub const GPU_PT_NEAREST: GPU_PROCTEX_FILTER = 0;
pub const GPU_PT_LINEAR: GPU_PROCTEX_FILTER = 1;
pub const GPU_PT_NEAREST_MIP_NEAREST: GPU_PROCTEX_FILTER = 2;
pub const GPU_PT_LINEAR_MIP_NEAREST: GPU_PROCTEX_FILTER = 3;
pub const GPU_PT_NEAREST_MIP_LINEAR: GPU_PROCTEX_FILTER = 4;
pub const GPU_PT_LINEAR_MIP_LINEAR: GPU_PROCTEX_FILTER = 5;
pub type GPU_PROCTEX_FILTER = u32;
pub const GPU_LUT_NOISE: GPU_PROCTEX_LUTID = 0;
pub const GPU_LUT_RGBMAP: GPU_PROCTEX_LUTID = 2;
pub const GPU_LUT_ALPHAMAP: GPU_PROCTEX_LUTID = 3;
pub const GPU_LUT_COLOR: GPU_PROCTEX_LUTID = 4;
pub const GPU_LUT_COLORDIF: GPU_PROCTEX_LUTID = 5;
pub type GPU_PROCTEX_LUTID = u32;
pub const GPU_RB_RGBA8: GPU_COLORBUF = 0;
pub const GPU_RB_RGB8: GPU_COLORBUF = 1;
pub const GPU_RB_RGBA5551: GPU_COLORBUF = 2;
pub const GPU_RB_RGB565: GPU_COLORBUF = 3;
pub const GPU_RB_RGBA4: GPU_COLORBUF = 4;
pub type GPU_COLORBUF = u32;
pub const GPU_RB_DEPTH16: GPU_DEPTHBUF = 0;
pub const GPU_RB_DEPTH24: GPU_DEPTHBUF = 2;
pub const GPU_RB_DEPTH24_STENCIL8: GPU_DEPTHBUF = 3;
pub type GPU_DEPTHBUF = u32;
pub const GPU_NEVER: GPU_TESTFUNC = 0;
pub const GPU_ALWAYS: GPU_TESTFUNC = 1;
pub const GPU_EQUAL: GPU_TESTFUNC = 2;
pub const GPU_NOTEQUAL: GPU_TESTFUNC = 3;
pub const GPU_LESS: GPU_TESTFUNC = 4;
pub const GPU_LEQUAL: GPU_TESTFUNC = 5;
pub const GPU_GREATER: GPU_TESTFUNC = 6;
pub const GPU_GEQUAL: GPU_TESTFUNC = 7;
pub type GPU_TESTFUNC = u32;
pub const GPU_EARLYDEPTH_GEQUAL: GPU_EARLYDEPTHFUNC = 0;
pub const GPU_EARLYDEPTH_GREATER: GPU_EARLYDEPTHFUNC = 1;
pub const GPU_EARLYDEPTH_LEQUAL: GPU_EARLYDEPTHFUNC = 2;
pub const GPU_EARLYDEPTH_LESS: GPU_EARLYDEPTHFUNC = 3;
pub type GPU_EARLYDEPTHFUNC = u32;
pub const GPU_SCISSOR_DISABLE: GPU_SCISSORMODE = 0;
pub const GPU_SCISSOR_INVERT: GPU_SCISSORMODE = 1;
pub const GPU_SCISSOR_NORMAL: GPU_SCISSORMODE = 3;
pub type GPU_SCISSORMODE = u32;
pub const GPU_STENCIL_KEEP: GPU_STENCILOP = 0;
pub const GPU_STENCIL_ZERO: GPU_STENCILOP = 1;
pub const GPU_STENCIL_REPLACE: GPU_STENCILOP = 2;
pub const GPU_STENCIL_INCR: GPU_STENCILOP = 3;
pub const GPU_STENCIL_DECR: GPU_STENCILOP = 4;
pub const GPU_STENCIL_INVERT: GPU_STENCILOP = 5;
pub const GPU_STENCIL_INCR_WRAP: GPU_STENCILOP = 6;
pub const GPU_STENCIL_DECR_WRAP: GPU_STENCILOP = 7;
pub type GPU_STENCILOP = u32;
pub const GPU_WRITE_RED: GPU_WRITEMASK = 1;
pub const GPU_WRITE_GREEN: GPU_WRITEMASK = 2;
pub const GPU_WRITE_BLUE: GPU_WRITEMASK = 4;
pub const GPU_WRITE_ALPHA: GPU_WRITEMASK = 8;
pub const GPU_WRITE_DEPTH: GPU_WRITEMASK = 16;
pub const GPU_WRITE_COLOR: GPU_WRITEMASK = 15;
pub const GPU_WRITE_ALL: GPU_WRITEMASK = 31;
pub type GPU_WRITEMASK = u32;
pub const GPU_BLEND_ADD: GPU_BLENDEQUATION = 0;
pub const GPU_BLEND_SUBTRACT: GPU_BLENDEQUATION = 1;
pub const GPU_BLEND_REVERSE_SUBTRACT: GPU_BLENDEQUATION = 2;
pub const GPU_BLEND_MIN: GPU_BLENDEQUATION = 3;
pub const GPU_BLEND_MAX: GPU_BLENDEQUATION = 4;
pub type GPU_BLENDEQUATION = u32;
pub const GPU_ZERO: GPU_BLENDFACTOR = 0;
pub const GPU_ONE: GPU_BLENDFACTOR = 1;
pub const GPU_SRC_COLOR: GPU_BLENDFACTOR = 2;
pub const GPU_ONE_MINUS_SRC_COLOR: GPU_BLENDFACTOR = 3;
pub const GPU_DST_COLOR: GPU_BLENDFACTOR = 4;
pub const GPU_ONE_MINUS_DST_COLOR: GPU_BLENDFACTOR = 5;
pub const GPU_SRC_ALPHA: GPU_BLENDFACTOR = 6;
pub const GPU_ONE_MINUS_SRC_ALPHA: GPU_BLENDFACTOR = 7;
pub const GPU_DST_ALPHA: GPU_BLENDFACTOR = 8;
pub const GPU_ONE_MINUS_DST_ALPHA: GPU_BLENDFACTOR = 9;
pub const GPU_CONSTANT_COLOR: GPU_BLENDFACTOR = 10;
pub const GPU_ONE_MINUS_CONSTANT_COLOR: GPU_BLENDFACTOR = 11;
pub const GPU_CONSTANT_ALPHA: GPU_BLENDFACTOR = 12;
pub const GPU_ONE_MINUS_CONSTANT_ALPHA: GPU_BLENDFACTOR = 13;
pub const GPU_SRC_ALPHA_SATURATE: GPU_BLENDFACTOR = 14;
pub type GPU_BLENDFACTOR = u32;
pub const GPU_LOGICOP_CLEAR: GPU_LOGICOP = 0;
pub const GPU_LOGICOP_AND: GPU_LOGICOP = 1;
pub const GPU_LOGICOP_AND_REVERSE: GPU_LOGICOP = 2;
pub const GPU_LOGICOP_COPY: GPU_LOGICOP = 3;
pub const GPU_LOGICOP_SET: GPU_LOGICOP = 4;
pub const GPU_LOGICOP_COPY_INVERTED: GPU_LOGICOP = 5;
pub const GPU_LOGICOP_NOOP: GPU_LOGICOP = 6;
pub const GPU_LOGICOP_INVERT: GPU_LOGICOP = 7;
pub const GPU_LOGICOP_NAND: GPU_LOGICOP = 8;
pub const GPU_LOGICOP_OR: GPU_LOGICOP = 9;
pub const GPU_LOGICOP_NOR: GPU_LOGICOP = 10;
pub const GPU_LOGICOP_XOR: GPU_LOGICOP = 11;
pub const GPU_LOGICOP_EQUIV: GPU_LOGICOP = 12;
pub const GPU_LOGICOP_AND_INVERTED: GPU_LOGICOP = 13;
pub const GPU_LOGICOP_OR_REVERSE: GPU_LOGICOP = 14;
pub const GPU_LOGICOP_OR_INVERTED: GPU_LOGICOP = 15;
pub type GPU_LOGICOP = u32;
pub const GPU_FRAGOPMODE_GL: GPU_FRAGOPMODE = 0;
pub const GPU_FRAGOPMODE_GAS_ACC: GPU_FRAGOPMODE = 1;
pub const GPU_FRAGOPMODE_SHADOW: GPU_FRAGOPMODE = 3;
pub type GPU_FRAGOPMODE = u32;
pub const GPU_BYTE: GPU_FORMATS = 0;
pub const GPU_UNSIGNED_BYTE: GPU_FORMATS = 1;
pub const GPU_SHORT: GPU_FORMATS = 2;
pub const GPU_FLOAT: GPU_FORMATS = 3;
pub type GPU_FORMATS = u32;
pub const GPU_CULL_NONE: GPU_CULLMODE = 0;
pub const GPU_CULL_FRONT_CCW: GPU_CULLMODE = 1;
pub const GPU_CULL_BACK_CCW: GPU_CULLMODE = 2;
pub type GPU_CULLMODE = u32;
pub const GPU_PRIMARY_COLOR: GPU_TEVSRC = 0;
pub const GPU_FRAGMENT_PRIMARY_COLOR: GPU_TEVSRC = 1;
pub const GPU_FRAGMENT_SECONDARY_COLOR: GPU_TEVSRC = 2;
pub const GPU_TEXTURE0: GPU_TEVSRC = 3;
pub const GPU_TEXTURE1: GPU_TEVSRC = 4;
pub const GPU_TEXTURE2: GPU_TEVSRC = 5;
pub const GPU_TEXTURE3: GPU_TEVSRC = 6;
pub const GPU_PREVIOUS_BUFFER: GPU_TEVSRC = 13;
pub const GPU_CONSTANT: GPU_TEVSRC = 14;
pub const GPU_PREVIOUS: GPU_TEVSRC = 15;
pub type GPU_TEVSRC = u32;
pub const GPU_TEVOP_RGB_SRC_COLOR: GPU_TEVOP_RGB = 0;
pub const GPU_TEVOP_RGB_ONE_MINUS_SRC_COLOR: GPU_TEVOP_RGB = 1;
pub const GPU_TEVOP_RGB_SRC_ALPHA: GPU_TEVOP_RGB = 2;
pub const GPU_TEVOP_RGB_ONE_MINUS_SRC_ALPHA: GPU_TEVOP_RGB = 3;
pub const GPU_TEVOP_RGB_SRC_R: GPU_TEVOP_RGB = 4;
pub const GPU_TEVOP_RGB_ONE_MINUS_SRC_R: GPU_TEVOP_RGB = 5;
pub const GPU_TEVOP_RGB_0x06: GPU_TEVOP_RGB = 6;
pub const GPU_TEVOP_RGB_0x07: GPU_TEVOP_RGB = 7;
pub const GPU_TEVOP_RGB_SRC_G: GPU_TEVOP_RGB = 8;
pub const GPU_TEVOP_RGB_ONE_MINUS_SRC_G: GPU_TEVOP_RGB = 9;
pub const GPU_TEVOP_RGB_0x0A: GPU_TEVOP_RGB = 10;
pub const GPU_TEVOP_RGB_0x0B: GPU_TEVOP_RGB = 11;
pub const GPU_TEVOP_RGB_SRC_B: GPU_TEVOP_RGB = 12;
pub const GPU_TEVOP_RGB_ONE_MINUS_SRC_B: GPU_TEVOP_RGB = 13;
pub const GPU_TEVOP_RGB_0x0E: GPU_TEVOP_RGB = 14;
pub const GPU_TEVOP_RGB_0x0F: GPU_TEVOP_RGB = 15;
pub type GPU_TEVOP_RGB = u32;
pub const GPU_TEVOP_A_SRC_ALPHA: GPU_TEVOP_A = 0;
pub const GPU_TEVOP_A_ONE_MINUS_SRC_ALPHA: GPU_TEVOP_A = 1;
pub const GPU_TEVOP_A_SRC_R: GPU_TEVOP_A = 2;
pub const GPU_TEVOP_A_ONE_MINUS_SRC_R: GPU_TEVOP_A = 3;
pub const GPU_TEVOP_A_SRC_G: GPU_TEVOP_A = 4;
pub const GPU_TEVOP_A_ONE_MINUS_SRC_G: GPU_TEVOP_A = 5;
pub const GPU_TEVOP_A_SRC_B: GPU_TEVOP_A = 6;
pub const GPU_TEVOP_A_ONE_MINUS_SRC_B: GPU_TEVOP_A = 7;
pub type GPU_TEVOP_A = u32;
pub const GPU_REPLACE: GPU_COMBINEFUNC = 0;
pub const GPU_MODULATE: GPU_COMBINEFUNC = 1;
pub const GPU_ADD: GPU_COMBINEFUNC = 2;
pub const GPU_ADD_SIGNED: GPU_COMBINEFUNC = 3;
pub const GPU_INTERPOLATE: GPU_COMBINEFUNC = 4;
pub const GPU_SUBTRACT: GPU_COMBINEFUNC = 5;
pub const GPU_DOT3_RGB: GPU_COMBINEFUNC = 6;
pub const GPU_MULTIPLY_ADD: GPU_COMBINEFUNC = 8;
pub const GPU_ADD_MULTIPLY: GPU_COMBINEFUNC = 9;
pub type GPU_COMBINEFUNC = u32;
pub const GPU_TEVSCALE_1: GPU_TEVSCALE = 0;
pub const GPU_TEVSCALE_2: GPU_TEVSCALE = 1;
pub const GPU_TEVSCALE_4: GPU_TEVSCALE = 2;
pub type GPU_TEVSCALE = u32;
pub const GPU_NO_FRESNEL: GPU_FRESNELSEL = 0;
pub const GPU_PRI_ALPHA_FRESNEL: GPU_FRESNELSEL = 1;
pub const GPU_SEC_ALPHA_FRESNEL: GPU_FRESNELSEL = 2;
pub const GPU_PRI_SEC_ALPHA_FRESNEL: GPU_FRESNELSEL = 3;
pub type GPU_FRESNELSEL = u32;
pub const GPU_BUMP_NOT_USED: GPU_BUMPMODE = 0;
pub const GPU_BUMP_AS_BUMP: GPU_BUMPMODE = 1;
pub const GPU_BUMP_AS_TANG: GPU_BUMPMODE = 2;
pub type GPU_BUMPMODE = u32;
pub const GPU_LUT_D0: GPU_LIGHTLUTID = 0;
pub const GPU_LUT_D1: GPU_LIGHTLUTID = 1;
pub const GPU_LUT_SP: GPU_LIGHTLUTID = 2;
pub const GPU_LUT_FR: GPU_LIGHTLUTID = 3;
pub const GPU_LUT_RB: GPU_LIGHTLUTID = 4;
pub const GPU_LUT_RG: GPU_LIGHTLUTID = 5;
pub const GPU_LUT_RR: GPU_LIGHTLUTID = 6;
pub const GPU_LUT_DA: GPU_LIGHTLUTID = 7;
pub type GPU_LIGHTLUTID = u32;
pub const GPU_LUTINPUT_NH: GPU_LIGHTLUTINPUT = 0;
pub const GPU_LUTINPUT_VH: GPU_LIGHTLUTINPUT = 1;
pub const GPU_LUTINPUT_NV: GPU_LIGHTLUTINPUT = 2;
pub const GPU_LUTINPUT_LN: GPU_LIGHTLUTINPUT = 3;
pub const GPU_LUTINPUT_SP: GPU_LIGHTLUTINPUT = 4;
pub const GPU_LUTINPUT_CP: GPU_LIGHTLUTINPUT = 5;
pub type GPU_LIGHTLUTINPUT = u32;
pub const GPU_LUTSCALER_1x: GPU_LIGHTLUTSCALER = 0;
pub const GPU_LUTSCALER_2x: GPU_LIGHTLUTSCALER = 1;
pub const GPU_LUTSCALER_4x: GPU_LIGHTLUTSCALER = 2;
pub const GPU_LUTSCALER_8x: GPU_LIGHTLUTSCALER = 3;
pub const GPU_LUTSCALER_0_25x: GPU_LIGHTLUTSCALER = 6;
pub const GPU_LUTSCALER_0_5x: GPU_LIGHTLUTSCALER = 7;
pub type GPU_LIGHTLUTSCALER = u32;
pub const GPU_LUTSELECT_COMMON: GPU_LIGHTLUTSELECT = 0;
pub const GPU_LUTSELECT_SP: GPU_LIGHTLUTSELECT = 1;
pub const GPU_LUTSELECT_DA: GPU_LIGHTLUTSELECT = 2;
pub type GPU_LIGHTLUTSELECT = u32;
pub const GPU_NO_FOG: GPU_FOGMODE = 0;
pub const GPU_FOG: GPU_FOGMODE = 5;
pub const GPU_GAS: GPU_FOGMODE = 7;
pub type GPU_FOGMODE = u32;
pub const GPU_PLAIN_DENSITY: GPU_GASMODE = 0;
pub const GPU_DEPTH_DENSITY: GPU_GASMODE = 1;
pub type GPU_GASMODE = u32;
pub const GPU_GAS_DENSITY: GPU_GASLUTINPUT = 0;
pub const GPU_GAS_LIGHT_FACTOR: GPU_GASLUTINPUT = 1;
pub type GPU_GASLUTINPUT = u32;
pub const GPU_TRIANGLES: GPU_Primitive_t = 0;
pub const GPU_TRIANGLE_STRIP: GPU_Primitive_t = 256;
pub const GPU_TRIANGLE_FAN: GPU_Primitive_t = 512;
pub const GPU_GEOMETRY_PRIM: GPU_Primitive_t = 768;
pub type GPU_Primitive_t = u32;
pub const GPU_VERTEX_SHADER: GPU_SHADER_TYPE = 0;
pub const GPU_GEOMETRY_SHADER: GPU_SHADER_TYPE = 1;
pub type GPU_SHADER_TYPE = u32;
extern "C" {
    pub static mut gpuCmdBuf: *mut u32;
}
extern "C" {
    pub static mut gpuCmdBufSize: u32;
}
extern "C" {
    pub static mut gpuCmdBufOffset: u32;
}
extern "C" {
    pub fn GPUCMD_AddRawCommands(cmd: *const u32, size: u32);
}
extern "C" {
    pub fn GPUCMD_Add(header: u32, param: *const u32, paramlength: u32);
}
extern "C" {
    pub fn GPUCMD_Split(addr: *mut *mut u32, size: *mut u32);
}
extern "C" {
    pub fn f32tof16(f: f32) -> u32;
}
extern "C" {
    pub fn f32tof20(f: f32) -> u32;
}
extern "C" {
    pub fn f32tof24(f: f32) -> u32;
}
extern "C" {
    pub fn f32tof31(f: f32) -> u32;
}
pub const VERTEX_SHDR: DVLE_type = 0;
pub const GEOMETRY_SHDR: DVLE_type = 1;
pub type DVLE_type = u32;
pub const DVLE_CONST_BOOL: DVLE_constantType = 0;
pub const DVLE_CONST_u8: DVLE_constantType = 1;
pub const DVLE_CONST_FLOAT24: DVLE_constantType = 2;
pub type DVLE_constantType = u32;
pub const RESULT_POSITION: DVLE_outputAttribute_t = 0;
pub const RESULT_NORMALQUAT: DVLE_outputAttribute_t = 1;
pub const RESULT_COLOR: DVLE_outputAttribute_t = 2;
pub const RESULT_TEXCOORD0: DVLE_outputAttribute_t = 3;
pub const RESULT_TEXCOORD0W: DVLE_outputAttribute_t = 4;
pub const RESULT_TEXCOORD1: DVLE_outputAttribute_t = 5;
pub const RESULT_TEXCOORD2: DVLE_outputAttribute_t = 6;
pub const RESULT_VIEW: DVLE_outputAttribute_t = 8;
pub const RESULT_DUMMY: DVLE_outputAttribute_t = 9;
pub type DVLE_outputAttribute_t = u32;
pub const GSH_POINT: DVLE_geoShaderMode = 0;
pub const GSH_VARIABLE_PRIM: DVLE_geoShaderMode = 1;
pub const GSH_FIXED_PRIM: DVLE_geoShaderMode = 2;
pub type DVLE_geoShaderMode = u32;
#[repr(C)]
pub struct DVLP_s {
    pub codeSize: u32,
    pub codeData: *mut u32,
    pub opdescSize: u32,
    pub opcdescData: *mut u32,
}
#[repr(C)]
pub struct DVLE_constEntry_s {
    pub type_: u16,
    pub id: u16,
    pub data: [u32; 4usize],
}
#[repr(C)]
pub struct DVLE_outEntry_s {
    pub type_: u16,
    pub regID: u16,
    pub mask: u8,
    pub unk: [u8; 3usize],
}
#[repr(C)]
pub struct DVLE_uniformEntry_s {
    pub symbolOffset: u32,
    pub startReg: u16,
    pub endReg: u16,
}
#[repr(C)]
pub struct DVLE_s {
    pub type_: DVLE_type,
    pub mergeOutmaps: bool,
    pub gshMode: DVLE_geoShaderMode,
    pub gshFixedVtxStart: u8,
    pub gshVariableVtxNum: u8,
    pub gshFixedVtxNum: u8,
    pub dvlp: *mut DVLP_s,
    pub mainOffset: u32,
    pub endmainOffset: u32,
    pub constTableSize: u32,
    pub constTableData: *mut DVLE_constEntry_s,
    pub outTableSize: u32,
    pub outTableData: *mut DVLE_outEntry_s,
    pub uniformTableSize: u32,
    pub uniformTableData: *mut DVLE_uniformEntry_s,
    pub symbolTableData: *mut ::libc::c_char,
    pub outmapMask: u8,
    pub outmapData: [u32; 8usize],
    pub outmapMode: u32,
    pub outmapClock: u32,
}
#[repr(C)]
pub struct DVLB_s {
    pub numDVLE: u32,
    pub DVLP: DVLP_s,
    pub DVLE: *mut DVLE_s,
}
extern "C" {
    pub fn DVLB_ParseFile(shbinData: *mut u32, shbinSize: u32) -> *mut DVLB_s;
}
extern "C" {
    pub fn DVLB_Free(dvlb: *mut DVLB_s);
}
extern "C" {
    pub fn DVLE_GetUniformRegister(dvle: *mut DVLE_s, name: *const ::libc::c_char) -> s8;
}
extern "C" {
    pub fn DVLE_GenerateOutmap(dvle: *mut DVLE_s);
}
#[repr(C)]
pub struct float24Uniform_s {
    pub id: u32,
    pub data: [u32; 3usize],
}
#[repr(C)]
pub struct shaderInstance_s {
    pub dvle: *mut DVLE_s,
    pub boolUniforms: u16,
    pub boolUniformMask: u16,
    pub intUniforms: [u32; 4usize],
    pub float24Uniforms: *mut float24Uniform_s,
    pub intUniformMask: u8,
    pub numFloat24Uniforms: u8,
}
#[repr(C)]
pub struct shaderProgram_s {
    pub vertexShader: *mut shaderInstance_s,
    pub geometryShader: *mut shaderInstance_s,
    pub geoShaderInputPermutation: [u32; 2usize],
    pub geoShaderInputStride: u8,
}
extern "C" {
    pub fn shaderInstanceInit(si: *mut shaderInstance_s, dvle: *mut DVLE_s) -> Result;
}
extern "C" {
    pub fn shaderInstanceFree(si: *mut shaderInstance_s) -> Result;
}
extern "C" {
    pub fn shaderInstanceSetBool(
        si: *mut shaderInstance_s,
        id: ::libc::c_int,
        value: bool,
    ) -> Result;
}
extern "C" {
    pub fn shaderInstanceGetBool(
        si: *mut shaderInstance_s,
        id: ::libc::c_int,
        value: *mut bool,
    ) -> Result;
}
extern "C" {
    pub fn shaderInstanceGetUniformLocation(
        si: *mut shaderInstance_s,
        name: *const ::libc::c_char,
    ) -> s8;
}
extern "C" {
    pub fn shaderProgramInit(sp: *mut shaderProgram_s) -> Result;
}
extern "C" {
    pub fn shaderProgramFree(sp: *mut shaderProgram_s) -> Result;
}
extern "C" {
    pub fn shaderProgramSetVsh(sp: *mut shaderProgram_s, dvle: *mut DVLE_s) -> Result;
}
extern "C" {
    pub fn shaderProgramSetGsh(sp: *mut shaderProgram_s, dvle: *mut DVLE_s, stride: u8) -> Result;
}
extern "C" {
    pub fn shaderProgramSetGshInputPermutation(
        sp: *mut shaderProgram_s,
        permutation: u64,
    ) -> Result;
}
extern "C" {
    pub fn shaderProgramConfigure(
        sp: *mut shaderProgram_s,
        sendVshCode: bool,
        sendGshCode: bool,
    ) -> Result;
}
extern "C" {
    pub fn shaderProgramUse(sp: *mut shaderProgram_s) -> Result;
}
pub const NDSP_OUTPUT_MONO: ndspOutputMode = 0;
pub const NDSP_OUTPUT_STEREO: ndspOutputMode = 1;
pub const NDSP_OUTPUT_SURROUND: ndspOutputMode = 2;
pub type ndspOutputMode = u32;
pub const NDSP_CLIP_NORMAL: ndspClippingMode = 0;
pub const NDSP_CLIP_SOFT: ndspClippingMode = 1;
pub type ndspClippingMode = u32;
pub const NDSP_SPKPOS_SQUARE: ndspSpeakerPos = 0;
pub const NDSP_SPKPOS_WIDE: ndspSpeakerPos = 1;
pub const NDSP_SPKPOS_NUM: ndspSpeakerPos = 2;
pub type ndspSpeakerPos = u32;
#[repr(C)]
pub struct ndspAdpcmData {
    pub index: u16,
    pub history0: s16,
    pub history1: s16,
}
pub type ndspWaveBuf = tag_ndspWaveBuf;
pub const NDSP_WBUF_FREE: _bindgen_ty_25 = 0;
pub const NDSP_WBUF_QUEUED: _bindgen_ty_25 = 1;
pub const NDSP_WBUF_PLAYING: _bindgen_ty_25 = 2;
pub const NDSP_WBUF_DONE: _bindgen_ty_25 = 3;
pub type _bindgen_ty_25 = u32;
#[repr(C)]
pub struct tag_ndspWaveBuf {
    pub __bindgen_anon_1: tag_ndspWaveBuf__bindgen_ty_1,
    pub nsamples: u32,
    pub adpcm_data: *mut ndspAdpcmData,
    pub offset: u32,
    pub looping: bool,
    pub status: u8,
    pub sequence_id: u16,
    pub next: *mut ndspWaveBuf,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tag_ndspWaveBuf__bindgen_ty_1 {
    pub data_pcm8: *mut s8,
    pub data_pcm16: *mut s16,
    pub data_adpcm: *mut u8,
    pub data_vaddr: *const ::libc::c_void,
    _bindgen_union_align: u32,
}
pub type ndspCallback = ::core::option::Option<unsafe extern "C" fn(data: *mut ::libc::c_void)>;
pub type ndspAuxCallback = ::core::option::Option<
    unsafe extern "C" fn(
        data: *mut ::libc::c_void,
        nsamples: ::libc::c_int,
        samples: *mut *mut ::libc::c_void,
    ),
>;
extern "C" {
    pub fn ndspUseComponent(binary: *const ::libc::c_void, size: u32, progMask: u16, dataMask: u16);
}
extern "C" {
    pub fn ndspInit() -> Result;
}
extern "C" {
    pub fn ndspExit();
}
extern "C" {
    pub fn ndspGetDroppedFrames() -> u32;
}
extern "C" {
    pub fn ndspGetFrameCount() -> u32;
}
extern "C" {
    pub fn ndspSetMasterVol(volume: f32);
}
extern "C" {
    pub fn ndspSetOutputMode(mode: ndspOutputMode);
}
extern "C" {
    pub fn ndspSetClippingMode(mode: ndspClippingMode);
}
extern "C" {
    pub fn ndspSetOutputCount(count: ::libc::c_int);
}
extern "C" {
    pub fn ndspSetCapture(capture: *mut ndspWaveBuf);
}
extern "C" {
    pub fn ndspSetCallback(callback: ndspCallback, data: *mut ::libc::c_void);
}
extern "C" {
    pub fn ndspSurroundSetDepth(depth: u16);
}
extern "C" {
    pub fn ndspSurroundSetPos(pos: ndspSpeakerPos);
}
extern "C" {
    pub fn ndspSurroundSetRearRatio(ratio: u16);
}
extern "C" {
    pub fn ndspAuxSetEnable(id: ::libc::c_int, enable: bool);
}
extern "C" {
    pub fn ndspAuxSetFrontBypass(id: ::libc::c_int, bypass: bool);
}
extern "C" {
    pub fn ndspAuxSetVolume(id: ::libc::c_int, volume: f32);
}
extern "C" {
    pub fn ndspAuxSetCallback(
        id: ::libc::c_int,
        callback: ndspAuxCallback,
        data: *mut ::libc::c_void,
    );
}
pub const NDSP_ENCODING_PCM8: _bindgen_ty_26 = 0;
pub const NDSP_ENCODING_PCM16: _bindgen_ty_26 = 1;
pub const NDSP_ENCODING_ADPCM: _bindgen_ty_26 = 2;
pub type _bindgen_ty_26 = u32;
pub const NDSP_FORMAT_MONO_PCM8: _bindgen_ty_27 = 1;
pub const NDSP_FORMAT_MONO_PCM16: _bindgen_ty_27 = 5;
pub const NDSP_FORMAT_MONO_ADPCM: _bindgen_ty_27 = 9;
pub const NDSP_FORMAT_STEREO_PCM8: _bindgen_ty_27 = 2;
pub const NDSP_FORMAT_STEREO_PCM16: _bindgen_ty_27 = 6;
pub const NDSP_FORMAT_PCM8: _bindgen_ty_27 = 1;
pub const NDSP_FORMAT_PCM16: _bindgen_ty_27 = 5;
pub const NDSP_FORMAT_ADPCM: _bindgen_ty_27 = 9;
pub const NDSP_FRONT_BYPASS: _bindgen_ty_27 = 16;
pub const NDSP_3D_SURROUND_PREPROCESSED: _bindgen_ty_27 = 64;
pub type _bindgen_ty_27 = u32;
pub const NDSP_INTERP_POLYPHASE: ndspInterpType = 0;
pub const NDSP_INTERP_LINEAR: ndspInterpType = 1;
pub const NDSP_INTERP_NONE: ndspInterpType = 2;
pub type ndspInterpType = u32;
extern "C" {
    pub fn ndspChnReset(id: ::libc::c_int);
}
extern "C" {
    pub fn ndspChnInitParams(id: ::libc::c_int);
}
extern "C" {
    pub fn ndspChnIsPlaying(id: ::libc::c_int) -> bool;
}
extern "C" {
    pub fn ndspChnGetSamplePos(id: ::libc::c_int) -> u32;
}
extern "C" {
    pub fn ndspChnGetWaveBufSeq(id: ::libc::c_int) -> u16;
}
extern "C" {
    pub fn ndspChnIsPaused(id: ::libc::c_int) -> bool;
}
extern "C" {
    pub fn ndspChnSetPaused(id: ::libc::c_int, paused: bool);
}
extern "C" {
    pub fn ndspChnSetFormat(id: ::libc::c_int, format: u16);
}
extern "C" {
    pub fn ndspChnSetInterp(id: ::libc::c_int, type_: ndspInterpType);
}
extern "C" {
    pub fn ndspChnSetRate(id: ::libc::c_int, rate: f32);
}
extern "C" {
    pub fn ndspChnSetMix(id: ::libc::c_int, mix: *mut f32);
}
extern "C" {
    pub fn ndspChnSetAdpcmCoefs(id: ::libc::c_int, coefs: *mut u16);
}
extern "C" {
    pub fn ndspChnWaveBufClear(id: ::libc::c_int);
}
extern "C" {
    pub fn ndspChnWaveBufAdd(id: ::libc::c_int, buf: *mut ndspWaveBuf);
}
extern "C" {
    pub fn ndspChnIirMonoSetEnable(id: ::libc::c_int, enable: bool);
}
extern "C" {
    pub fn ndspChnIirMonoSetParamsCustomFilter(
        id: ::libc::c_int,
        a0: f32,
        a1: f32,
        b0: f32,
    ) -> bool;
}
extern "C" {
    pub fn ndspChnIirMonoSetParamsLowPassFilter(id: ::libc::c_int, f0: f32) -> bool;
}
extern "C" {
    pub fn ndspChnIirMonoSetParamsHighPassFilter(id: ::libc::c_int, f0: f32) -> bool;
}
extern "C" {
    pub fn ndspChnIirBiquadSetEnable(id: ::libc::c_int, enable: bool);
}
extern "C" {
    pub fn ndspChnIirBiquadSetParamsCustomFilter(
        id: ::libc::c_int,
        a0: f32,
        a1: f32,
        a2: f32,
        b0: f32,
        b1: f32,
        b2: f32,
    ) -> bool;
}
extern "C" {
    pub fn ndspChnIirBiquadSetParamsLowPassFilter(id: ::libc::c_int, f0: f32, Q: f32) -> bool;
}
extern "C" {
    pub fn ndspChnIirBiquadSetParamsHighPassFilter(id: ::libc::c_int, f0: f32, Q: f32) -> bool;
}
extern "C" {
    pub fn ndspChnIirBiquadSetParamsBandPassFilter(id: ::libc::c_int, f0: f32, Q: f32) -> bool;
}
extern "C" {
    pub fn ndspChnIirBiquadSetParamsNotchFilter(id: ::libc::c_int, f0: f32, Q: f32) -> bool;
}
extern "C" {
    pub fn ndspChnIirBiquadSetParamsPeakingEqualizer(
        id: ::libc::c_int,
        f0: f32,
        Q: f32,
        gain: f32,
    ) -> bool;
}
pub const SWKBD_TYPE_NORMAL: SwkbdType = 0;
pub const SWKBD_TYPE_QWERTY: SwkbdType = 1;
pub const SWKBD_TYPE_NUMPAD: SwkbdType = 2;
pub const SWKBD_TYPE_WESTERN: SwkbdType = 3;
pub type SwkbdType = u32;
pub const SWKBD_ANYTHING: SwkbdValidInput = 0;
pub const SWKBD_NOTEMPTY: SwkbdValidInput = 1;
pub const SWKBD_NOTEMPTY_NOTBLANK: SwkbdValidInput = 2;
pub const SWKBD_NOTBLANK_NOTEMPTY: SwkbdValidInput = 2;
pub const SWKBD_NOTBLANK: SwkbdValidInput = 3;
pub const SWKBD_FIXEDLEN: SwkbdValidInput = 4;
pub type SwkbdValidInput = u32;
pub const SWKBD_BUTTON_LEFT: SwkbdButton = 0;
pub const SWKBD_BUTTON_MIDDLE: SwkbdButton = 1;
pub const SWKBD_BUTTON_RIGHT: SwkbdButton = 2;
pub const SWKBD_BUTTON_CONFIRM: SwkbdButton = 2;
pub const SWKBD_BUTTON_NONE: SwkbdButton = 3;
pub type SwkbdButton = u32;
pub const SWKBD_PASSWORD_NONE: SwkbdPasswordMode = 0;
pub const SWKBD_PASSWORD_HIDE: SwkbdPasswordMode = 1;
pub const SWKBD_PASSWORD_HIDE_DELAY: SwkbdPasswordMode = 2;
pub type SwkbdPasswordMode = u32;
pub const SWKBD_FILTER_DIGITS: _bindgen_ty_28 = 1;
pub const SWKBD_FILTER_AT: _bindgen_ty_28 = 2;
pub const SWKBD_FILTER_PERCENT: _bindgen_ty_28 = 4;
pub const SWKBD_FILTER_BACKSLASH: _bindgen_ty_28 = 8;
pub const SWKBD_FILTER_PROFANITY: _bindgen_ty_28 = 16;
pub const SWKBD_FILTER_CALLBACK: _bindgen_ty_28 = 32;
pub type _bindgen_ty_28 = u32;
pub const SWKBD_PARENTAL: _bindgen_ty_29 = 1;
pub const SWKBD_DARKEN_TOP_SCREEN: _bindgen_ty_29 = 2;
pub const SWKBD_PREDICTIVE_INPUT: _bindgen_ty_29 = 4;
pub const SWKBD_MULTILINE: _bindgen_ty_29 = 8;
pub const SWKBD_FIXED_WIDTH: _bindgen_ty_29 = 16;
pub const SWKBD_ALLOW_HOME: _bindgen_ty_29 = 32;
pub const SWKBD_ALLOW_RESET: _bindgen_ty_29 = 64;
pub const SWKBD_ALLOW_POWER: _bindgen_ty_29 = 128;
pub const SWKBD_DEFAULT_QWERTY: _bindgen_ty_29 = 512;
pub type _bindgen_ty_29 = u32;
pub const SWKBD_CALLBACK_OK: SwkbdCallbackResult = 0;
pub const SWKBD_CALLBACK_CLOSE: SwkbdCallbackResult = 1;
pub const SWKBD_CALLBACK_CONTINUE: SwkbdCallbackResult = 2;
pub type SwkbdCallbackResult = u32;
pub const SWKBD_NONE: SwkbdResult = -1;
pub const SWKBD_INVALID_INPUT: SwkbdResult = -2;
pub const SWKBD_OUTOFMEM: SwkbdResult = -3;
pub const SWKBD_D0_CLICK: SwkbdResult = 0;
pub const SWKBD_D1_CLICK0: SwkbdResult = 1;
pub const SWKBD_D1_CLICK1: SwkbdResult = 2;
pub const SWKBD_D2_CLICK0: SwkbdResult = 3;
pub const SWKBD_D2_CLICK1: SwkbdResult = 4;
pub const SWKBD_D2_CLICK2: SwkbdResult = 5;
pub const SWKBD_HOMEPRESSED: SwkbdResult = 10;
pub const SWKBD_RESETPRESSED: SwkbdResult = 11;
pub const SWKBD_POWERPRESSED: SwkbdResult = 12;
pub const SWKBD_PARENTAL_OK: SwkbdResult = 20;
pub const SWKBD_PARENTAL_FAIL: SwkbdResult = 21;
pub const SWKBD_BANNED_INPUT: SwkbdResult = 30;
pub type SwkbdResult = i32;
#[repr(C)]
pub struct SwkbdDictWord {
    pub reading: [u16; 41usize],
    pub word: [u16; 41usize],
    pub language: u8,
    pub all_languages: bool,
}
pub type SwkbdCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        user: *mut ::libc::c_void,
        ppMessage: *mut *const ::libc::c_char,
        text: *const ::libc::c_char,
        textlen: usize,
    ) -> SwkbdCallbackResult,
>;
#[repr(C)]
pub struct SwkbdStatusData {
    pub data: [u32; 17usize],
}
#[repr(C)]
pub struct SwkbdLearningData {
    pub data: [u32; 10523usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SwkbdExtra {
    pub initial_text: *const ::libc::c_char,
    pub dict: *const SwkbdDictWord,
    pub status_data: *mut SwkbdStatusData,
    pub learning_data: *mut SwkbdLearningData,
    pub callback: SwkbdCallbackFn,
    pub callback_user: *mut ::libc::c_void,
}
#[repr(C)]
pub struct SwkbdState {
    pub type_: ::libc::c_int,
    pub num_buttons_m1: ::libc::c_int,
    pub valid_input: ::libc::c_int,
    pub password_mode: ::libc::c_int,
    pub is_parental_screen: ::libc::c_int,
    pub darken_top_screen: ::libc::c_int,
    pub filter_flags: u32,
    pub save_state_flags: u32,
    pub max_text_len: u16,
    pub dict_word_count: u16,
    pub max_digits: u16,
    pub button_text: [[u16; 17usize]; 3usize],
    pub numpad_keys: [u16; 2usize],
    pub hint_text: [u16; 65usize],
    pub predictive_input: bool,
    pub multiline: bool,
    pub fixed_width: bool,
    pub allow_home: bool,
    pub allow_reset: bool,
    pub allow_power: bool,
    pub unknown: bool,
    pub default_qwerty: bool,
    pub button_submits_text: [bool; 4usize],
    pub language: u16,
    pub initial_text_offset: ::libc::c_int,
    pub dict_offset: ::libc::c_int,
    pub initial_status_offset: ::libc::c_int,
    pub initial_learning_offset: ::libc::c_int,
    pub shared_memory_size: usize,
    pub version: u32,
    pub result: SwkbdResult,
    pub status_offset: ::libc::c_int,
    pub learning_offset: ::libc::c_int,
    pub text_offset: ::libc::c_int,
    pub text_length: u16,
    pub callback_result: ::libc::c_int,
    pub callback_msg: [u16; 257usize],
    pub skip_at_check: bool,
    pub __bindgen_anon_1: SwkbdState__bindgen_ty_1,
}
#[repr(C)]
pub struct SwkbdState__bindgen_ty_1 {
    pub reserved: __BindgenUnionField<[u8; 171usize]>,
    pub extra: __BindgenUnionField<SwkbdExtra>,
    pub bindgen_union_field: [u32; 43usize],
}
extern "C" {
    pub fn swkbdInit(
        swkbd: *mut SwkbdState,
        type_: SwkbdType,
        numButtons: ::libc::c_int,
        maxTextLength: ::libc::c_int,
    );
}
extern "C" {
    pub fn swkbdSetFeatures(swkbd: *mut SwkbdState, features: u32);
}
extern "C" {
    pub fn swkbdSetHintText(swkbd: *mut SwkbdState, text: *const ::libc::c_char);
}
extern "C" {
    pub fn swkbdSetButton(
        swkbd: *mut SwkbdState,
        button: SwkbdButton,
        text: *const ::libc::c_char,
        submit: bool,
    );
}
extern "C" {
    pub fn swkbdSetInitialText(swkbd: *mut SwkbdState, text: *const ::libc::c_char);
}
extern "C" {
    pub fn swkbdSetDictWord(
        word: *mut SwkbdDictWord,
        reading: *const ::libc::c_char,
        text: *const ::libc::c_char,
    );
}
extern "C" {
    pub fn swkbdSetDictionary(
        swkbd: *mut SwkbdState,
        dict: *const SwkbdDictWord,
        wordCount: ::libc::c_int,
    );
}
extern "C" {
    pub fn swkbdSetStatusData(
        swkbd: *mut SwkbdState,
        data: *mut SwkbdStatusData,
        in_: bool,
        out: bool,
    );
}
extern "C" {
    pub fn swkbdSetLearningData(
        swkbd: *mut SwkbdState,
        data: *mut SwkbdLearningData,
        in_: bool,
        out: bool,
    );
}
extern "C" {
    pub fn swkbdSetFilterCallback(
        swkbd: *mut SwkbdState,
        callback: SwkbdCallbackFn,
        user: *mut ::libc::c_void,
    );
}
extern "C" {
    pub fn swkbdInputText(
        swkbd: *mut SwkbdState,
        buf: *mut ::libc::c_char,
        bufsize: usize,
    ) -> SwkbdButton;
}
pub const ERROR_LANGUAGE_FLAG: _bindgen_ty_30 = 256;
pub const ERROR_WORD_WRAP_FLAG: _bindgen_ty_30 = 512;
pub type _bindgen_ty_30 = u32;
pub const ERROR_CODE: errorType = 0;
pub const ERROR_TEXT: errorType = 1;
pub const ERROR_EULA: errorType = 2;
pub const ERROR_TYPE_EULA_FIRST_BOOT: errorType = 3;
pub const ERROR_TYPE_EULA_DRAW_ONLY: errorType = 4;
pub const ERROR_TYPE_AGREE: errorType = 5;
pub const ERROR_CODE_LANGUAGE: errorType = 256;
pub const ERROR_TEXT_LANGUAGE: errorType = 257;
pub const ERROR_EULA_LANGUAGE: errorType = 258;
pub const ERROR_TEXT_WORD_WRAP: errorType = 513;
pub const ERROR_TEXT_LANGUAGE_WORD_WRAP: errorType = 769;
pub type errorType = u32;
pub const ERROR_NORMAL: errorScreenFlag = 0;
pub const ERROR_STEREO: errorScreenFlag = 1;
pub type errorScreenFlag = u32;
pub const ERROR_UNKNOWN: errorReturnCode = -1;
pub const ERROR_NONE: errorReturnCode = 0;
pub const ERROR_SUCCESS: errorReturnCode = 1;
pub const ERROR_NOT_SUPPORTED: errorReturnCode = 2;
pub const ERROR_HOME_BUTTON: errorReturnCode = 10;
pub const ERROR_SOFTWARE_RESET: errorReturnCode = 11;
pub const ERROR_POWER_BUTTON: errorReturnCode = 12;
pub type errorReturnCode = i32;
#[repr(C)]
pub struct errorConf {
    pub type_: errorType,
    pub errorCode: ::libc::c_int,
    pub upperScreenFlag: errorScreenFlag,
    pub useLanguage: u16,
    pub Text: [u16; 1900usize],
    pub homeButton: bool,
    pub softwareReset: bool,
    pub appJump: bool,
    pub returnCode: errorReturnCode,
    pub eulaVersion: u16,
}
extern "C" {
    pub fn errorInit(err: *mut errorConf, type_: errorType, lang: CFG_Language);
}
extern "C" {
    pub fn errorCode(err: *mut errorConf, error: ::libc::c_int);
}
extern "C" {
    pub fn errorText(err: *mut errorConf, text: *const ::libc::c_char);
}
extern "C" {
    pub fn errorDisp(err: *mut errorConf);
}
#[repr(C)]
pub struct MiiSelectorConf {
    pub enable_cancel_button: ::libc::c_char,
    pub enable_selecting_guests: ::libc::c_char,
    pub show_on_top_screen: ::libc::c_char,
    pub _unk0x3: [::libc::c_char; 5usize],
    pub title: [u16; 64usize],
    pub _unk0x88: [::libc::c_char; 4usize],
    pub show_guest_page: ::libc::c_char,
    pub _unk0x8D: [::libc::c_char; 3usize],
    pub initial_index: u32,
    pub mii_guest_whitelist: [::libc::c_char; 6usize],
    pub mii_whitelist: [::libc::c_char; 100usize],
    pub _unk0xFE: u16,
    pub magic: u32,
}
#[repr(C)]
pub struct MiiSelectorReturn {
    pub no_mii_selected: u32,
    pub guest_mii_was_selected: u32,
    pub guest_mii_index: u32,
    pub mii: [::libc::c_char; 92usize],
    pub _pad0x68: u16,
    pub checksum: u16,
    pub guest_mii_name: [u16; 12usize],
}
extern "C" {
    pub fn miiSelectorLaunch(
        conf: *const MiiSelectorConf,
        returnbuf: *mut MiiSelectorReturn,
    ) -> Result;
}
extern "C" {
    pub fn miiSelectorChecksumIsValid(returnbuf: *const MiiSelectorReturn) -> bool;
}
#[repr(C)]
pub struct sdmc_dir_t {
    pub magic: u32,
    pub fd: Handle,
    pub index: isize,
    pub size: usize,
    pub entry_data: [FS_DirectoryEntry; 32usize],
}
extern "C" {
    pub fn sdmcInit() -> Result;
}
extern "C" {
    pub fn sdmcWriteSafe(enable: bool);
}
extern "C" {
    pub fn sdmcExit() -> Result;
}
extern "C" {
    pub fn sdmc_getmtime(name: *const ::libc::c_char, mtime: *mut u64) -> Result;
}
#[repr(C)]
pub struct romfs_header {
    pub headerSize: u32,
    pub dirHashTableOff: u32,
    pub dirHashTableSize: u32,
    pub dirTableOff: u32,
    pub dirTableSize: u32,
    pub fileHashTableOff: u32,
    pub fileHashTableSize: u32,
    pub fileTableOff: u32,
    pub fileTableSize: u32,
    pub fileDataOff: u32,
}
#[repr(C)]
pub struct romfs_dir {
    pub parent: u32,
    pub sibling: u32,
    pub childDir: u32,
    pub childFile: u32,
    pub nextHash: u32,
    pub nameLen: u32,
    pub name: __IncompleteArrayField<u16>,
}
#[repr(C)]
pub struct romfs_file {
    pub parent: u32,
    pub sibling: u32,
    pub dataOff: u64,
    pub dataSize: u64,
    pub nextHash: u32,
    pub nameLen: u32,
    pub name: __IncompleteArrayField<u16>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct romfs_mount {
    _unused: [u8; 0],
}
extern "C" {
    pub fn romfsMount(mount: *mut *mut romfs_mount) -> Result;
}
extern "C" {
    pub fn romfsMountFromFile(file: Handle, offset: u32, mount: *mut *mut romfs_mount) -> Result;
}
extern "C" {
    pub fn romfsBind(mount: *mut romfs_mount) -> Result;
}
extern "C" {
    pub fn romfsUnmount(mount: *mut romfs_mount) -> Result;
}
#[repr(C)]
pub struct charWidthInfo_s {
    pub left: s8,
    pub glyphWidth: u8,
    pub charWidth: u8,
}
#[repr(C)]
pub struct TGLP_s {
    pub cellWidth: u8,
    pub cellHeight: u8,
    pub baselinePos: u8,
    pub maxCharWidth: u8,
    pub sheetSize: u32,
    pub nSheets: u16,
    pub sheetFmt: u16,
    pub nRows: u16,
    pub nLines: u16,
    pub sheetWidth: u16,
    pub sheetHeight: u16,
    pub sheetData: *mut u8,
}
pub type CWDH_s = tag_CWDH_s;
#[repr(C)]
pub struct tag_CWDH_s {
    pub startIndex: u16,
    pub endIndex: u16,
    pub next: *mut CWDH_s,
    pub widths: __IncompleteArrayField<charWidthInfo_s>,
}
pub const CMAP_TYPE_DIRECT: _bindgen_ty_31 = 0;
pub const CMAP_TYPE_TABLE: _bindgen_ty_31 = 1;
pub const CMAP_TYPE_SCAN: _bindgen_ty_31 = 2;
pub type _bindgen_ty_31 = u32;
pub type CMAP_s = tag_CMAP_s;
#[repr(C)]
pub struct tag_CMAP_s {
    pub codeBegin: u16,
    pub codeEnd: u16,
    pub mappingMethod: u16,
    pub reserved: u16,
    pub next: *mut CMAP_s,
    pub __bindgen_anon_1: tag_CMAP_s__bindgen_ty_1,
}
#[repr(C)]
pub struct tag_CMAP_s__bindgen_ty_1 {
    pub indexOffset: __BindgenUnionField<u16>,
    pub indexTable: __BindgenUnionField<[u16; 0usize]>,
    pub __bindgen_anon_1: __BindgenUnionField<tag_CMAP_s__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: u16,
}
#[repr(C)]
pub struct tag_CMAP_s__bindgen_ty_1__bindgen_ty_1 {
    pub nScanEntries: u16,
    pub scanEntries: __IncompleteArrayField<tag_CMAP_s__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>,
}
#[repr(C)]
pub struct tag_CMAP_s__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub code: u16,
    pub glyphIndex: u16,
}
#[repr(C)]
pub struct FINF_s {
    pub signature: u32,
    pub sectionSize: u32,
    pub fontType: u8,
    pub lineFeed: u8,
    pub alterCharIndex: u16,
    pub defaultWidth: charWidthInfo_s,
    pub encoding: u8,
    pub tglp: *mut TGLP_s,
    pub cwdh: *mut CWDH_s,
    pub cmap: *mut CMAP_s,
    pub height: u8,
    pub width: u8,
    pub ascent: u8,
    pub padding: u8,
}
#[repr(C)]
pub struct CFNT_s {
    pub signature: u32,
    pub endianness: u16,
    pub headerSize: u16,
    pub version: u32,
    pub fileSize: u32,
    pub nBlocks: u32,
    pub finf: FINF_s,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fontGlyphPos_s {
    pub sheetIndex: ::libc::c_int,
    pub xOffset: f32,
    pub xAdvance: f32,
    pub width: f32,
    pub texcoord: fontGlyphPos_s__bindgen_ty_1,
    pub vtxcoord: fontGlyphPos_s__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fontGlyphPos_s__bindgen_ty_1 {
    pub left: f32,
    pub top: f32,
    pub right: f32,
    pub bottom: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fontGlyphPos_s__bindgen_ty_2 {
    pub left: f32,
    pub top: f32,
    pub right: f32,
    pub bottom: f32,
}
pub const GLYPH_POS_CALC_VTXCOORD: _bindgen_ty_32 = 1;
pub const GLYPH_POS_AT_BASELINE: _bindgen_ty_32 = 2;
pub const GLYPH_POS_Y_POINTS_UP: _bindgen_ty_32 = 4;
pub type _bindgen_ty_32 = u32;
extern "C" {
    pub fn fontEnsureMapped() -> Result;
}
extern "C" {
    pub fn fontGlyphIndexFromCodePoint(codePoint: u32) -> ::libc::c_int;
}
extern "C" {
    pub fn fontGetCharWidthInfo(glyphIndex: ::libc::c_int) -> *mut charWidthInfo_s;
}
extern "C" {
    pub fn fontCalcGlyphPos(
        out: *mut fontGlyphPos_s,
        glyphIndex: ::libc::c_int,
        flags: u32,
        scaleX: f32,
        scaleY: f32,
    );
}
